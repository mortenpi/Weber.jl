<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Adaptive Tracks · Weber.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Weber.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><span class="toctext">User guide</span><ul><li><a class="toctext" href="../start/">Getting Started</a></li><li><a class="toctext" href="../trial_guide/">Trial Creation</a></li><li><a class="toctext" href="../stimulus/">Stimulus Generation</a></li><li class="current"><a class="toctext" href>Adaptive Tracks</a><ul class="internal"><li><a class="toctext" href="#Creating-the-Adapter-1">Creating the Adapter</a></li><li><a class="toctext" href="#Generating-Stimuli-1">Generating Stimuli</a></li><li><a class="toctext" href="#Collecting-Responses-1">Collecting Responses</a></li><li><a class="toctext" href="#Generating-Trials-1">Generating Trials</a></li><li class="toplevel"><a class="toctext" href="#Reporting-the-Threshold-1">Reporting the Threshold</a></li><li class="toplevel"><a class="toctext" href="#Custom-Adaptive-Tracking-Algorithms-1">Custom Adaptive Tracking Algorithms</a></li></ul></li><li><a class="toctext" href="../advanced/">Advanced Experiments</a></li><li><a class="toctext" href="../extend/">Extending Weber</a></li></ul></li><li><span class="toctext">Reference</span><ul><li><a class="toctext" href="../experiment/">Experiments</a></li><li><a class="toctext" href="../trials/">Trials</a></li><li><a class="toctext" href="../sound/">Sound</a></li><li><a class="toctext" href="../video/">Video</a></li><li><a class="toctext" href="../event/">Events</a></li><li><a class="toctext" href="../extend_ref/">Extensions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>User guide</li><li><a href>Adaptive Tracks</a></li></ul><a class="edit-page" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/docs/src/adaptive.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Adaptive Tracks</span><a class="fa fa-bars" href="#"></a></div></header><p>Some experiments require the use of an adaptive adjustment of a stimulus based on participant responses. There are several basic adaptive tracking algorithms built into Weber, and you can also implement your own as well.</p><h1><a class="nav-anchor" id="Using-an-Adaptive-Track-1" href="#Using-an-Adaptive-Track-1">Using an Adaptive Track</a></h1><p>To use an adaptive track in your experiment, you need to make use of some of the <a href="../advanced/">advanced features</a> of Weber. In this section we&#39;ll walk through the necessary steps, using a simple frequency discrimination experiment.</p><p>In this experiment, on each trial, listeners hear a low and a high tone, separated in frequency by an adaptively adjusted delta. Their task is to indicate which tone is lower, and the delta is adjusted to determine the difference in frequency at which listeners respond with 79% accuracy. The entire example code is provided below. </p><pre><code class="language-julia">using Weber

version = v&quot;0.0.2&quot;
sid,trial_skip,adapt = @read_args(&quot;Frequency Discrimination ($version).&quot;,
                                  adapt=[:levitt,:bayes])

const atten_dB = 30
const n_trials = 60
const feedback_delay = 750ms

isresponse(e) = iskeydown(e,key&quot;p&quot;) || iskeydown(e,key&quot;q&quot;)

const standard_freq = 1kHz
const standard = attenuate(ramp(tone(standard_freq,0.1)),atten_dB)
function one_trial(adapter)
  first_lower = rand(Bool)
  resp = response(adapter,key&quot;q&quot; =&gt; &quot;first_lower&quot;,key&quot;p&quot; =&gt; &quot;second_lower&quot;,
                  correct=(first_lower ? &quot;first_lower&quot; : &quot;second_lower&quot;))

  signal() = attenuate(ramp(tone(standard_freq*(1-delta(adapter)),0.1s)),atten_dB)
  stimuli = first_lower? [signal,standard] : [standard,signal]

  [moment(feedback_delay,play,stimuli[1]),
   show_cross(),
   moment(0.9s,play,stimuli[2]),
   moment(0.1s + 0.3s,display,
          &quot;Was the first [Q] or second sound [P] lower in pitch?&quot;),
   resp,await_response(isresponse)]
end

experiment = Experiment(
  skip=trial_skip,
  columns = [
    :sid =&gt; sid,
    :condition =&gt; &quot;example&quot;,
    :version =&gt; version,
    :standard =&gt; standard_freq
  ]
)

setup(experimerntent) do
  addbreak(moment(record,&quot;start&quot;))

  addbreak(instruct(&quot;&quot;&quot;

    On each trial, you will hear two beeps. Indicate which of the two beeps you
heard was lower in pitch. Hit &#39;Q&#39; if the first beep was lower, and &#39;P&#39; if the
second beep was lower.
&quot;&quot;&quot;))

  if adapt == :levitt
    adapter = levitt_adapter(down=3,up=1,min_delta=0,max_delta=1,
                             big=2,little=sqrt(2),mult=true)
  else
    adapter = bayesian_adapter(min_delta = 0,max_delta = 0.95)
  end

  @addtrials let a = adapter
    for trial in 1:n_trials
      addtrial(one_trial(a))
    end

    # define this string during experiment setup
    # when we know what block we&#39;re on...

    function threshold_report()
      mean,sd = estimate(adapter)
      thresh = round(mean,3)*standard_freq
      thresh_sd = round(sd,3)*standard_freq

      # define this string during run time when we know
      # what the threshold estimate is.
      &quot;Threshold $(thresh)Hz (SD: $thresh_sd)\n&quot;*
      &quot;Hit spacebar to continue...&quot;
    end

    addbreak(moment(display,threshold_report,clean_whitespace=false),
             await_response(iskeydown(key&quot;:space:&quot;)))
  end

end

run(experimerntent)</code></pre><p>In what follows we&#39;ll walk through the parts of this code unique to creating an adaptive track. For more details on the basics of creating an experiment see <a href="../start/">Getting Started</a>.</p><h2><a class="nav-anchor" id="Creating-the-Adapter-1" href="#Creating-the-Adapter-1">Creating the Adapter</a></h2><pre><code class="language-julia">if adapt == :levitt
  adapter = levitt_adapter(down=3,up=1,min_delta=0,max_delta=1,
                           big=2,little=sqrt(2),mult=true)
else
  adapter = bayesian_adapter(min_delta = 0,max_delta = 0.95)
end</code></pre><p>The present experiment can be run using either of two built-in adapters: <a href="../trials/#Weber.levitt_adapter"><code>levitt_adapter</code></a> and <a href="../trials/#Weber.bayesian_adapter"><code>bayesian_adapter</code></a>. An adapter is the object you create to run an adaptive track, and defines the particular algorithm that will be used to select a new delta on each trial, based on the responses to previous deltas. </p><h2><a class="nav-anchor" id="Generating-Stimuli-1" href="#Generating-Stimuli-1">Generating Stimuli</a></h2><pre><code class="language-julia">const standard = attenuate(ramp(tone(standard_freq,0.1s)),atten_dB)
...
signal() = attenuate(ramp(tone(standard_freq*(1-delta(adapter)),0.1s)),atten_dB)
stimuli = first_lower? [signal,standard] : [standard,signal]</code></pre><p>The two stimuli presented to the listener are the standard (always at 1kHz) and the signal (1kHz - delta). The standard is always the same, and so can be generated in advance before the experiment begins. The signal must be generated during the experiment, on each trial. The next delta is queried from the adapter using <a href="../trials/#Weber.delta"><code>delta</code></a>. The signal is defined as a function that takes no arguments. When passed a function, <a href="../sound/#Weber.play"><code>play</code></a> generates the stimulus defined by that function at runtime, rather than <a href="../start/#setup_time-1">setup time</a>, which is precisely what we want in this case.</p><h2><a class="nav-anchor" id="Collecting-Responses-1" href="#Collecting-Responses-1">Collecting Responses</a></h2><pre><code class="language-julia">resp = response(adapter,key&quot;q&quot; =&gt; &quot;first_lower&quot;,key&quot;p&quot; =&gt; &quot;second_lower&quot;,
                  correct=(first_lower ? &quot;first_lower&quot; : &quot;second_lower&quot;))</code></pre><p>To update the adapter after each response, a special method of the <a href="../trials/#Weber.response"><code>response</code></a> function is used, which takes the adapter as its first argument. We also must indicate which response is correct by setting <code>correct</code> appropriately.</p><h2><a class="nav-anchor" id="Generating-Trials-1" href="#Generating-Trials-1">Generating Trials</a></h2><pre><code class="language-julia">@addtrials let a = adapter
  for trial in 1:n_trials
    addtrial(one_trial(a))
  end
  addbreak(moment(display,() -&gt; &quot;Estimated threshold: $(estimate(adapter)[1])\n&quot;,
                                &quot;Hit spacebar to exit.&quot;),
           await_response(iskeydown(key&quot;:space:&quot;)))
end</code></pre><p>To generate the trials, which depend on the run-time state of the adapter, we use the <a href="../trials/#Weber.@addtrials"><code>@addtrials</code></a> macro. Any time the behavior of listeners in one trial influences subsequent trials, this macro will be necessary. In this case it is used to signal to Weber that the trials added inside the loop depend on the run-time state of the adapter.</p><p>After all trials have been run, we report the threshold estimated by the adapter using the <a href="../trials/#Weber.estimate"><code>estimate</code></a> function, which returns both the mean and measurement error.</p><h1><a class="nav-anchor" id="Reporting-the-Threshold-1" href="#Reporting-the-Threshold-1">Reporting the Threshold</a></h1><pre><code class="language-julia"># define this string during experiment setup
# when we know what block we&#39;re on...

function threshold_report()
  mean,sd = estimate(adapter)
  thresh = round(mean,3)*standard_freq
  thresh_sd = round(sd,3)*standard_freq

  # define this string during run time when we know
  # what the threshold estimate is.
  &quot;Threshold $(thresh)Hz (SD: $thresh_sd)\n&quot;*
  &quot;Hit spacebar to continue...&quot;
end

addbreak(moment(display,threshold_report,clean_whitespace=false),
         await_response(iskeydown(key&quot;:space:&quot;)))</code></pre><p>You can report the threshold at the end of an experiment using <a href="../trials/#Weber.estimate"><code>estimate</code></a>, as above, but this isn&#39;t strictly necessary. The tricky part is to make sure you find the estimate <em>after</em> trials have been run (during run time).</p><h1><a class="nav-anchor" id="Custom-Adaptive-Tracking-Algorithms-1" href="#Custom-Adaptive-Tracking-Algorithms-1">Custom Adaptive Tracking Algorithms</a></h1><p>You can define your own adaptive tracking algorithms by defining a new type that is a child of <code>Adapter</code>. You must define an appropriate function to generate the adapter, and methods of <a href="../trials/#Weber.update!"><code>Weber.update!</code></a>, <a href="../trials/#Weber.estimate"><code>estimate</code></a> and <a href="../trials/#Weber.delta"><code>delta</code></a> for this type. Strictly speaking estimate need not be implemented, if you choose not to make use of this method in your experiment.</p><footer><hr/><a class="previous" href="../stimulus/"><span class="direction">Previous</span><span class="title">Stimulus Generation</span></a><a class="next" href="../advanced/"><span class="direction">Next</span><span class="title">Advanced Experiments</span></a></footer></article></body></html>
