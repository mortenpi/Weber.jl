{
    "docs": [
        {
            "location": "/", 
            "text": "About\n\n\nWeber is a \nJulia\n package that can be used to generate simple psychology experiments that present visual and auditory stimuli at precise times. \n\n\nWeber's emphasis is currently on auditory psychophysics, but the package has the features necessary to generate most visual stimuli one would desire as well, thanks to \nImages.jl\n. It is named after Ernst Weber. Weber runs on Windows and Mac OS X. Additional functionality can be added through \nextensions\n\n\n\n\nInstallation\n\n\nThe following instructions are designed for those new to Julia, and coding in general.\n\n\n\n\n1. Install Julia and Juno\n\n\nTo use Weber you will need to have Julia, and an appropriate code editor installed. \nFollow these instructions\n to install Julia and the Juno IDE. Juno is an extension for the code editor Atom (which these instructions will also ask you to download).\n\n\n\n\n2. Install Weber\n\n\nOnce Julia and Juno are installed, open Atom. Go to \"Open Console\" under the Julia menu.\n\n\n\n\nA console window will appear. Type \nPkg.add(\"Weber\")\n in the console and hit enter.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#about", 
            "text": "Weber is a  Julia  package that can be used to generate simple psychology experiments that present visual and auditory stimuli at precise times.   Weber's emphasis is currently on auditory psychophysics, but the package has the features necessary to generate most visual stimuli one would desire as well, thanks to  Images.jl . It is named after Ernst Weber. Weber runs on Windows and Mac OS X. Additional functionality can be added through  extensions", 
            "title": "About"
        }, 
        {
            "location": "/#installation", 
            "text": "The following instructions are designed for those new to Julia, and coding in general.", 
            "title": "Installation"
        }, 
        {
            "location": "/#1-install-julia-and-juno", 
            "text": "To use Weber you will need to have Julia, and an appropriate code editor installed.  Follow these instructions  to install Julia and the Juno IDE. Juno is an extension for the code editor Atom (which these instructions will also ask you to download).", 
            "title": "1. Install Julia and Juno"
        }, 
        {
            "location": "/#2-install-weber", 
            "text": "Once Julia and Juno are installed, open Atom. Go to \"Open Console\" under the Julia menu.   A console window will appear. Type  Pkg.add(\"Weber\")  in the console and hit enter.", 
            "title": "2. Install Weber"
        }, 
        {
            "location": "/start/", 
            "text": "In the following example, we'll run through all the basics of how to create an experiment in Weber. It's assumed you have already followed the \ndirections for installing Julia and Juno\n. First, open Atom.\n\n\nYou may want to familiarize yourself with the basics of Julia. There are a number of useful \nresources\n available to learn Julia.\n\n\n\n\nCreating a simple program\n\n\nFirst, open the Julia console, and enter the following lines of code.\n\n\nusing Weber\ncreate_new_project(\nsimple\n)\n\n\n\n\nThis will create a set of files in your current directory to get you started creating your experiment. Open the file called run_simple.jl in Atom.\n\n\nRemove all text in run_simple.jl and replace it with the following.\n\n\nusing Weber\nsid,skip = @read_args(\nA simple frequency discrimination experiment.\n)\n\nconst low = ramp(tone(1kHz,0.5s))\nconst high = ramp(tone(1.1kHz,0.5s))\n\nfunction one_trial()\n  if rand(Bool)\n    stim1 = moment(0.5s,play,low)\n    stim2 = moment(0.5s,play,high)\n    resp = response(key\nq\n =\n \nlow_first\n, key\np\n =\n \nlow_second\n,correct = \nlow_first\n)\n  else\n    stim1 = moment(0.5s,play,high)\n    stim2 = moment(0.5s,play,low)\n    resp = response(key\nq\n =\n \nlow_first\n, key\np\n =\n \nlow_second\n,correct = \nlow_second\n)   \n  end\n  return [show_cross(),stim1,stim2,resp,await_response(iskeydown)]\nend\n\nexp = Experiment(columns = [:sid =\n sid,condition =\n \nConditionA\n,:correct],skip=skip)\nsetup(exp) do\n  addbreak(instruct(\nPress 'q' when you hear the low tone first and 'p' otherwise.\n))\n  for trial in 1:10\n    addtrial(one_trial())\n  end\nend\n\nrun(exp)\n\n\n\n\n\n\nRunning the program\n\n\nNow, \nopen the julia console\n, and enter the following:\n\n\ninclude(\nrun_simple.jl\n)\n\n\n\n\n\n\nMake sure you're in the correct directory\n\n\nYou may get an error that looks like \"could not open file [file name here]\". This probably means Julia's working directory is not set correctly. Open run_simple.jl in Atom, make sure you are focused on this file (by clicking inside the file), and then, in the menu, click \"Julia\" \n \"Working Directory\" \n \"Current File's Folder\". This will set Julia's working directory to run_simple.jl's directory.\n\n\n\n\n\n\nYou can exit at any time\n\n\nTo prematurely end the experiment hit the escape key.\n\n\n\n\n\n\nCode Walk-through\n\n\nAfter running the experiment on yourself, let's walk through the parts of this experiment piece-by-piece.\n\n\n\n\nRead Experiment Parameters\n\n\nusing Weber\nsid,skip = @read_args(\nA simple frequency discrimination experiment.\n)\n\n\n\n\nThe first line loads Weber. Then, when the script is run, the second line will read two important experimental parameters from the user: their subject ID, and an \noffset\n.\n\n\nDon't worry about the offset right now. (If you wish to learn more you can read about the \nWeber.offset\n function).\n\n\n\n\nStimulus Generation\n\n\nconst low = ramp(tone(1kHz,0.5s))\nconst high = ramp(tone(1.1kHz,0.5s))\n\n\n\n\nThese next two lines create two stimuli. A 1000 Hz tone (\nlow\n) and a 1100 Hz tone (\nhigh\n) each 0.5 seconds long. The \nramp\n function tapers the start and end of a sound to avoid click sounds.\n\n\nYou can generate many simple stimuli in Weber, or you can use \nload(\"sound.wav\")\n to open a sound file on your computer. Refer to the documentation in \nSound\n.\n\n\n\n\nCreating a trial\n\n\nfunction one_trial()\n  if rand(Bool)\n    stim1 = moment(0.5s,play,low)\n    stim2 = moment(0.5s,play,high)\n    resp = response(key\nq\n =\n \nlow_first\n, key\np\n =\n \nlow_second\n,correct = \nlow_first\n)\n  else\n    stim1 = moment(0.5s,play,high)\n    stim2 = moment(0.5s,play,low)\n    resp = response(key\nq\n =\n \nlow_first\n, key\np\n =\n \nlow_second\n,correct = \nlow_second\n)   \n  end\n  return [show_cross(),stim1,stim2,resp,await_response(iskeydown)]\nend\n\n\n\n\nThese lines define a function that is used to create a single trial of the experiment. To create a trial, a random boolean value (true or false) is produced. When true, the low stimulus is presented first, when false, the high stimulus is presented first. There are two basic components of trial creation: trial moments and trial events.\n\n\n\n\nTrial Moments\n\n\nEach trial is composed of a sequence of \nmoments\n. Most moments just run a short function at some well defined point in time. For example, during the experiment, the moment \nmoment(0.5,play,low)\n will call the function \nplay\n on the \nlow\n stimulus, doing so 0.5 seconds after the onset of the previous moment. All moments running at a specified time do so in reference to the onset of the prior moment.\n\n\nThere are two other moments created in this function: \nshow_cross\n\u2013which simply displays a \"+\" symbol in the middle of the screen\u2013and \nawait_response\n\u2013which is a moment that begins only once a key is pressed, and then immediately ends.\n\n\nOnce all of the moments have been defined, they are returned in an array and will be run in sequence during the experiment.\n\n\nFor more details on how to create trial moments you can refer to the \nTrial Creation\n section of the user guide and the \nTrials\n section of the reference.\n\n\n\n\nTrial Events\n\n\nThe \nresponse\n function also creates a moment. It's purpose is to record the keyboard presses to q or p. It works a little differently than other moments. Rather than running once after a specified time, it runs anytime an event occurs.\n\n\nEvents indicate that something has changed: e.g. a key has been pressed, a key has been released, the experiment has been paused. Keyboard events signal a particular code, referring to the key the experiment participant pressed. In the code above \nkey\"p\"\n and \nkey\"q\"\n are used to indicate the 'q' and 'p' keys on the keyboard. For details on how events work you can refer to the reference section on \nEvents\n. The \nresponse\n moment listens for events with the 'p' or 'q' key codes, and records those events.\n\n\n\n\nExperiment Definition\n\n\nexp = Experiment(columns = [:sid =\n sid,condition =\n \nConditionA\n,:correct],skip=skip) \n\n\n\n\nThis line creates the actual experiment. It creates a datafile with an appropriate name, and opens a window for the experiment to be displayed in.\n\n\nThe code \ncolumns\n creates a number of columns. Some of these columns have fixed values, that are the same for each row of the data (e.g. \n:sid =\n sid\n) but one of them, \n:correct\n, is different on each line. Note that in the call to \nresponse\n in \none_trial\n, the value of correct is set to the response listeners should have pressed during a trial.\n\n\nYou can add as many columns as you want, either when you first create an experiment, as above, or using \naddcolumn\n. Trying to record values to a column you haven't added results in an error.\n\n\n\n\nExperiment Setup\n\n\nsetup(exp) do\n  addbreak(instruct(\nPress 'q' when you hear the low tone first and 'p' otherwise.\n))\n  for trial in 1:10\n    addtrial(one_trial())\n  end\nend\n\n\n\n\nOnce the experiment is defined, you can setup any trials and instructions that you want the experiment to have. The above code adds a break providing instructions for the listeners, and 10 trials, created using the \none_trial\n function we defined above. Please refer to the \nTrial Creation\n section of the user guide for more details on how to add trials.\n\n\n\n\nSetup- vs. run-time\n\n\nrun(exp)\n\n\n\n\nThis final part of the code actually runs the experiment. Note that almost none of the code in setup actually runs during the experiment. This is \nimportant\n! Weber is designed to run as much code as possible before the experiment starts, during setup. This is called setup-time. This ensures that code which does run during the experiment, during run-time, can do so in a timely manner. The only code that actually runs during the experiment is the behavior defined within each moment (e.g. playing sounds, displaying text, etc...).\n\n\n\n\nWhere to go from here\n\n\nFrom here you can begin writing your own simple experiments. Take a look at some of the example experiments under Weber's example directory to see what you can do. You can find the location of this directory by typing \nPkg.dir(\"Weber\",\"examples\")\n in the julia console. To further your understanding of the details of Weber, you can also read through the rest of the user guide. Topics in the guide have been organized from simplest, and most useful, to the more advanced, least-frequently-necessary features.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/start/#creating-a-simple-program", 
            "text": "First, open the Julia console, and enter the following lines of code.  using Weber\ncreate_new_project( simple )  This will create a set of files in your current directory to get you started creating your experiment. Open the file called run_simple.jl in Atom.  Remove all text in run_simple.jl and replace it with the following.  using Weber\nsid,skip = @read_args( A simple frequency discrimination experiment. )\n\nconst low = ramp(tone(1kHz,0.5s))\nconst high = ramp(tone(1.1kHz,0.5s))\n\nfunction one_trial()\n  if rand(Bool)\n    stim1 = moment(0.5s,play,low)\n    stim2 = moment(0.5s,play,high)\n    resp = response(key q  =   low_first , key p  =   low_second ,correct =  low_first )\n  else\n    stim1 = moment(0.5s,play,high)\n    stim2 = moment(0.5s,play,low)\n    resp = response(key q  =   low_first , key p  =   low_second ,correct =  low_second )   \n  end\n  return [show_cross(),stim1,stim2,resp,await_response(iskeydown)]\nend\n\nexp = Experiment(columns = [:sid =  sid,condition =   ConditionA ,:correct],skip=skip)\nsetup(exp) do\n  addbreak(instruct( Press 'q' when you hear the low tone first and 'p' otherwise. ))\n  for trial in 1:10\n    addtrial(one_trial())\n  end\nend\n\nrun(exp)", 
            "title": "Creating a simple program"
        }, 
        {
            "location": "/start/#running-the-program", 
            "text": "Now,  open the julia console , and enter the following:  include( run_simple.jl )   Make sure you're in the correct directory  You may get an error that looks like \"could not open file [file name here]\". This probably means Julia's working directory is not set correctly. Open run_simple.jl in Atom, make sure you are focused on this file (by clicking inside the file), and then, in the menu, click \"Julia\"   \"Working Directory\"   \"Current File's Folder\". This will set Julia's working directory to run_simple.jl's directory.    You can exit at any time  To prematurely end the experiment hit the escape key.", 
            "title": "Running the program"
        }, 
        {
            "location": "/start/#code-walk-through", 
            "text": "After running the experiment on yourself, let's walk through the parts of this experiment piece-by-piece.", 
            "title": "Code Walk-through"
        }, 
        {
            "location": "/start/#read-experiment-parameters", 
            "text": "using Weber\nsid,skip = @read_args( A simple frequency discrimination experiment. )  The first line loads Weber. Then, when the script is run, the second line will read two important experimental parameters from the user: their subject ID, and an  offset .  Don't worry about the offset right now. (If you wish to learn more you can read about the  Weber.offset  function).", 
            "title": "Read Experiment Parameters"
        }, 
        {
            "location": "/start/#stimulus-generation", 
            "text": "const low = ramp(tone(1kHz,0.5s))\nconst high = ramp(tone(1.1kHz,0.5s))  These next two lines create two stimuli. A 1000 Hz tone ( low ) and a 1100 Hz tone ( high ) each 0.5 seconds long. The  ramp  function tapers the start and end of a sound to avoid click sounds.  You can generate many simple stimuli in Weber, or you can use  load(\"sound.wav\")  to open a sound file on your computer. Refer to the documentation in  Sound .", 
            "title": "Stimulus Generation"
        }, 
        {
            "location": "/start/#creating-a-trial", 
            "text": "function one_trial()\n  if rand(Bool)\n    stim1 = moment(0.5s,play,low)\n    stim2 = moment(0.5s,play,high)\n    resp = response(key q  =   low_first , key p  =   low_second ,correct =  low_first )\n  else\n    stim1 = moment(0.5s,play,high)\n    stim2 = moment(0.5s,play,low)\n    resp = response(key q  =   low_first , key p  =   low_second ,correct =  low_second )   \n  end\n  return [show_cross(),stim1,stim2,resp,await_response(iskeydown)]\nend  These lines define a function that is used to create a single trial of the experiment. To create a trial, a random boolean value (true or false) is produced. When true, the low stimulus is presented first, when false, the high stimulus is presented first. There are two basic components of trial creation: trial moments and trial events.", 
            "title": "Creating a trial"
        }, 
        {
            "location": "/start/#trial-moments", 
            "text": "Each trial is composed of a sequence of  moments . Most moments just run a short function at some well defined point in time. For example, during the experiment, the moment  moment(0.5,play,low)  will call the function  play  on the  low  stimulus, doing so 0.5 seconds after the onset of the previous moment. All moments running at a specified time do so in reference to the onset of the prior moment.  There are two other moments created in this function:  show_cross \u2013which simply displays a \"+\" symbol in the middle of the screen\u2013and  await_response \u2013which is a moment that begins only once a key is pressed, and then immediately ends.  Once all of the moments have been defined, they are returned in an array and will be run in sequence during the experiment.  For more details on how to create trial moments you can refer to the  Trial Creation  section of the user guide and the  Trials  section of the reference.", 
            "title": "Trial Moments"
        }, 
        {
            "location": "/start/#trial-events", 
            "text": "The  response  function also creates a moment. It's purpose is to record the keyboard presses to q or p. It works a little differently than other moments. Rather than running once after a specified time, it runs anytime an event occurs.  Events indicate that something has changed: e.g. a key has been pressed, a key has been released, the experiment has been paused. Keyboard events signal a particular code, referring to the key the experiment participant pressed. In the code above  key\"p\"  and  key\"q\"  are used to indicate the 'q' and 'p' keys on the keyboard. For details on how events work you can refer to the reference section on  Events . The  response  moment listens for events with the 'p' or 'q' key codes, and records those events.", 
            "title": "Trial Events"
        }, 
        {
            "location": "/start/#experiment-definition", 
            "text": "exp = Experiment(columns = [:sid =  sid,condition =   ConditionA ,:correct],skip=skip)   This line creates the actual experiment. It creates a datafile with an appropriate name, and opens a window for the experiment to be displayed in.  The code  columns  creates a number of columns. Some of these columns have fixed values, that are the same for each row of the data (e.g.  :sid =  sid ) but one of them,  :correct , is different on each line. Note that in the call to  response  in  one_trial , the value of correct is set to the response listeners should have pressed during a trial.  You can add as many columns as you want, either when you first create an experiment, as above, or using  addcolumn . Trying to record values to a column you haven't added results in an error.", 
            "title": "Experiment Definition"
        }, 
        {
            "location": "/start/#experiment-setup", 
            "text": "setup(exp) do\n  addbreak(instruct( Press 'q' when you hear the low tone first and 'p' otherwise. ))\n  for trial in 1:10\n    addtrial(one_trial())\n  end\nend  Once the experiment is defined, you can setup any trials and instructions that you want the experiment to have. The above code adds a break providing instructions for the listeners, and 10 trials, created using the  one_trial  function we defined above. Please refer to the  Trial Creation  section of the user guide for more details on how to add trials.", 
            "title": "Experiment Setup"
        }, 
        {
            "location": "/start/#setup-vs-run-time", 
            "text": "run(exp)  This final part of the code actually runs the experiment. Note that almost none of the code in setup actually runs during the experiment. This is  important ! Weber is designed to run as much code as possible before the experiment starts, during setup. This is called setup-time. This ensures that code which does run during the experiment, during run-time, can do so in a timely manner. The only code that actually runs during the experiment is the behavior defined within each moment (e.g. playing sounds, displaying text, etc...).", 
            "title": "Setup- vs. run-time"
        }, 
        {
            "location": "/start/#where-to-go-from-here", 
            "text": "From here you can begin writing your own simple experiments. Take a look at some of the example experiments under Weber's example directory to see what you can do. You can find the location of this directory by typing  Pkg.dir(\"Weber\",\"examples\")  in the julia console. To further your understanding of the details of Weber, you can also read through the rest of the user guide. Topics in the guide have been organized from simplest, and most useful, to the more advanced, least-frequently-necessary features.", 
            "title": "Where to go from here"
        }, 
        {
            "location": "/trial_guide/", 
            "text": "We'll look in detail at how to create trials of an experiment. For a broad overview of trial creation refer to \nGetting Started\n. The two basic steps to creating a trial are (1) defining a set of moments and (2) add moments to a trial. \n\n\n\n\nDefining Moments\n\n\nTrials are composed of moments. There are several types of moments: timed moments, compound moments, watcher moments, and conditional moments.\n\n\n\n\nTimed Moments\n\n\nTimed moments are the simplest kind of moment. They are are normally created by calling \nmoment\n.\n\n\nmoment([delta_t],[fn],args...;keys...)\n\n\n\n\nA timed moment waits \ndelta_t\n seconds after the onset of the previous moment, and then runs the specified function (\nfn\n), if any, passing it any \nargs\n and \nkeys\n provided. Below is an example of creating a timed moment.\n\n\nmoment(0.5s,play,mysound)\n\n\n\n\nThis moment plays \nmysound\n 0.5 seconds after the onset of the previous moment.\n\n\nThere are several other kinds of timed moments, other than those created by calling \nmoment\n. Specifically, \ntimeout\n and \nawait_response\n wait for a particular event to occur (such as a key press) before they begin.\n\n\n\n\nGuidlines for low-latency moments\n\n\nWeber aims to present moments at low latencies for accurate experiments.\n\n\nTo maintain low latency, as much of the experimental logic as possible should be precomputed, outside of trial moments, during \nsetup-time\n. The following operations are definitely safe to perform during a moment:\n\n\n\n\nCalls to \nplay\n to present a sound\n\n\nCalls to \ndisplay\n to present a visual.\n\n\nCalls to \nrecord\n to save something to a data file (usually after any calls to \nplay\n or \ndisplay\n)\n\n\n\n\nNote that Julia compiles functions on demand (known as just-in-time or JIT compilation), which can lead to very slow runtimes the first time a function runs.  To minimize JIT compilation during an experiment, any functions called directly by a moment are first precompiled.\n\n\n\n\nKeep Moments Short\n\n\nLong running moments will lead to latency issues. Make sure all functions that run in a moment terminate relatively quickly.\n\n\n\n\n\n\nSync visuals to the refresh rate.\n\n\nVisuals synchronize to the screen refresh rate. You can  find more details about this in the documentation of \ndisplay\n\n\n\n\n\n\nCompound Moments\n\n\nYou can create more complicated moments by concatenating simpler moments together using the \n operator or \nmoment(momoment1,moment2,...)\n.\n\n\nA concatenation of moments starts immediately, proceeding through each of the moments in order. This allows for a more complex relationship in inter-moment timing. For example, the following code will present two sounds, one at 100 ms, the other 200 ms after the start of the trial. It will also display \"Too Late!\" on the screen if no keyboard key is pressed 150 ms after the start of the trial. \n\n\naddtrial(moment(100ms,play,soundA) \n moment(100ms,play,soundB),\n         timeout(() -\n display(\nToo Late!\n),iskeydown,150ms))\n\n\n\n\nThis exact sequence of timing would not be possible withou using the \n operator because the timing of the \ntimeout\n moment depends on user input, while we want soundB to be played at a reliable time.\n\n\n\n\nWatcher Moments\n\n\nWatcher moments are used to respond to events. Often, watcher moments need not be directly used. Instead, the higher level \nresponse\n method can be used.\n\n\nAs long as a watcher moment is active it occurs any time an event is triggered. A watcher moment becomes active at the start of the preceding moment, or at the start of a trial (if it's the first moment in a trial). This latter form is most common, since generally one wishes to listen to all events during a trial. A watcher moments is simply a function that takes one argument: the event to be processed.\n\n\nIf the watcher is the first moment in a trial, the convenient \ndo\n block syntax is possible.\n\n\nmessage = visual(\nYou hit spacebar!\n)\naddtrial(moment2,moment3) do event\n  if iskeydown(key\n:space:\n)\n    display(message,duration=500ms)\n    record()\n  end\nend\n\n\n\n\nIn the above example, \"You hit spacebar!\" is displayed for 500 ms every time the spacebar is hit.\n\n\nRefer to the documentation for \nEvents\n for full details on how to respond to events.\n\n\n\n\nConditional Moments\n\n\nConditional moments are a more advanced technique for creating moments and aren't normally necessary. They run a function only when a certain condition is true (the \nwhen\n moment) or repeat a function until a condition is false (the \nlooping\n moment). They require a good understanding of the difference between \nsetup- and run-time\n, \nanonymous functions\n, and \nscoping rules\n in julia.\n\n\n\n\nAdding Trials\n\n\nNormally, to add moments to a trial you simply call \naddtrial\n. There is also \naddpractice\n, and \naddbreak\n. These functions are nearly identical to \naddtrial\n but differ in how they update the trial and offset counters, and what they automatically \nrecord\n to a data file.\n\n\nAll of these functions take a series of iterable objects of moments. The moments of all arguments are added in sequence. For convience these iterables can be nested, allowing functions that return multiple moments themselves to be easily passed to \naddtrial\n.", 
            "title": "Trial Creation"
        }, 
        {
            "location": "/trial_guide/#defining-moments", 
            "text": "Trials are composed of moments. There are several types of moments: timed moments, compound moments, watcher moments, and conditional moments.", 
            "title": "Defining Moments"
        }, 
        {
            "location": "/trial_guide/#timed-moments", 
            "text": "Timed moments are the simplest kind of moment. They are are normally created by calling  moment .  moment([delta_t],[fn],args...;keys...)  A timed moment waits  delta_t  seconds after the onset of the previous moment, and then runs the specified function ( fn ), if any, passing it any  args  and  keys  provided. Below is an example of creating a timed moment.  moment(0.5s,play,mysound)  This moment plays  mysound  0.5 seconds after the onset of the previous moment.  There are several other kinds of timed moments, other than those created by calling  moment . Specifically,  timeout  and  await_response  wait for a particular event to occur (such as a key press) before they begin.", 
            "title": "Timed Moments"
        }, 
        {
            "location": "/trial_guide/#guidlines-for-low-latency-moments", 
            "text": "Weber aims to present moments at low latencies for accurate experiments.  To maintain low latency, as much of the experimental logic as possible should be precomputed, outside of trial moments, during  setup-time . The following operations are definitely safe to perform during a moment:   Calls to  play  to present a sound  Calls to  display  to present a visual.  Calls to  record  to save something to a data file (usually after any calls to  play  or  display )   Note that Julia compiles functions on demand (known as just-in-time or JIT compilation), which can lead to very slow runtimes the first time a function runs.  To minimize JIT compilation during an experiment, any functions called directly by a moment are first precompiled.   Keep Moments Short  Long running moments will lead to latency issues. Make sure all functions that run in a moment terminate relatively quickly.    Sync visuals to the refresh rate.  Visuals synchronize to the screen refresh rate. You can  find more details about this in the documentation of  display", 
            "title": "Guidlines for low-latency moments"
        }, 
        {
            "location": "/trial_guide/#compound-moments", 
            "text": "You can create more complicated moments by concatenating simpler moments together using the   operator or  moment(momoment1,moment2,...) .  A concatenation of moments starts immediately, proceeding through each of the moments in order. This allows for a more complex relationship in inter-moment timing. For example, the following code will present two sounds, one at 100 ms, the other 200 ms after the start of the trial. It will also display \"Too Late!\" on the screen if no keyboard key is pressed 150 ms after the start of the trial.   addtrial(moment(100ms,play,soundA)   moment(100ms,play,soundB),\n         timeout(() -  display( Too Late! ),iskeydown,150ms))  This exact sequence of timing would not be possible withou using the   operator because the timing of the  timeout  moment depends on user input, while we want soundB to be played at a reliable time.", 
            "title": "Compound Moments"
        }, 
        {
            "location": "/trial_guide/#watcher-moments", 
            "text": "Watcher moments are used to respond to events. Often, watcher moments need not be directly used. Instead, the higher level  response  method can be used.  As long as a watcher moment is active it occurs any time an event is triggered. A watcher moment becomes active at the start of the preceding moment, or at the start of a trial (if it's the first moment in a trial). This latter form is most common, since generally one wishes to listen to all events during a trial. A watcher moments is simply a function that takes one argument: the event to be processed.  If the watcher is the first moment in a trial, the convenient  do  block syntax is possible.  message = visual( You hit spacebar! )\naddtrial(moment2,moment3) do event\n  if iskeydown(key :space: )\n    display(message,duration=500ms)\n    record()\n  end\nend  In the above example, \"You hit spacebar!\" is displayed for 500 ms every time the spacebar is hit.  Refer to the documentation for  Events  for full details on how to respond to events.", 
            "title": "Watcher Moments"
        }, 
        {
            "location": "/trial_guide/#conditional-moments", 
            "text": "Conditional moments are a more advanced technique for creating moments and aren't normally necessary. They run a function only when a certain condition is true (the  when  moment) or repeat a function until a condition is false (the  looping  moment). They require a good understanding of the difference between  setup- and run-time ,  anonymous functions , and  scoping rules  in julia.", 
            "title": "Conditional Moments"
        }, 
        {
            "location": "/trial_guide/#adding-trials", 
            "text": "Normally, to add moments to a trial you simply call  addtrial . There is also  addpractice , and  addbreak . These functions are nearly identical to  addtrial  but differ in how they update the trial and offset counters, and what they automatically  record  to a data file.  All of these functions take a series of iterable objects of moments. The moments of all arguments are added in sequence. For convience these iterables can be nested, allowing functions that return multiple moments themselves to be easily passed to  addtrial .", 
            "title": "Adding Trials"
        }, 
        {
            "location": "/stimulus/", 
            "text": "So far we have seen several examples of how to generate sounds and simple images (text). Here we'll cover stimulus generation in more detail.\n\n\n\n\nSounds\n\n\nWeber's primary focus is on psychoacoustics, so there are many methods for generating and manipulating sounds. There are two primary ways to create sound stimuli: loading a file and composing sound primitives.\n\n\n\n\nLoading a file\n\n\nGenerating stimuli by loading a file is easy. You simply play the given file, like so.\n\n\naddtrial(moment(play,\nmysound_file.wav\n))\n\n\n\n\n\n\nSounds are cached\n\n\nYou can safely play the same file multiple times: the sound is cached, and will only load into memory once.\n\n\n\n\nIf you need to manipulate the sound before playing it, you can load it using \nsound\n.  For example, to remove any frequencies from \n\"mysound_file.wav\"\n above 400Hz before playing the sound, you could do the following.\n\n\nmysound = lowpass(sound(\nmysound_file.wav\n),400Hz)\naddtrial(moment(play,mysound))\n\n\n\n\n\n\nSound Primivites\n\n\nThere are several primitives you can use to generate simple sounds directly in Weber. They are \ntone\n (to create pure tones), \nnoise\n (to generate white noise), \nsilence\n (for a silent period) and \nharmonic_complex\n (to create multiple pure tones with integer frequency ratios).\n\n\nThese primitives can then be combined and manipuliated to generate more interesting sounds. You can filter sounds (\nbandpass\n, \nbandstop\n, \nlowpass\n, \nhighpass\n and \nlowpass\n), mix them together (\nmix\n) and set an appropriate decibel level (\nattenuate\n). You can also manipulate the envelope of the sound (\nramp\n, \nrampon\n, \nrampoff\n, \nfadeto\n, \nenvelope\n and \nmult\n).\n\n\nFor instance, to play a 1 kHz tone for 1 second inside of a noise with a notch from 0.5 to 1.5 kHz, with 5 dB SNR you could call the following.\n\n\nmysound = tone(1kHz,1s)\nmysound = ramp(mysound)\nmysound = attenuate(mysound,20)\n\nmynoise = noise(1s)\nmynoise = bandstop(mynoise,0.5kHz,1.5kHz)\nmynoise = attenuate(mynoise,25)\n\naddtrial(moment(play,mix(mysound,mynoise))\n\n\n\n\nWeber exports the macro \n@\n (from \nLazy.jl\n) to simplify this pattern. It is easiest to understand the macro by example: the below code yields the same result as the code above.\n\n\nmytone = @\n tone(1kHz,1s) ramp attenuate(20)\nmynoise = @\n noise(1s) bandstop(0.5kHz,1.5kHz) attenuate(25)\naddtrial(moment(play, mix(mytone,mynoise)))\n\n\n\n\nWeber also exports \n@\n, and \n@_\n (refer to \nLazy.jl\n for details).\n\n\n\n\nSounds are arrays\n\n\nSounds can be manipulated in the same way that any array can be manipulated in Julia, with some additional support for indexing sounds using time units. For instance, to get the first 5 seconds of a sound you can do the following.\n\n\nmytone = tone(1kHz,10s)\nmytone[0s .. 5s]\n\n\n\n\nFurthermore, we can concatentate multiple sounds, to play them in sequence. The following code plays two tones in sequence, with a 100 ms gap between them.\n\n\ninterval = [tone(400Hz,50ms); silence(100ms); tone(400Hz * 2^(5/12),50ms)]\naddtrial(moment(play,interval))\n\n\n\n\n\n\nStereo Sounds\n\n\nYou can create stereo sounds with using \nleftright\n, and reference their left and right channel sound using \n:left\n or \n:right\n as a second index, like so.\n\n\nstereo_sound = leftright(tone(1kHz,2s),tone(2kHz,2s))\naddtrial(moment(play,stereo_sound[:,:left],\n         moment(2s,play,stereo_sound[:,:right]))\n\n\n\n\nThe functions \nleft\n and \nright\n serve the same purpose, but can also operate on streams.\n\n\n\n\nStreams\n\n\nIn addition to the discrete sounds that have been discussed so far, Weber also supports sound streams. Streams are aribtrarily long: you need not decide when they should stop until after they start playing. All of the primitives described so far can apply to streams, except that streams cannot be indexed.\n\n\n\n\nStreaming operations are lazy\n\n\nAll manipulations of streams are lazy: they are applied just as the stream is played. The more operators you apply to a stream the more processing that has to occur. If you have a particularly complicated stream you may have to increase streaming latency by changing the \nstream_unit\n parameter of \nsetup_sound\n, or consider an alternative approach (e.g. \naudible\n).\n\n\n\n\nTo create a stream you can use one of the standard primitives, leaving out the length parameter. For example, the following will play a 1 kHz pure tone until Weber quits.\n\n\naddtrial(moment(play,tone(1kHz)))\n\n\n\n\nStreams always play on a specific stream channel, so if you want to stop the stream at some point you can request that the channel stop. The following plays a pure tone until the experiment participant hits spacebar.\n\n\naddtrial(moment(play,tone(1kHz),channel=1),\n         await_response(iskeydown(key\n:space:\n)),\n         moment(stop,1))\n\n\n\n\nStreams can be manipulated as they are playing as well, so if you wanted to have a ramp at the start and end of the stream to avoid clicks, you could change the example above, to the following.\n\n\nongoing_tone = @\n tone(1kHz) rampon\naddtrial(moment(play,ongoing_tone,channel=1),\n         await_response(iskeydown(key\n:space:\n)),\n         moment(play,rampoff(ongoing_tone),channel=1))\n\n\n\n\n\n\nStreams are stateful\n\n\nThis example also demonstrates the stateful nature of streams. Once some part of a stream has been played it is forever consumed, and cannot be played again. After the stream is played, subsequent modifications only apply to unplayed frames of the stream. \nBEWARE\n: this means that you cannot play two different modifications of the same stream.\n\n\n\n\nJust as with any moment, these manipulations to streams can be precisely timed. The following will turn the sound off precisely 1 second after the space key is pressed.\n\n\nongoing_tone = @\n tone(1kHz) rampon\naddtrial(moment(play,ongoing_tone,channel=1),\n         await_response(iskeydown(key\n:space:\n)),\n         moment(1s,play,rampoff(ongoing_tone),channel=1))\n\n\n\n\nIf you wish to turn the entirety of a finite stream into a sound, you can use \nsound\n. You can also grab the next section of an infinite stream using \nsound\n if you provide a second parameter specifying the length of the stream you want to turn into a sound.\n\n\nSome manipulations of streams require that the stream be treated as a sound. You can modify individual sound segments as they play from the stream using \naudiofn\n. (Calling \naudiofn\n on a sound, rather than a stream, is the same as applying the given function to the sound directly).\n\n\n\n\nLow-level Sound/Stream Generation\n\n\nFinally, if none of the functions above suit your purposes for generating sounds or streams, you can use the function \naudible\n, which can be used to generate any arbitrary sound or stream you want. Please refer to the source code for \ntone\n and \nnoise\n to see examples of the two ways to use this function.\n\n\n\n\nImages\n\n\nImages can also be generated by either displaying a file or generating image primitves.\n\n\n\n\nLoading a file\n\n\nDisplaying an image file is a simple matter of calling display on that file.\n\n\naddtrial(moment(display,\nmyimage.png\n))\n\n\n\n\n\n\nImages are cached\n\n\nYou can safely display the same file multiple times: the image is cached, and will only load into memory once.\n\n\n\n\nAnalogous to sounds, if you need to manipulate the image before displaying it you can load it using \nvisual\n. For example, the following displays the upper quarter of an image.\n\n\nmyimage = visual(\nmyimage.png\n)\naddtrial(moment(display,myimage[1:div(end,2),1:div(end,2)]))\n\n\n\n\nNote that displaying a string can also result in that string being printed to the screen. Weber determines the difference between a string you want to display and a string referring to an image file by looking at the end of the string. If the string ends in a file type (.bmp, .jpeg, .png, etc...), Weber assumes it is an image file you want to load, otherwise it assumes it is a string you want to print to the screen. \n\n\n\n\nImage Primitives\n\n\nSupport for generating images in Weber comes from \nImages.jl\n. In this package, images are represented as arrays. For instance, to display a white 100x100 pixel box next to a black 100x100 pixel box, we could do the following.\n\n\naddtrial(moment(display,[ones(100,100); zeros(100,100)]))\n\n\n\n\nFor more information about generating images please refer to the \nJuliaImages\n documentation.", 
            "title": "Stimulus Generation"
        }, 
        {
            "location": "/stimulus/#sounds", 
            "text": "Weber's primary focus is on psychoacoustics, so there are many methods for generating and manipulating sounds. There are two primary ways to create sound stimuli: loading a file and composing sound primitives.", 
            "title": "Sounds"
        }, 
        {
            "location": "/stimulus/#loading-a-file", 
            "text": "Generating stimuli by loading a file is easy. You simply play the given file, like so.  addtrial(moment(play, mysound_file.wav ))   Sounds are cached  You can safely play the same file multiple times: the sound is cached, and will only load into memory once.   If you need to manipulate the sound before playing it, you can load it using  sound .  For example, to remove any frequencies from  \"mysound_file.wav\"  above 400Hz before playing the sound, you could do the following.  mysound = lowpass(sound( mysound_file.wav ),400Hz)\naddtrial(moment(play,mysound))", 
            "title": "Loading a file"
        }, 
        {
            "location": "/stimulus/#sound-primivites", 
            "text": "There are several primitives you can use to generate simple sounds directly in Weber. They are  tone  (to create pure tones),  noise  (to generate white noise),  silence  (for a silent period) and  harmonic_complex  (to create multiple pure tones with integer frequency ratios).  These primitives can then be combined and manipuliated to generate more interesting sounds. You can filter sounds ( bandpass ,  bandstop ,  lowpass ,  highpass  and  lowpass ), mix them together ( mix ) and set an appropriate decibel level ( attenuate ). You can also manipulate the envelope of the sound ( ramp ,  rampon ,  rampoff ,  fadeto ,  envelope  and  mult ).  For instance, to play a 1 kHz tone for 1 second inside of a noise with a notch from 0.5 to 1.5 kHz, with 5 dB SNR you could call the following.  mysound = tone(1kHz,1s)\nmysound = ramp(mysound)\nmysound = attenuate(mysound,20)\n\nmynoise = noise(1s)\nmynoise = bandstop(mynoise,0.5kHz,1.5kHz)\nmynoise = attenuate(mynoise,25)\n\naddtrial(moment(play,mix(mysound,mynoise))  Weber exports the macro  @  (from  Lazy.jl ) to simplify this pattern. It is easiest to understand the macro by example: the below code yields the same result as the code above.  mytone = @  tone(1kHz,1s) ramp attenuate(20)\nmynoise = @  noise(1s) bandstop(0.5kHz,1.5kHz) attenuate(25)\naddtrial(moment(play, mix(mytone,mynoise)))  Weber also exports  @ , and  @_  (refer to  Lazy.jl  for details).", 
            "title": "Sound Primivites"
        }, 
        {
            "location": "/stimulus/#sounds-are-arrays", 
            "text": "Sounds can be manipulated in the same way that any array can be manipulated in Julia, with some additional support for indexing sounds using time units. For instance, to get the first 5 seconds of a sound you can do the following.  mytone = tone(1kHz,10s)\nmytone[0s .. 5s]  Furthermore, we can concatentate multiple sounds, to play them in sequence. The following code plays two tones in sequence, with a 100 ms gap between them.  interval = [tone(400Hz,50ms); silence(100ms); tone(400Hz * 2^(5/12),50ms)]\naddtrial(moment(play,interval))", 
            "title": "Sounds are arrays"
        }, 
        {
            "location": "/stimulus/#stereo-sounds", 
            "text": "You can create stereo sounds with using  leftright , and reference their left and right channel sound using  :left  or  :right  as a second index, like so.  stereo_sound = leftright(tone(1kHz,2s),tone(2kHz,2s))\naddtrial(moment(play,stereo_sound[:,:left],\n         moment(2s,play,stereo_sound[:,:right]))  The functions  left  and  right  serve the same purpose, but can also operate on streams.", 
            "title": "Stereo Sounds"
        }, 
        {
            "location": "/stimulus/#streams", 
            "text": "In addition to the discrete sounds that have been discussed so far, Weber also supports sound streams. Streams are aribtrarily long: you need not decide when they should stop until after they start playing. All of the primitives described so far can apply to streams, except that streams cannot be indexed.   Streaming operations are lazy  All manipulations of streams are lazy: they are applied just as the stream is played. The more operators you apply to a stream the more processing that has to occur. If you have a particularly complicated stream you may have to increase streaming latency by changing the  stream_unit  parameter of  setup_sound , or consider an alternative approach (e.g.  audible ).   To create a stream you can use one of the standard primitives, leaving out the length parameter. For example, the following will play a 1 kHz pure tone until Weber quits.  addtrial(moment(play,tone(1kHz)))  Streams always play on a specific stream channel, so if you want to stop the stream at some point you can request that the channel stop. The following plays a pure tone until the experiment participant hits spacebar.  addtrial(moment(play,tone(1kHz),channel=1),\n         await_response(iskeydown(key :space: )),\n         moment(stop,1))  Streams can be manipulated as they are playing as well, so if you wanted to have a ramp at the start and end of the stream to avoid clicks, you could change the example above, to the following.  ongoing_tone = @  tone(1kHz) rampon\naddtrial(moment(play,ongoing_tone,channel=1),\n         await_response(iskeydown(key :space: )),\n         moment(play,rampoff(ongoing_tone),channel=1))   Streams are stateful  This example also demonstrates the stateful nature of streams. Once some part of a stream has been played it is forever consumed, and cannot be played again. After the stream is played, subsequent modifications only apply to unplayed frames of the stream.  BEWARE : this means that you cannot play two different modifications of the same stream.   Just as with any moment, these manipulations to streams can be precisely timed. The following will turn the sound off precisely 1 second after the space key is pressed.  ongoing_tone = @  tone(1kHz) rampon\naddtrial(moment(play,ongoing_tone,channel=1),\n         await_response(iskeydown(key :space: )),\n         moment(1s,play,rampoff(ongoing_tone),channel=1))  If you wish to turn the entirety of a finite stream into a sound, you can use  sound . You can also grab the next section of an infinite stream using  sound  if you provide a second parameter specifying the length of the stream you want to turn into a sound.  Some manipulations of streams require that the stream be treated as a sound. You can modify individual sound segments as they play from the stream using  audiofn . (Calling  audiofn  on a sound, rather than a stream, is the same as applying the given function to the sound directly).", 
            "title": "Streams"
        }, 
        {
            "location": "/stimulus/#low-level-soundstream-generation", 
            "text": "Finally, if none of the functions above suit your purposes for generating sounds or streams, you can use the function  audible , which can be used to generate any arbitrary sound or stream you want. Please refer to the source code for  tone  and  noise  to see examples of the two ways to use this function.", 
            "title": "Low-level Sound/Stream Generation"
        }, 
        {
            "location": "/stimulus/#images", 
            "text": "Images can also be generated by either displaying a file or generating image primitves.", 
            "title": "Images"
        }, 
        {
            "location": "/stimulus/#loading-a-file_1", 
            "text": "Displaying an image file is a simple matter of calling display on that file.  addtrial(moment(display, myimage.png ))   Images are cached  You can safely display the same file multiple times: the image is cached, and will only load into memory once.   Analogous to sounds, if you need to manipulate the image before displaying it you can load it using  visual . For example, the following displays the upper quarter of an image.  myimage = visual( myimage.png )\naddtrial(moment(display,myimage[1:div(end,2),1:div(end,2)]))  Note that displaying a string can also result in that string being printed to the screen. Weber determines the difference between a string you want to display and a string referring to an image file by looking at the end of the string. If the string ends in a file type (.bmp, .jpeg, .png, etc...), Weber assumes it is an image file you want to load, otherwise it assumes it is a string you want to print to the screen.", 
            "title": "Loading a file"
        }, 
        {
            "location": "/stimulus/#image-primitives", 
            "text": "Support for generating images in Weber comes from  Images.jl . In this package, images are represented as arrays. For instance, to display a white 100x100 pixel box next to a black 100x100 pixel box, we could do the following.  addtrial(moment(display,[ones(100,100); zeros(100,100)]))  For more information about generating images please refer to the  JuliaImages  documentation.", 
            "title": "Image Primitives"
        }, 
        {
            "location": "/adaptive/", 
            "text": "Some experiments require the use of an adaptive adjustment of a stimulus based on participant responses. There are several basic adaptive tracking algorithms built into Weber, and you can also implement your own as well.\n\n\n\n\nUsing an Adaptive Track\n\n\nTo use an adaptive track in your experiment, you need to make use of some of the \nadvanced features\n of Weber. In this section we'll walk through the necessary steps, using a simple frequency discrimination experiment.\n\n\nIn this experiment, on each trial, listeners hear a low and a high tone, separated in frequency by an adaptively adjusted delta. Their task is to indicate which tone is lower, and the delta is adjusted to determine the difference in frequency at which listeners respond with 79% accuracy. The entire example code is provided below. \n\n\nusing Weber\n\nversion = v\n0.0.2\n\nsid,trial_skip,adapt = @read_args(\nFrequency Discrimination ($version).\n,\n                                  adapt=[:levitt,:bayes])\n\nconst atten_dB = 30\nconst n_trials = 60\nconst feedback_delay = 750ms\n\nisresponse(e) = iskeydown(e,key\np\n) || iskeydown(e,key\nq\n)\n\nconst standard_freq = 1kHz\nconst standard = attenuate(ramp(tone(standard_freq,0.1)),atten_dB)\nfunction one_trial(adapter)\n  first_lower = rand(Bool)\n  resp = response(adapter,key\nq\n =\n \nfirst_lower\n,key\np\n =\n \nsecond_lower\n,\n                  correct=(first_lower ? \nfirst_lower\n : \nsecond_lower\n))\n\n  signal() = attenuate(ramp(tone(standard_freq*(1-delta(adapter)),0.1s)),atten_dB)\n  stimuli = first_lower? [signal,standard] : [standard,signal]\n\n  [moment(feedback_delay,play,stimuli[1]),\n   show_cross(),\n   moment(0.9s,play,stimuli[2]),\n   moment(0.1s + 0.3s,display,\n          \nWas the first [Q] or second sound [P] lower in pitch?\n),\n   resp,await_response(isresponse)]\nend\n\nexperiment = Experiment(\n  skip=trial_skip,\n  columns = [\n    :sid =\n sid,\n    :condition =\n \nexample\n,\n    :version =\n version,\n    :standard =\n standard_freq\n  ]\n)\n\nsetup(experimerntent) do\n  addbreak(moment(record,\nstart\n))\n\n  addbreak(instruct(\n\n\n    On each trial, you will hear two beeps. Indicate which of the two beeps you\nheard was lower in pitch. Hit 'Q' if the first beep was lower, and 'P' if the\nsecond beep was lower.\n\n))\n\n  if adapt == :levitt\n    adapter = levitt_adapter(down=3,up=1,min_delta=0,max_delta=1,\n                             big=2,little=sqrt(2),mult=true)\n  else\n    adapter = bayesian_adapter(min_delta = 0,max_delta = 0.95)\n  end\n\n  @addtrials let a = adapter\n    for trial in 1:n_trials\n      addtrial(one_trial(a))\n    end\n\n    # define this string during experiment setup\n    # when we know what block we're on...\n\n    function threshold_report()\n      mean,sd = estimate(adapter)\n      thresh = round(mean,3)*standard_freq\n      thresh_sd = round(sd,3)*standard_freq\n\n      # define this string during run time when we know\n      # what the threshold estimate is.\n      \nThreshold $(thresh)Hz (SD: $thresh_sd)\\n\n*\n      \nHit spacebar to continue...\n\n    end\n\n    addbreak(moment(display,threshold_report,clean_whitespace=false),\n             await_response(iskeydown(key\n:space:\n)))\n  end\n\nend\n\nrun(experimerntent)\n\n\n\n\nIn what follows we'll walk through the parts of this code unique to creating an adaptive track. For more details on the basics of creating an experiment see \nGetting Started\n.\n\n\n\n\nCreating the Adapter\n\n\nif adapt == :levitt\n  adapter = levitt_adapter(down=3,up=1,min_delta=0,max_delta=1,\n                           big=2,little=sqrt(2),mult=true)\nelse\n  adapter = bayesian_adapter(min_delta = 0,max_delta = 0.95)\nend\n\n\n\n\nThe present experiment can be run using either of two built-in adapters: \nlevitt_adapter\n and \nbayesian_adapter\n. An adapter is the object you create to run an adaptive track, and defines the particular algorithm that will be used to select a new delta on each trial, based on the responses to previous deltas. \n\n\n\n\nGenerating Stimuli\n\n\nconst standard = attenuate(ramp(tone(standard_freq,0.1s)),atten_dB)\n...\nsignal() = attenuate(ramp(tone(standard_freq*(1-delta(adapter)),0.1s)),atten_dB)\nstimuli = first_lower? [signal,standard] : [standard,signal]\n\n\n\n\nThe two stimuli presented to the listener are the standard (always at 1kHz) and the signal (1kHz - delta). The standard is always the same, and so can be generated in advance before the experiment begins. The signal must be generated during the experiment, on each trial. The next delta is queried from the adapter using \ndelta\n. The signal is defined as a function that takes no arguments. When passed a function, \nplay\n generates the stimulus defined by that function at runtime, rather than \nsetup time\n, which is precisely what we want in this case.\n\n\n\n\nCollecting Responses\n\n\nresp = response(adapter,key\nq\n =\n \nfirst_lower\n,key\np\n =\n \nsecond_lower\n,\n                  correct=(first_lower ? \nfirst_lower\n : \nsecond_lower\n))\n\n\n\n\nTo update the adapter after each response, a special method of the \nresponse\n function is used, which takes the adapter as its first argument. We also must indicate which response is correct by setting \ncorrect\n appropriately.\n\n\n\n\nGenerating Trials\n\n\n@addtrials let a = adapter\n  for trial in 1:n_trials\n    addtrial(one_trial(a))\n  end\n  addbreak(moment(display,() -\n \nEstimated threshold: $(estimate(adapter)[1])\\n\n,\n                                \nHit spacebar to exit.\n),\n           await_response(iskeydown(key\n:space:\n)))\nend\n\n\n\n\nTo generate the trials, which depend on the run-time state of the adapter, we use the \n@addtrials\n macro. Any time the behavior of listeners in one trial influences subsequent trials, this macro will be necessary. In this case it is used to signal to Weber that the trials added inside the loop depend on the run-time state of the adapter.\n\n\nAfter all trials have been run, we report the threshold estimated by the adapter using the \nestimate\n function, which returns both the mean and measurement error.\n\n\n\n\nReporting the Threshold\n\n\n# define this string during experiment setup\n# when we know what block we're on...\n\nfunction threshold_report()\n  mean,sd = estimate(adapter)\n  thresh = round(mean,3)*standard_freq\n  thresh_sd = round(sd,3)*standard_freq\n\n  # define this string during run time when we know\n  # what the threshold estimate is.\n  \nThreshold $(thresh)Hz (SD: $thresh_sd)\\n\n*\n  \nHit spacebar to continue...\n\nend\n\naddbreak(moment(display,threshold_report,clean_whitespace=false),\n         await_response(iskeydown(key\n:space:\n)))\n\n\n\n\nYou can report the threshold at the end of an experiment using \nestimate\n, as above, but this isn't strictly necessary. The tricky part is to make sure you find the estimate \nafter\n trials have been run (during run time).\n\n\n\n\nCustom Adaptive Tracking Algorithms\n\n\nYou can define your own adaptive tracking algorithms by defining a new type that is a child of \nAdapter\n. You must define an appropriate function to generate the adapter, and methods of \nWeber.update!\n, \nestimate\n and \ndelta\n for this type. Strictly speaking estimate need not be implemented, if you choose not to make use of this method in your experiment.", 
            "title": "Adaptive Tracks"
        }, 
        {
            "location": "/adaptive/#using-an-adaptive-track", 
            "text": "To use an adaptive track in your experiment, you need to make use of some of the  advanced features  of Weber. In this section we'll walk through the necessary steps, using a simple frequency discrimination experiment.  In this experiment, on each trial, listeners hear a low and a high tone, separated in frequency by an adaptively adjusted delta. Their task is to indicate which tone is lower, and the delta is adjusted to determine the difference in frequency at which listeners respond with 79% accuracy. The entire example code is provided below.   using Weber\n\nversion = v 0.0.2 \nsid,trial_skip,adapt = @read_args( Frequency Discrimination ($version). ,\n                                  adapt=[:levitt,:bayes])\n\nconst atten_dB = 30\nconst n_trials = 60\nconst feedback_delay = 750ms\n\nisresponse(e) = iskeydown(e,key p ) || iskeydown(e,key q )\n\nconst standard_freq = 1kHz\nconst standard = attenuate(ramp(tone(standard_freq,0.1)),atten_dB)\nfunction one_trial(adapter)\n  first_lower = rand(Bool)\n  resp = response(adapter,key q  =   first_lower ,key p  =   second_lower ,\n                  correct=(first_lower ?  first_lower  :  second_lower ))\n\n  signal() = attenuate(ramp(tone(standard_freq*(1-delta(adapter)),0.1s)),atten_dB)\n  stimuli = first_lower? [signal,standard] : [standard,signal]\n\n  [moment(feedback_delay,play,stimuli[1]),\n   show_cross(),\n   moment(0.9s,play,stimuli[2]),\n   moment(0.1s + 0.3s,display,\n           Was the first [Q] or second sound [P] lower in pitch? ),\n   resp,await_response(isresponse)]\nend\n\nexperiment = Experiment(\n  skip=trial_skip,\n  columns = [\n    :sid =  sid,\n    :condition =   example ,\n    :version =  version,\n    :standard =  standard_freq\n  ]\n)\n\nsetup(experimerntent) do\n  addbreak(moment(record, start ))\n\n  addbreak(instruct( \n\n    On each trial, you will hear two beeps. Indicate which of the two beeps you\nheard was lower in pitch. Hit 'Q' if the first beep was lower, and 'P' if the\nsecond beep was lower. ))\n\n  if adapt == :levitt\n    adapter = levitt_adapter(down=3,up=1,min_delta=0,max_delta=1,\n                             big=2,little=sqrt(2),mult=true)\n  else\n    adapter = bayesian_adapter(min_delta = 0,max_delta = 0.95)\n  end\n\n  @addtrials let a = adapter\n    for trial in 1:n_trials\n      addtrial(one_trial(a))\n    end\n\n    # define this string during experiment setup\n    # when we know what block we're on...\n\n    function threshold_report()\n      mean,sd = estimate(adapter)\n      thresh = round(mean,3)*standard_freq\n      thresh_sd = round(sd,3)*standard_freq\n\n      # define this string during run time when we know\n      # what the threshold estimate is.\n       Threshold $(thresh)Hz (SD: $thresh_sd)\\n *\n       Hit spacebar to continue... \n    end\n\n    addbreak(moment(display,threshold_report,clean_whitespace=false),\n             await_response(iskeydown(key :space: )))\n  end\n\nend\n\nrun(experimerntent)  In what follows we'll walk through the parts of this code unique to creating an adaptive track. For more details on the basics of creating an experiment see  Getting Started .", 
            "title": "Using an Adaptive Track"
        }, 
        {
            "location": "/adaptive/#creating-the-adapter", 
            "text": "if adapt == :levitt\n  adapter = levitt_adapter(down=3,up=1,min_delta=0,max_delta=1,\n                           big=2,little=sqrt(2),mult=true)\nelse\n  adapter = bayesian_adapter(min_delta = 0,max_delta = 0.95)\nend  The present experiment can be run using either of two built-in adapters:  levitt_adapter  and  bayesian_adapter . An adapter is the object you create to run an adaptive track, and defines the particular algorithm that will be used to select a new delta on each trial, based on the responses to previous deltas.", 
            "title": "Creating the Adapter"
        }, 
        {
            "location": "/adaptive/#generating-stimuli", 
            "text": "const standard = attenuate(ramp(tone(standard_freq,0.1s)),atten_dB)\n...\nsignal() = attenuate(ramp(tone(standard_freq*(1-delta(adapter)),0.1s)),atten_dB)\nstimuli = first_lower? [signal,standard] : [standard,signal]  The two stimuli presented to the listener are the standard (always at 1kHz) and the signal (1kHz - delta). The standard is always the same, and so can be generated in advance before the experiment begins. The signal must be generated during the experiment, on each trial. The next delta is queried from the adapter using  delta . The signal is defined as a function that takes no arguments. When passed a function,  play  generates the stimulus defined by that function at runtime, rather than  setup time , which is precisely what we want in this case.", 
            "title": "Generating Stimuli"
        }, 
        {
            "location": "/adaptive/#collecting-responses", 
            "text": "resp = response(adapter,key q  =   first_lower ,key p  =   second_lower ,\n                  correct=(first_lower ?  first_lower  :  second_lower ))  To update the adapter after each response, a special method of the  response  function is used, which takes the adapter as its first argument. We also must indicate which response is correct by setting  correct  appropriately.", 
            "title": "Collecting Responses"
        }, 
        {
            "location": "/adaptive/#generating-trials", 
            "text": "@addtrials let a = adapter\n  for trial in 1:n_trials\n    addtrial(one_trial(a))\n  end\n  addbreak(moment(display,() -   Estimated threshold: $(estimate(adapter)[1])\\n ,\n                                 Hit spacebar to exit. ),\n           await_response(iskeydown(key :space: )))\nend  To generate the trials, which depend on the run-time state of the adapter, we use the  @addtrials  macro. Any time the behavior of listeners in one trial influences subsequent trials, this macro will be necessary. In this case it is used to signal to Weber that the trials added inside the loop depend on the run-time state of the adapter.  After all trials have been run, we report the threshold estimated by the adapter using the  estimate  function, which returns both the mean and measurement error.", 
            "title": "Generating Trials"
        }, 
        {
            "location": "/adaptive/#reporting-the-threshold", 
            "text": "# define this string during experiment setup\n# when we know what block we're on...\n\nfunction threshold_report()\n  mean,sd = estimate(adapter)\n  thresh = round(mean,3)*standard_freq\n  thresh_sd = round(sd,3)*standard_freq\n\n  # define this string during run time when we know\n  # what the threshold estimate is.\n   Threshold $(thresh)Hz (SD: $thresh_sd)\\n *\n   Hit spacebar to continue... \nend\n\naddbreak(moment(display,threshold_report,clean_whitespace=false),\n         await_response(iskeydown(key :space: )))  You can report the threshold at the end of an experiment using  estimate , as above, but this isn't strictly necessary. The tricky part is to make sure you find the estimate  after  trials have been run (during run time).", 
            "title": "Reporting the Threshold"
        }, 
        {
            "location": "/adaptive/#custom-adaptive-tracking-algorithms", 
            "text": "You can define your own adaptive tracking algorithms by defining a new type that is a child of  Adapter . You must define an appropriate function to generate the adapter, and methods of  Weber.update! ,  estimate  and  delta  for this type. Strictly speaking estimate need not be implemented, if you choose not to make use of this method in your experiment.", 
            "title": "Custom Adaptive Tracking Algorithms"
        }, 
        {
            "location": "/advanced/", 
            "text": "There are several concepts and techniques best avoided unless they are really necessary. These generally complicate the creation of experiments. \n\n\n\n\nStateful Trials\n\n\nSome experiments require that what trials present depend on responses to previous trials. For instance, adaptive tracking to find a discrimination threshold.\n\n\nIf your trials depend on experiment-changing state, you need to use the macro \n@addtrials\n.\n\n\nThere are three kinds of trials you can add with this macro: blocks, conditionals and loops.\n\n\n\n\nBlocks of Trials\n\n\n@addtrials let [assignments]\n  body...\nend\n\n\n\n\nBlocks of trials are useful for setting up state that will change during the trials. Such state can then be used in a subsequent @addtrials expression. In fact all other types of @addtrials expression will likely be nested inside blocks. The main reason to use such a block is to ensure that  \nWeber.offset\n is well defined.\n\n\nThe offset counter is used to fast-forward through the expeirment by specifying an offset greater than 0.  However, if there is state that changes throughout the course of several trials, those trials cannot reliably be reproduced when only some of them are skipped. Either all or none of the trials that depend on one another should be skipped.\n\n\nAnytime you have a series of trials, some of which depend on what happens earlier in an expeirment, such trials should be placed inside of an @addtrials let block. Otherwise experiment fast forwarding will result in unexpected behaviors.\n\n\n\n\nConditional Trials\n\n\n@addtrials if [cond1]\n  body...\nelseif [cond2]\n  body...\n...\nelseif [condN]\n  body...\nelse\n  body...\nend\n\n\n\n\nAdds one or mores trials that are presented only if the given conditions are met. The expressions \ncond1\n through \ncondN\n are evaluted during the experiment, but each \nbody\n is executed before the experiment begins, and is used to indicate the set of trials (and breaks or practice trials) that will be run for a given condition.\n\n\nFor example, the following code only runs the second trial if the user hits the \"y\" key.\n\n\n@addtrials let y_hit = false\n  isresponse(e) = iskeydown(e,key\ny\n) || iskeydown(e,key\nn\n)\n  addtrial(moment(display,\nHit Y or N.\n),await_response(isresponse)) do event\n    if iskeydown(event,key\ny\n)\n      y_hit = true\n    end\n  end\n\n  @addtrials if !y_hit\n    addtrial(moment(display,\nYou did not hit Y!\n),await_response(iskeydown))\n  end\nend\n\n\n\n\nIf \n@addtrials if !y_hit\n was replaced with \nif !y_hit\n in the above example, the second trial would always run. This is because the \nif\n expression would be run during setup-time, before any trials were run (when \ny_hit\n is false).\n\n\n\n\nLooping Trials\n\n\n@addtrials while expr\n  body...\nend\n\n\n\n\nAdd some number of trials that repeat as long as \nexpr\n evalutes to true. For example the follow code runs as long as the user hits the \"y\" key.\n\n\n@addtrials let y_hit = true\n  @addtrials while y_hit\n    message = moment(display,\nHit Y if you want to continue\n)\n    addtrial(message,await_response(iskeydown)) do event\n      y_hit = iskeydown(event,key\ny\n)\n    end\n  end\nend\n\n\n\n\nIf \n@addtrials while y_hit\n was replaced with \nwhile y_hit\n in the above example, the while loop would never terminate, running an infinite loop, because \ny_hit\n is true before the experiment starts.\n\n\n\n\nRun-time stimulus generation.\n\n\nWhen stimuli need to be generated during an experiment the normal approach will not work. For instance, if you want a tone's frequency to depend on some delta value that changes during the experimrent the following will not work.\n\n\n# THIS WILL NOT WORK!!!\nmoment(play,tone(1kHz+my_delta,1s))\n\n\n\n\nThe basic problem here is that tone is used to generate a sound at \nsetup-time\n. What we want is for the run-time value of \nmy_delta\n to be used. To do this you can pass a function to play. This function will be used to generate a sound during runtime.\n\n\nmoment(play,() -\n tone(1kHz+my_delta,1s))\n\n\n\n\nSimilarly, we can use a runtime value in display by passing a function to display.\n\n\nmoment(display,() -\n \nhello $my_name.\n)\n\n\n\n\nWhen moments are created this way, the sound or visual is generated before the moment even begins, to eliminate any latency that would be introduced by loading the sound or visual into memory. Specifically, the stimulus is generated during the most recent non-zero pause occuring before a moment. So for instance, in the following example, \nmysound\n will be generated ~0.5 seconds before play is called right after \"Get ready!\" is displayed.\n\n\naddtrial(moment(display,\nGet ready!\n),moment(0.5s),\n         moment(display,\nHere we go!\n),moment(play,mysound))", 
            "title": "Advanced Experiments"
        }, 
        {
            "location": "/advanced/#stateful-trials", 
            "text": "Some experiments require that what trials present depend on responses to previous trials. For instance, adaptive tracking to find a discrimination threshold.  If your trials depend on experiment-changing state, you need to use the macro  @addtrials .  There are three kinds of trials you can add with this macro: blocks, conditionals and loops.", 
            "title": "Stateful Trials"
        }, 
        {
            "location": "/advanced/#blocks-of-trials", 
            "text": "@addtrials let [assignments]\n  body...\nend  Blocks of trials are useful for setting up state that will change during the trials. Such state can then be used in a subsequent @addtrials expression. In fact all other types of @addtrials expression will likely be nested inside blocks. The main reason to use such a block is to ensure that   Weber.offset  is well defined.  The offset counter is used to fast-forward through the expeirment by specifying an offset greater than 0.  However, if there is state that changes throughout the course of several trials, those trials cannot reliably be reproduced when only some of them are skipped. Either all or none of the trials that depend on one another should be skipped.  Anytime you have a series of trials, some of which depend on what happens earlier in an expeirment, such trials should be placed inside of an @addtrials let block. Otherwise experiment fast forwarding will result in unexpected behaviors.", 
            "title": "Blocks of Trials"
        }, 
        {
            "location": "/advanced/#conditional-trials", 
            "text": "@addtrials if [cond1]\n  body...\nelseif [cond2]\n  body...\n...\nelseif [condN]\n  body...\nelse\n  body...\nend  Adds one or mores trials that are presented only if the given conditions are met. The expressions  cond1  through  condN  are evaluted during the experiment, but each  body  is executed before the experiment begins, and is used to indicate the set of trials (and breaks or practice trials) that will be run for a given condition.  For example, the following code only runs the second trial if the user hits the \"y\" key.  @addtrials let y_hit = false\n  isresponse(e) = iskeydown(e,key y ) || iskeydown(e,key n )\n  addtrial(moment(display, Hit Y or N. ),await_response(isresponse)) do event\n    if iskeydown(event,key y )\n      y_hit = true\n    end\n  end\n\n  @addtrials if !y_hit\n    addtrial(moment(display, You did not hit Y! ),await_response(iskeydown))\n  end\nend  If  @addtrials if !y_hit  was replaced with  if !y_hit  in the above example, the second trial would always run. This is because the  if  expression would be run during setup-time, before any trials were run (when  y_hit  is false).", 
            "title": "Conditional Trials"
        }, 
        {
            "location": "/advanced/#looping-trials", 
            "text": "@addtrials while expr\n  body...\nend  Add some number of trials that repeat as long as  expr  evalutes to true. For example the follow code runs as long as the user hits the \"y\" key.  @addtrials let y_hit = true\n  @addtrials while y_hit\n    message = moment(display, Hit Y if you want to continue )\n    addtrial(message,await_response(iskeydown)) do event\n      y_hit = iskeydown(event,key y )\n    end\n  end\nend  If  @addtrials while y_hit  was replaced with  while y_hit  in the above example, the while loop would never terminate, running an infinite loop, because  y_hit  is true before the experiment starts.", 
            "title": "Looping Trials"
        }, 
        {
            "location": "/advanced/#run-time-stimulus-generation", 
            "text": "When stimuli need to be generated during an experiment the normal approach will not work. For instance, if you want a tone's frequency to depend on some delta value that changes during the experimrent the following will not work.  # THIS WILL NOT WORK!!!\nmoment(play,tone(1kHz+my_delta,1s))  The basic problem here is that tone is used to generate a sound at  setup-time . What we want is for the run-time value of  my_delta  to be used. To do this you can pass a function to play. This function will be used to generate a sound during runtime.  moment(play,() -  tone(1kHz+my_delta,1s))  Similarly, we can use a runtime value in display by passing a function to display.  moment(display,() -   hello $my_name. )  When moments are created this way, the sound or visual is generated before the moment even begins, to eliminate any latency that would be introduced by loading the sound or visual into memory. Specifically, the stimulus is generated during the most recent non-zero pause occuring before a moment. So for instance, in the following example,  mysound  will be generated ~0.5 seconds before play is called right after \"Get ready!\" is displayed.  addtrial(moment(display, Get ready! ),moment(0.5s),\n         moment(display, Here we go! ),moment(play,mysound))", 
            "title": "Run-time stimulus generation."
        }, 
        {
            "location": "/extend/", 
            "text": "Functionality can be added to Weber via extensions. You can add multiple extensions to the same experiment. The \nreference\n provides a list of available extensions. Here we'll cover how to create new extensions.\n\n\nExtensions can create new methods of existing Weber functions on custom types, just like any Julia package, and this may be all that's necessary to extend Weber.\n\n\nHowever, extensions also have several ways to insert additional behavior into a number of methods via special extension machinery.\n\n\n\n\naddcolumn\n\n\nsetup\n\n\nrun\n\n\nrecord\n\n\naddtrial\n\n\naddpractice\n\n\naddbreak\n\n\npoll_events\n\n\n\n\nTo extend one of these functions you first define an extension type. For example:\n\n\ntype MyExtension \n: Weber.Extension\n  my_value::String\nend\n\n\n\n\nFor all of the public functions above (everything but \npoll_events\n), you can then define a new method of these functions that includes one additional argument beyond that listed in its documentation, located before all other arguments. This argument should be of type \nExtendedExperiment{MyExtension}\n. To extend the private \npoll_events\n function, replace the \nExperiment\n argument with an \nExtendedExperiment{MyExtension}\n argument.\n\n\n\n\nDon't extend unlisted functions\n\n\nThese functions have specific machinery setup to make extension possible. Don't use this same approach with other functions and expect your extension to work.\n\n\n\n\nAs an example, \nrecord\n could be extended as follows.\n\n\nfunction record(experiment::ExtendedExperiment{MyExtension},code;keys...)\n  record(next(experiment),code;my_extension=extension(experiment).my_value,keys...)\nend\n\n\n\n\nThere are a few things to note about this implementation. First,  the extension object is accessed using \nextension\n.\n\n\nSecond, \nrecord\n is called on the \nnext\n extension.  \nAll extended functions should follow this pattern\n. Each experiment can have multiple extensions, and each pairing of an experiment with a particular extension is called an experiment \nversion\n. These are ordered from top-most to bottom-most version. The top-most version is paired with the first extension in the list specified during the call to \nExperiment\n. Subsequent versions are accessed in this same order, using \nnext\n, until the bottom-most version, which is the experiment without any paired extension.\n\n\nFor the extension to \nrecord\n to actually work, \nsetup\n must also be extended to add the column \n:my_extension\n to the data file.\n\n\nfunction setup(fn::Function,experiment::ExtendedExperiment{MyExtension})\n  setup(next(experiment)) do\n    addcolumn(top(experiment),:my_extension)\n    fn()\n  end\nend\n\n\n\n\nThis demonstrates one last important concept. When calling \naddcolumn\n, the function \ntop\n is called on the experiment to get the top-most version of the experiment. This is done so that any functionality of versions above the current one will be utilized in the call to \naddcolumn\n.\n\n\n\n\nWhen to use \nnext\n and \ntop\n\n\nAs a general rule, inside an extended method, when you dispatch over the same function which that method implements, you should pass it \nnext(experiment)\n while all other functions taking an experiment argument should be passed \ntop(experiment)\n.\n\n\n\n\n\n\nThe private interface of run-time objects.\n\n\nMost of the functionality above is for the extension of \nsetup-time\n behavior. However, there are two ways to implement new run-time behavior: the generation of custom events and custom moments.\n\n\n\n\nCustom Events\n\n\nExtensions to \npoll_events\n can be used to notify watcher functions of new kinds of events. An event is an object that inherits from \nWeber.ExpEvent\n and which is tagged with the \n@event\n macro. Custom events can implement new methods for the existing \npublic functions on events\n or their own new functions.\n\n\nIf you define new functions, instead of leveraging the existing ones, they should generally have some default behavior for all \nExpEvent\n objects, so it is easy to call the method on any event a watcher moment receives.\n\n\n\n\nEvent Timing\n\n\nTo specify event timing, you must define a \ntime\n method for your custom event. You can simply store the time passed to \npoll_events\n in your custom event, or, if you have more precise timing information for your hardware you can store it here. Internally, the value returend by \ntime\n is used to determine when to run the next moment when a prior moment triggers on the event.\n\n\n\n\nCustom Key Events\n\n\nOne approach, if you are implementing events for a hardware input device, is to implement methods for \niskeydown\n. You can define your own type of keycode (which should be of some new custom type \n: Weber.Key\n). Then, you can make use of the \n@key_str\n macro by adding entries to the \nWeber.str_to_code\n dictionary (a private global constant). So for example, you could add the following to the module implementing your extension.\n\n\nWeber.str_to_code[\nmy_button1\n] = MyHardwareKey(1)\nWeber.str_to_code[\nmy_button1\n] = MyHardwareKey(2)\n\n\n\n\nSuch key types should implement \n==\n, \nhash\n and \nisless\n so that key events can be ordered. This allows them to be displayed in an organized fashion when printed using \nlistkeys\n.\n\n\nOnce these events are defined you can extend \npoll_events\n so that it generates events that return true for \niskeydown(myevent,key\"my_button1\")\n (and a corresponding method for \niskeyup\n). How this happens will depend on the specific hardware you are supporting. These new events could then be used in an experiment as follows.\n\n\nresponse(key\nmy_button1\n =\n \nbutton1_pressed\n,\n         key\nmy_button2\n =\n \nbutton2_pressed\n)\n\n\n\n\n\n\nCustom Moments\n\n\nYou can create your own moment types, which must be children of \nWeber.SimpleMoment\n. These new moments will have to be generated using some newly defined function, or added automatically by extending \naddtrial\n. Once created, and added to trials, these moments will be processed at run-time using the function \nhandle\n, which should define the moment's run-time behavior. Such a moment must also define \nmoment_trace\n.\n\n\nA moment can also define \ndelta_t\n\u2013to define when it occurs\u2013or \nprepare!\n\u2013to have some kind of initialization occur before its onset\u2013but these both have default implementations.\n\n\nMethods of \nhandle\n should not make use of the extension machinery described above. What this means is that methods of \nhandle\n should never dispatch on an extended experiment, and no calls to \ntop\n, \nnext\n or \nextension\n should occur on the experiment object. Further, each moment should belong to one specific extension, in which all functionality for that custom moment should be implemented.\n\n\n\n\nRegistering Your Extension\n\n\nOptionally, you can make it possible for users to extend Weber without ever having to manually download or import your extension.\n\n\nTo do so you register your extension using the \n@Weber.extension\n macro. This macro is not exported and should not be called within your extensions module. Instead you should submit a pull request to \nWeber\n with your new extension defintion added to \nextensions.jl\n. Once your extension is also a registered package with \nMETADATA.jl\n it can be downloaded the first time a user initializes your extension using its corresponding macro.", 
            "title": "Extending Weber"
        }, 
        {
            "location": "/extend/#the-private-interface-of-run-time-objects", 
            "text": "Most of the functionality above is for the extension of  setup-time  behavior. However, there are two ways to implement new run-time behavior: the generation of custom events and custom moments.", 
            "title": "The private interface of run-time objects."
        }, 
        {
            "location": "/extend/#custom-events", 
            "text": "Extensions to  poll_events  can be used to notify watcher functions of new kinds of events. An event is an object that inherits from  Weber.ExpEvent  and which is tagged with the  @event  macro. Custom events can implement new methods for the existing  public functions on events  or their own new functions.  If you define new functions, instead of leveraging the existing ones, they should generally have some default behavior for all  ExpEvent  objects, so it is easy to call the method on any event a watcher moment receives.", 
            "title": "Custom Events"
        }, 
        {
            "location": "/extend/#event-timing", 
            "text": "To specify event timing, you must define a  time  method for your custom event. You can simply store the time passed to  poll_events  in your custom event, or, if you have more precise timing information for your hardware you can store it here. Internally, the value returend by  time  is used to determine when to run the next moment when a prior moment triggers on the event.", 
            "title": "Event Timing"
        }, 
        {
            "location": "/extend/#custom-key-events", 
            "text": "One approach, if you are implementing events for a hardware input device, is to implement methods for  iskeydown . You can define your own type of keycode (which should be of some new custom type  : Weber.Key ). Then, you can make use of the  @key_str  macro by adding entries to the  Weber.str_to_code  dictionary (a private global constant). So for example, you could add the following to the module implementing your extension.  Weber.str_to_code[ my_button1 ] = MyHardwareKey(1)\nWeber.str_to_code[ my_button1 ] = MyHardwareKey(2)  Such key types should implement  == ,  hash  and  isless  so that key events can be ordered. This allows them to be displayed in an organized fashion when printed using  listkeys .  Once these events are defined you can extend  poll_events  so that it generates events that return true for  iskeydown(myevent,key\"my_button1\")  (and a corresponding method for  iskeyup ). How this happens will depend on the specific hardware you are supporting. These new events could then be used in an experiment as follows.  response(key my_button1  =   button1_pressed ,\n         key my_button2  =   button2_pressed )", 
            "title": "Custom Key Events"
        }, 
        {
            "location": "/extend/#custom-moments", 
            "text": "You can create your own moment types, which must be children of  Weber.SimpleMoment . These new moments will have to be generated using some newly defined function, or added automatically by extending  addtrial . Once created, and added to trials, these moments will be processed at run-time using the function  handle , which should define the moment's run-time behavior. Such a moment must also define  moment_trace .  A moment can also define  delta_t \u2013to define when it occurs\u2013or  prepare! \u2013to have some kind of initialization occur before its onset\u2013but these both have default implementations.  Methods of  handle  should not make use of the extension machinery described above. What this means is that methods of  handle  should never dispatch on an extended experiment, and no calls to  top ,  next  or  extension  should occur on the experiment object. Further, each moment should belong to one specific extension, in which all functionality for that custom moment should be implemented.", 
            "title": "Custom Moments"
        }, 
        {
            "location": "/extend/#registering-your-extension", 
            "text": "Optionally, you can make it possible for users to extend Weber without ever having to manually download or import your extension.  To do so you register your extension using the  @Weber.extension  macro. This macro is not exported and should not be called within your extensions module. Instead you should submit a pull request to  Weber  with your new extension defintion added to  extensions.jl . Once your extension is also a registered package with  METADATA.jl  it can be downloaded the first time a user initializes your extension using its corresponding macro.", 
            "title": "Registering Your Extension"
        }, 
        {
            "location": "/experiment/", 
            "text": "#\n\n\nWeber.Experiment\n \n \nType\n.\n\n\nExperiment([skip=0],[columns=[symbols...]],[debug=false],\n           [moment_resolution=0.0015],[data_dir=\ndata\n],\n           [width=1024],[height=768],[warn_on_trials_only=true],[extensions=[]])\n\n\n\n\nPrepares a new experiment to be run.\n\n\nKeyword Arguments\n\n\n\n\nskip\n the number of offsets to skip. Allows restarting of an experiment somewhere in the middle. When an experiment is terminated, the most recent offset is reported. The offset is also recorded in each row of the resulting data file (also reported on exit).\n\n\ncolumns\n the names (as symbols) of columns that will be recorded during the experiment (using \nrecord\n). These can be set to fixed values (using :name =\n value), or be filled in during a call to record (:name). The column \n:value\n is always included here, even if not specified, since there are number of events recorded automatically which make use of this column.\n\n\ndebug\n if true, experiment will show in a windowed view\n\n\nmoment_resolution\n the desired precision that moments should be presented at. Warnings will be printed for moments that lack this precision.\n\n\ndata_dir\n the directory where data files should be stored (can be set to nothing to prevent a file from being created)\n\n\nwidth\n and \nheight\n specified the screen resolution during the experiment\n\n\nextensions\n an array of Weber.Extension objects, which \nextend\n the behavior of an experiment.\n\n\nwarn_on_trials_only\n when true, latency warnings are only displayed when the trial count is greater than 0. Thus, practice and breaks that occur before the first trial do not raise latency warnings.\n\n\n\n\nsource\n\n\n#\n\n\nWeber.addcolumn\n \n \nFunction\n.\n\n\naddcolumn(column::Symbol)\n\n\n\n\nAdds a column to be recorded in the data file.\n\n\nThis function must be called during setup.  It cannot be called once the experiment has begun. Repeatedly adding the same column only adds the column once. After adding a column you can include that column as a keyword argument to \nrecord\n. You need not write to the column for every record. If left out, the column will be empty in the resulting row of the data file.\n\n\nsource\n\n\n#\n\n\nWeber.setup\n \n \nFunction\n.\n\n\nsetup(fn,experiment)\n\n\n\n\nSetup the experiment, adding breaks, practice, and trials.\n\n\nSetup creates the context necessary to generate elements of an experiment. All calls to \naddtrial\n, \naddbreak\n and \naddpractice\n must be called inside of \nfn\n. This function must be called before \nrun\n.\n\n\nsource\n\n\n#\n\n\nBase.run\n \n \nFunction\n.\n\n\nrun(experiment;await_input=true)\n\n\n\n\nRuns an experiment. You must call \nsetup\n first.\n\n\nBy default, on windows, this function waits for user input before returning. This prevents a console from closing at the end of an experiment, preventing the user from viewing important messages. The exception is if run is called form within Juno: await_input should never be set to true in this case.\n\n\nsource\n\n\n#\n\n\nWeber.randomize_by\n \n \nFunction\n.\n\n\nrandomize_by(itr)\n\n\n\n\nRandomize by a given iterable object, usually a string (e.g. the subject id.)\n\n\nIf the same iterable is given, calls to random functions (e.g. \nrand\n, \nrandn\n and \nshuffle\n) will result in the same output.\n\n\nsource\n\n\n#\n\n\nWeber.@read_args\n \n \nMacro\n.\n\n\n@read_args(description,[keyword args...])\n\n\n\n\nReads experimental parameters from the user.\n\n\nWith no additional keyword arguments this requests the subject id, and an optional \nskip\n parameter (defaults to 0) from the user, and then returns them both in a tuple. The skip can be used to restart an experiment by passing it as the \nskip\n keyword argument to the \nExperiment\n constructor.\n\n\nYou can specify additional keyword arguments to request additional values from the user. Arguments that are a type will yield a request for textual input, and will verify that that input can be parsed as the given type. Arguments whose values are a list of symbols yield a request that the user select one of the specified values.\n\n\nArguments are requested from the user either as command-line arguments, or, if no command-line arguments were specified, interactively. Interactive arguments work both in the terminal or in Juno. This macro also generates useful help text that will be displayed to the user when they give a single command-line \"-h\" argument. This help text will include the \ndesecription\n string.\n\n\nExample\n\n\nsubject_id,skip,condition,block = @read_args(\nA simple experiment\n,\n  condition=[:red,:green,:blue],block=Int)\n\n\n\n\nsource\n\n\n#\n\n\nWeber.@read_debug_args\n \n \nMacro\n.\n\n\n@read_debug_args(description,[keyword args...])\n\n\n\n\nSame as @read_args, but better suited to debugging errors in your program when running the experiment in Juno.\n\n\nSpecifically, this verison will never spawn a new process to run the experiment. This means that you can safely step through the code using debugging tools. In this case, you will also likely want to set \ndebug=true\n when defining your \nExperiment\n object.\n\n\nsource\n\n\n#\n\n\nWeber.create_new_project\n \n \nFunction\n.\n\n\ncreate_new_project(name,dir=\n.\n)\n\n\n\n\nCreates a set of files to help you get started on a new experiment.\n\n\nThis creates a file called run_[name].jl, and a README.md and setup.jl file for your experiment. The readme provides useful information for running the experiment that is common across all experiments. The run file provides some guidelines to get you started creating an experiment and the setup file is a script that can be used to install Weber and any additional dependencies for the project, for anyone who wants to download and run your experiment.\n\n\nsource\n\n\n#\n\n\nWeber.trial\n \n \nFunction\n.\n\n\nWeber.trial()\n\n\n\n\nReturns the current trial of the experiment.\n\n\nsource\n\n\n#\n\n\nWeber.offset\n \n \nFunction\n.\n\n\nWeber.offset()\n\n\n\n\nReturns the current offset. The offset represents a well defined time in the experiment. The offset is typically incremented once for every call to \naddpractice\n \naddtrial\n and \naddbreak\n, unless you use \n@addtrials\n. You can use the offset to restart the experiment from a well defined location.\n\n\n\n\nWarning\n\n\nFor offsets to be well defined, all calls to \nmoment\n and \n@addtrials\n must follow the \nguidlines\n in the user guide. In particular, moments should not rely on state that changes during the experiment unless they are wrapped in an @addtrials macro.\n\n\n\n\nsource\n\n\n#\n\n\nWeber.tick\n \n \nFunction\n.\n\n\nWeber.tick()\n\n\n\n\nWith microsecond precision, this returns the number of elapsed seconds from the start of the experiment to the start of the most recent moment.\n\n\nIf there is no experiment running, this returns the time since epoch with microsecond precision.\n\n\nsource\n\n\n#\n\n\nWeber.metadata\n \n \nFunction\n.\n\n\nWeber.metadata() = Dict{Symbol,Any}()\n\n\nReturns metadata for this experiment. You can store global state, specific to this experiment, in this dictionary.\n\n\nsource", 
            "title": "Experiments"
        }, 
        {
            "location": "/trials/", 
            "text": "#\n\n\nWeber.addtrial\n \n \nFunction\n.\n\n\naddtrial(moments...)\n\n\n\n\nAdds a trial to the experiment, consisting of the specified moments.\n\n\nEach trial records a \"trial_start\" code, and increments a counter tracking the number of trials, and (normally) an offset counter. These two numbers are reported on every line of the resulting data file (see \nrecord\n). They can be retrieved using \nWeber.trial()\n and \nWeber.offset()\n.\n\n\nsource\n\n\n#\n\n\nWeber.addbreak\n \n \nFunction\n.\n\n\naddbreak(moments...)\n\n\n\n\nIdentical to \naddpractice\n, but records \"break_start\" instead of \"practice_start\".\n\n\nsource\n\n\n#\n\n\nWeber.addbreak_every\n \n \nFunction\n.\n\n\naddbreak_every(n,total,\n               [response=key\n:space:\n],[response_str=\nthe spacebar\n])\n\n\n\n\nAdds a break every \nn\n times this event is added given a known number of total such events.\n\n\nBy default this waits for the user to hit spacebar to move on.\n\n\nsource\n\n\n#\n\n\nWeber.addpractice\n \n \nFunction\n.\n\n\naddpractice(moments...)\n\n\n\n\nIdentical to \naddtrial\n, except that it does not incriment the trial count, and records a \"practice_start\" instead of \"trial_start\" code.\n\n\nsource\n\n\n#\n\n\nWeber.moment\n \n \nFunction\n.\n\n\nmoment([delta_t],[fn],args...;keys...)\n\n\n\n\nCreate a moment that occurs \ndelta_t\n (default 0) seconds after the onset of the previous moment, running the specified function.\n\n\nThe function \nfn\n is passed the arguments specified in \nargs\n and \nkeys\n.\n\n\nsource\n\n\nmoment(moments...)\nmoment(moments::Array)\n\n\n\n\nCreate a single, compound moment by concatentating several moments togethor.\n\n\nsource\n\n\n#\n\n\nWeber.response\n \n \nFunction\n.\n\n\nresponse(key1 =\n response1,key2 =\n response2,...;kwds...)\n\n\n\n\nCreate a watcher moment that records press of \nkey[n]\n as \nrecord(response[n];kwds...)\n.\n\n\nSee \nrecord\n for more details on how events are recorded.\n\n\nWhen a key is pressed down, the record event occurs. Key releases are also recorded, but are suffixed, by default, with \"_up\". This suffix can be changed using the \nkeyup_suffix\n keyword argument.\n\n\nsource\n\n\nresponse([fn],adapter,[key1] =\n [\nresp1\n],...;correct=[resp],\n         [show_feedback=true],\n         [feedback=Dict(true=\nCorrect\n,false=\nWrong!\n)]\n         keys...)\n\n\n\n\nRecord a response in a n-alternative forced choice task and update an adapter.\n\n\nThe first response recieved is interpreted as the actual response. Subsequent responses will be recorded, without a delta or correct value set, and appending \"late_\" to the specified response string.\n\n\nFunction Callback\n\n\nOptionally, upon participant response, \nfn\n receives two arguments: the provided response, and the correct response.\n\n\nKeyword Arguments\n\n\n\n\ncorrect\n the response string corresponding to the correct response\n\n\nshow_feedback\n (default = true): whether to show feedback to the participant after they respond.\n\n\nfeedback\n the text to display to a participant when they are correct (for the true key, defaults to \"Correct!\") or incorrect (for the false key, defaults to \"Wrong!\").\n\n\n\n\nAny additional keyword arguments are added as column values when the response is recorded.\n\n\nsource\n\n\n#\n\n\nWeber.await_response\n \n \nFunction\n.\n\n\nawait_response(isresponse;[atleast=0.0])\n\n\n\n\nThis moment starts when the \nisresponse\n function evaluates to true.\n\n\nThe \nisresponse\n function will be called anytime an event occurs. It should take one parameter (the event that just occured).\n\n\nIf the response is provided before \natleast\n seconds, the moment does not start until \natleast\n seconds have passed.\n\n\nsource\n\n\n#\n\n\nWeber.record\n \n \nFunction\n.\n\n\nrecord(code;keys...)\n\n\n\n\nRecord a row to the experiment data file using a given \ncode\n.\n\n\nEach event has a code which identifies it as being a particular type of experiment event. This is normally a string. Each keyword argument is the value of a column (with the same name). By convention when you record something with the same code you should specify the same set of columns.\n\n\nAll calls to record also result in many additional values being written to the data file. The start time and date of the experiment, the trial and offset number, the version of Weber, and the time at which the last moment started are all stored.  Additional information can be added during creation of the experiment (see \nExperiment\n).\n\n\nEach call to record writes a new row to the data file used for the experiment, so there should be no loss of data if the program is terminated prematurely for some reason.\n\n\n\n\nAutomatically Recorded Codes\n\n\nThere are several codes that are automatically recorded by Weber. They include:\n\n\n\n\ntrial_start\n - recorded at the start of moments added by \naddtrial\n\n\npractice_start\n - recorded at the start of moments added by \naddpractice\n\n\nbreak_start\n - recorded at the start of moments added by \naddbreak\n\n\nhigh_latency\n - recorded whenever a high latency warning is triggered. The \"value\" column is set to the error between the actual and the desired timing of a moment, in seconds.\n\n\npaused\n - recorded when user hits 'escape' and the experiment is paused.\n\n\nunpaused\n - recorded when the user ends the pause, continuuing the experiment.\n\n\nterminated\n - recorded when the user manually terminates the experiment (via 'escape')\n\n\nclosed\n - recorded just before the experiment window closes\n\n\n\n\n\n\nsource\n\n\n#\n\n\nWeber.timeout\n \n \nFunction\n.\n\n\ntimeout(fn,isresponse,timeout,[atleast=0.0])\n\n\n\n\nThis moment starts when either \nisresponse\n evaluates to true or timeout time (in seconds) passes.\n\n\nThe \nisresponse\n function will be called anytime an event occurs. It should take one parameter (the event that just occured).\n\n\nIf the moment times out, the function \nfn\n (with no arguments) will be called.\n\n\nIf the response is provided before \natleast\n seconds, the moment does not begin until \natleast\n seconds (\nfn\n will not be called).\n\n\nsource\n\n\n#\n\n\nWeber.show_cross\n \n \nFunction\n.\n\n\nshow_cross([delta_t])\n\n\n\n\nCreates a moment that shows a cross hair \ndelta_t\n seconds after the start of the previous moment (defaults to 0 seconds).\n\n\nsource\n\n\n#\n\n\nWeber.when\n \n \nFunction\n.\n\n\nwhen(condition,moments...)\n\n\n\n\nThis moment will begin at the \nstart\n of the previous moment, and presents the following moments (possibly in nested iterable objects) if the \ncondition\n function (which takes no arguments) evaluates to true.\n\n\nsource\n\n\n#\n\n\nWeber.looping\n \n \nFunction\n.\n\n\nlooping(when=fn,moments...)\n\n\n\n\nThis moment will begin at the \nstart\n of the previous moment, and repeats the listed moments (possibly in nested iterable objects) until the \nwhen\n function (which takes no arguments) evaluates to false.\n\n\nsource\n\n\n#\n\n\nWeber.@addtrials\n \n \nMacro\n.\n\n\n@addtrials expr...\n\n\n\n\nMarks a let block, a for loop, or an if expression as dependent on experiment \nrun-time\n state, leaving the offset counter unincremented within that block.  The immediately proceeding loop or conditional logic will be run during experiment run-time rather than setup-time.\n\n\nRefer to the \nAdvanced Topics\n of the manual section for more details.\n\n\nsource\n\n\n#\n\n\nWeber.update!\n \n \nFunction\n.\n\n\nupdate!(adapter,response,correct)\n\n\n\n\nUpdates any internal state for the adapter when the listener responds with \nresponse\n and the correct response is \ncorrect\n. Usually not called directly, but instead called within \nresponse\n, when the adapter is passed as the first argument. May take a while to run.\n\n\nsource\n\n\n#\n\n\nWeber.estimate\n \n \nFunction\n.\n\n\nestimate(adapter)\n\n\n\n\nReturns the mean and error of the adapters threshold estimate. May take some time to run.\n\n\nsource\n\n\n#\n\n\nWeber.delta\n \n \nFunction\n.\n\n\ndelta(adapter)\n\n\n\n\nReturns the next delta that should be tested to help estimate the threshold.\n\n\nsource\n\n\n#\n\n\nWeber.oddball_paradigm\n \n \nFunction\n.\n\n\noddball_paradigm(trial_body_fn,n_oddballs,n_standards;\n                 lead=20,no_oddball_repeats=true)\n\n\n\n\nHelper to generate trials for an oddball paradigm.\n\n\nThe trial_body_fn should setup stimulus presentation: it takes one argument, indicating if the stimulus should be a standard (false) or oddball (true) stimulus.\n\n\nIt is usually best to use oddball_paradigm with a do block syntax. For instance, the following code sets up 20 oddball and 150 standard trials.\n\n\noddball_paradigm(20,150) do isoddball\n  if isoddball\n    addtrial(...create oddball trial here...)\n  else\n    addtrial(...create standard trial here...)\n  end\nend\n\n\n\n\nKeyword arguments\n\n\n\n\nlead\n: determines the number of standards that repeat before any oddballs get presented\n\n\nno_oddball_repeats\n: determines if at least one standard must occur between each oddball (true) or not (false).\n\n\n\n\nsource\n\n\n#\n\n\nWeber.levitt_adapter\n \n \nFunction\n.\n\n\nlevitt_adapter([first_delta=0.1],[down=3],[up=1],\n               [big_reverse=3],[big=0.01],[little=0.005],\n               [min_reversals=7],[min_delta=-Inf],[max_delta=Inf],\n               [mult=false])\n\n\n\n\nAn adapter that finds a threshold according to a non-parametric statistical procedure. This approach makes fewer explicit assumptions than \nbayesian_adapter\n but may be slower to converge to a threshold.\n\n\nThis finds a threshold by moving the delta down after three correct responses and up after one incorrect response (these default up and down counts can be changed). This is the same approach described in Levitt (1971).\n\n\nKeyword Arguments\n\n\n\n\nfirst_delta\n: the delta that the first trial should present.\n\n\nup\n: how many incorrect responses in a row must occur for the delta to move up\n\n\ndown\n: how many correct responses in a row must occur for the delta to move down.\n\n\nbig\n: the amount delta changes by (up or down) at first\n\n\nbig_reverse\n: how many reveresals (up to down or down to up) must occur before \nlittle\n is used instead of \nbig\n\n\nlittle\n: the amount delta changes by (up or down) after \nbig_reverse\n reversals.\n\n\nmin_reversals\n: the smallest number of reversals that can be used to estimate a threshold.\n\n\nmin_delta\n: the smallest delta allowed\n\n\nmax_delta\n: the largest delta allowed\n\n\nmult\n: whether the delta change should be additive (false) or  multiplicative (true).\n\n\n\n\nsource\n\n\n#\n\n\nWeber.bayesian_adapter\n \n \nFunction\n.\n\n\nbayesian_adapter(;first_delta=0.1,\n                 n_samples=1000,miss=0.01,threshold=0.79,\n                 min_delta=0,max_delta=1,\n                 min_plausible_delta = 0.0001,\n                 max_plausible_delta = 0.2,\n                 repeat3_thresh=1.0,repeat2_thresh=0.1,\n                 thresh_prior=\n                 Truncated(LogNormal(log(min_plausible_delta),\n                                     log(max_plausible_delta/\n                                         min_plausible_delta/2)),\n                           min_delta,max_delta),\n                      inv_slope_prior=TruncatedNormal(0,0.25,0,Inf),\n                      thresh_d=thresh_prior,\n                      inv_slope_d=inv_slope_prior)\n\n\n\n\nAn adapter that finds a threshold according to a parametric statistical model. This makes more explicit assumptions than the \nlevitt_adapter\n but will normally find a threshold faster.\n\n\nThe psychometric curve is estimated from user responses using a bayesian approach. After estimation, each new delta is selected in a greedy fashion, picking the response that best minimizes entropy according to this psychometric function. This is a modified version of the approach described in Kontsevich \n Tyler 1999. Specifically, the approach here uses importance sampling instead of sampling parmeters over a deterministic, uniform grid. This should increase measurement efficiency if the priors are chosen well.\n\n\nThis algorithm assumes the following functional form for the psychometric response as a function of the stimulus difference $\u0394$.\n\n\n$f(\u0394) = \u03bb/2 + (1-\u03bb) \u03a6((\u0394 - \u03b8)\u22c5\u03c3/\u221a2)$\n\n\nIn the above $\u03a6$ is the cumulative distribution function of a normal distribution, $\u03bb$ is the miss-rate parameter, indicating the rate at which listeners make a mistake, even when the delta is large and easily heard, $\u03b8$ is the 50%-correct threshold, and $\u03c3$ is the psychometric slope.\n\n\nFor stability and robustness, this adapter begins by repeating the same delta multiple times and only begins quickly changing deltas trial-by-trial when the ratio of estiamted standard deviation to mean is small. This functionality can be adjusted using \nrepeat3_thresh\n and \nrepeat2_thresh\n, or, if you do not wish to have any repeats, both values can be set to Inf.\n\n\nKeyword Arugments\n\n\n\n\nfirst_delta\n: the delta to start measuring with\n\n\nn_samples\n the number of samples to use during importance sampling. The algorithm for selecting new deltas is O(n\u00b2).\n\n\nmiss\n the expected rate at which listeners will make mistakes even for easy to percieve differences.\n\n\nthreshold\n the %-response threshold to be estimated\n\n\nmin_delta\n the smallest possible delta\n\n\nmax_delta\n the largest possible delta\n\n\nmin_plausible_delta\n the smallest plausible delta, should be \n 0. Used to define a reasonable value for thresh_prior and inv_slope_prior.\n\n\nmax_plausible_delta\n the largest plausible delta, should be \n max_delta. Used to define a reasonable value for thresh_prior and inv_slope_prior.\n\n\nthresh_prior\n the prior probability distribution across thresholds. This influence the way the delta is adapted. By default this is defined in terms of min_plausible_delta and max_plausible_delta.\n\n\ninv_slope_prior\n the prior probability distribution across inverse slopes. By default this is defined in terms of min_plausible_delta and max_plausible_delta.\n\n\nthresh_d\n the distribution over-which to draw samples for the threshold during importance sampling. This defaults to thresh_prior\n\n\ninv_slope_d\n the distribution over-which to draw samples for the inverse slope during importance sampling. This defaults to inv_slope_prior.\n\n\nrepeat2_thresh\n the ratio of sd / mean for theta must suprass to repeat each delta twice.\n\n\nrepeat3_thresh\n the ratio of sd / mean for theta must surpass to repeat each delta thrice.\n\n\n\n\nsource\n\n\n#\n\n\nWeber.constant_adapter\n \n \nFunction\n.\n\n\nconstant_adapter(stimuli)\n\n\n\n\nAn adapter that can be used to implement the method of constant stimuli: the specified sequence of stimulus deltas is presented in order to participants.\n\n\nStrictly speaking, this is not an adaptive tracking procedure. However, it can be convienient to have the same programming interface for this method as for adaptive methods. In this way you can easily select between the method of constant stimuli or some kind of adaptive procedure.\n\n\nsource", 
            "title": "Trials"
        }, 
        {
            "location": "/sound/", 
            "text": "Sound Creation\n\n\n#\n\n\nWeber.sound\n \n \nFunction\n.\n\n\nsound(x::Array,[cache=true];[sample_rate=samplerate()])\n\n\n\n\nCreates a sound object from an arbitrary array.\n\n\nAssumes 1 is the loudest and -1 the softest. The array should be 1d for mono signals, or an array of size (N,2) for stereo sounds.\n\n\nWhen cache is set to true, sound will cache its results thus avoiding repeatedly creating a new sound for the same object.\n\n\n\n\nCalled Implicitly\n\n\nThis function is normally called implicitly in a call to \nplay(x)\n, so it need not normally be called directly.\n\n\n\n\nsource\n\n\nsound(file,[cache=true];[sample_rate=samplerate(file)])\n\n\n\n\nLoad a specified file as a sound.\n\n\nsource\n\n\nsound(stream,[len])\n\n\n\n\nConsume some amount of the stream, converting it to a finite \nsound\n.\n\n\nIf left unspecified, the entire stream is consumed.  Infinite streams throw an error.\n\n\nsource\n\n\n#\n\n\nWeber.tone\n \n \nFunction\n.\n\n\ntone(freq,length;[sample_rate=samplerate()],[phase=0])\n\n\n\n\nCreates a pure tone of the given frequency and length (in seconds).\n\n\nYou can create an infinitely long tone by passing a length of Inf, or leaving out the length entirely.\n\n\nsource\n\n\n#\n\n\nWeber.noise\n \n \nFunction\n.\n\n\nnoise(length=Inf;[sample_rate_Hz=44100],[rng=global RNG])\n\n\n\n\nCreates a period of white noise of the given length (in seconds).\n\n\nYou can create an infinite stream of noise by passing a length of Inf, or leaving out the length entirely.\n\n\nsource\n\n\n#\n\n\nWeber.silence\n \n \nFunction\n.\n\n\nsilence(length;[sample_rate=samplerate()])\n\n\n\n\nCreates period of silence of the given length (in seconds).\n\n\nsource\n\n\n#\n\n\nWeber.harmonic_complex\n \n \nFunction\n.\n\n\nharmonic_complex(f0,harmonics,amps,length,\n                 [sample_rate=samplerate()],[phases=zeros(length(harmonics))])\n\n\n\n\nCreates a harmonic complex of the given length, with the specified harmonics at the given amplitudes. This implementation is somewhat superior to simply summing a number of pure tones generated using \ntone\n, because it avoids beating in the sound that may occur due floating point errors.\n\n\nYou can create an infinitely long complex by passing a length of Inf, or leaving out the length entirely.\n\n\nsource\n\n\n#\n\n\nWeber.audible\n \n \nFunction\n.\n\n\naudible(fn,len=Inf,asseconds=true;[sample_rate=samplerate(),eltype=Float64])\n\n\n\n\nCreates monaural sound where \nfn(t)\n returns the amplitudes for a given \nRange\n of time points.\n\n\nIf \nasseconds\n is false, \naudible\n creates a monaural sound where \nfn(i)\n returns the amplitudes for a given \nRange\n of sample indices.\n\n\nThe function \nfn\n should always return elements of type \neltype\n.\n\n\nIf an infinite length is specified, a stream is created rather than a sound.\n\n\nThe function \nfn\n need not be pure and it can be safely assumed that \nfn\n will only be called for a given range of indices once. While indices and times passed to \nfn\n normally begin from 0 and 1, respectively, this is not always the case.\n\n\nsource\n\n\n\n\nSound Manipulation\n\n\n#\n\n\nWeber.highpass\n \n \nFunction\n.\n\n\nhighpass(x,high,[order=5],[sample_rate_Hz=samplerate(x)])\n\n\n\n\nHigh-pass filter the sound (or stream) at the specified frequency.\n\n\nFiltering uses a butterworth filter of the given order.\n\n\nsource\n\n\n#\n\n\nWeber.lowpass\n \n \nFunction\n.\n\n\nlowpass(x,low,[order=5],[sample_rate_Hz=samplerate(x)])\n\n\n\n\nLow-pass filter the sound (or stream) at the specified frequency.\n\n\nFiltering uses a butterworth filter of the given order.\n\n\nsource\n\n\n#\n\n\nWeber.bandpass\n \n \nFunction\n.\n\n\nbandpass(x,low,high;[order=5])\n\n\n\n\nBand-pass filter the sound (or stream) at the specified frequencies.\n\n\nFiltering uses a butterworth filter of the given order.\n\n\nsource\n\n\n#\n\n\nWeber.bandstop\n \n \nFunction\n.\n\n\nbandstop(x,low,high,[order=5],[sample_rate_Hz=samplerate(x)])\n\n\n\n\nBand-stop filter of the sound (or stream) at the specified frequencies.\n\n\nFiltering uses a butterworth filter of the given order.\n\n\nsource\n\n\n#\n\n\nWeber.ramp\n \n \nFunction\n.\n\n\nramp(x,[length=5ms])\n\n\n\n\nApplies a half cosine ramp to start and end of the sound.\n\n\nRamps prevent clicks at the start and end of sounds.\n\n\nsource\n\n\n#\n\n\nWeber.rampon\n \n \nFunction\n.\n\n\nrampon(stream,[len=5ms])\n\n\n\n\nApplies a half consine ramp to start of the sound or stream.\n\n\nsource\n\n\n#\n\n\nWeber.rampoff\n \n \nFunction\n.\n\n\nrampoff(stream,[len=5ms],[after=0s])\n\n\n\n\nApplies a half consine ramp to the end sound, or to a stream.\n\n\nFor streams, you may specify how many seconds after the call to rampff the stream should end.\n\n\nsource\n\n\n#\n\n\nWeber.fadeto\n \n \nFunction\n.\n\n\nfadeto(stream,channel=1,transition=0.05)\n\n\n\n\nA smooth transition from the currently playing stream to another stream.\n\n\nsource\n\n\nfadeto(sound1,sound2,overlap=0.05)\n\n\n\n\nA smooth transition from sound1 to sound2, overlapping the end of sound1 and the start of sound2 by \noverlap\n (in seconds).\n\n\nsource\n\n\n#\n\n\nWeber.attenuate\n \n \nFunction\n.\n\n\nattenuate(x,atten_dB;[time_constant])\n\n\n\n\nApply the given decibels of attenuation to the sound (or stream) relative to a power level of 1.\n\n\nThis function normalizes the sound to have a root mean squared value of 1 and then reduces the sound by a factor of $10^{-a/20}$, where $a$ = \natten_dB\n.\n\n\nThe keyword argument \ntime_constant\n determines the time across which the sound is normalized to power 1, which, for sounds, defaults to the entire sound and, for streams, defaults to 1 second.\n\n\nsource\n\n\n#\n\n\nWeber.mix\n \n \nFunction\n.\n\n\nmix(x,y,...)\n\n\n\n\nmix several sounds (or streams) together so that they play at the same time.\n\n\nUnlike normal addition, this acts as if each sound is padded with zeros at the end so that the lengths of all sounds match.\n\n\nsource\n\n\n#\n\n\nWeber.mult\n \n \nFunction\n.\n\n\nmult(x,y,...)\n\n\n\n\nMutliply several sounds (or streams) together. Typically used to apply an amplitude envelope.\n\n\nUnlike normal multiplication, this acts as if each sound is padded with ones at the end so that the lengths of all sounds match.\n\n\nsource\n\n\n#\n\n\nWeber.envelope\n \n \nFunction\n.\n\n\nenvelope(mult,length;[sample_rate_Hz=44100])\n\n\n\n\ncreates an envelope of a given multiplier and length (in seconds).\n\n\nIf mult = 0 this is the same as calling \nsilence\n. This function is useful in conjunction with \nfadeto\n and \nmult\n when defining an envelope that changes in level. For example, the following will play a 1kHz tone for 1 second, which changes in volume halfway through to a softer level.\n\n\nmult(tone(1000,1),fadeto(envelope(1,0.5),envelope(0.1,0.5)))\n\n\n\n\nsource\n\n\n#\n\n\nWeber.duration\n \n \nFunction\n.\n\n\nduration(x)\n\n\n\n\nGet the duration of the given sound in seconds.\n\n\nsource\n\n\n#\n\n\nWeber.nchannels\n \n \nMethod\n.\n\n\nnchannels(sound)\n\n\n\n\nReturn the number of channels (1 for mono, 2 for stereo) in this sound.\n\n\nsource\n\n\n#\n\n\nDistributions.nsamples\n \n \nMethod\n.\n\n\nnsamples(sound::Sound)\n\n\n\n\nReturns the number of samples in the sound.\n\n\nsource\n\n\n#\n\n\nWeber.audiofn\n \n \nFunction\n.\n\n\naudiofn(fn,x)\n\n\n\n\nApply \nfn\n to x for both sounds and streams.\n\n\nFor a sound this is the same as calling \nfn(x)\n.\n\n\nsource\n\n\nFor a stream, \nfn\n will be applied to each unit of sound as it is requested from the stream.\n\n\nsource\n\n\n#\n\n\nWeber.leftright\n \n \nFunction\n.\n\n\nleftright(left,right)\n\n\n\n\nCreate a stereo sound from two vectors or two monaural sounds.\n\n\nFor vectors, one can specify a sample_rate other than the default, if desired.\n\n\nsource\n\n\n#\n\n\nWeber.left\n \n \nFunction\n.\n\n\nleft(sound::Sound)\n\n\n\n\nExtract the left channel a stereo sound or stream.\n\n\nsource\n\n\n#\n\n\nWeber.right\n \n \nFunction\n.\n\n\nright(sound::Sound)\n\n\n\n\nExtract the right channel of a stereo sound or stream.\n\n\nsource\n\n\n\n\nPlayback\n\n\n#\n\n\nWeber.play\n \n \nFunction\n.\n\n\nplay(x;[channel=0])\n\n\n\n\nPlays a sound (created via \nsound\n).\n\n\nFor convenience, play can also can be called on any object that can be turned into a sound (via \nsound\n).\n\n\nThis function returns immediately with the channel the sound is playing on. You may provide a specific channel that the sound plays on: only one sound can be played per channel. Normally it is unecessary to specify a channel, because an appropriate channel is selected for you. However, pausing and resuming of sounds occurs on a per channel basis, so if you plan to pause a specific sound, you can do so by specifying its channel.\n\n\nStreams\n\n\nPlay can also be used to present a continuous stream of sound.  In this case, the channel defaults to channel 1 (there is no automatic selection of channels for streams). Streams are usually created by specifying an infinite length during sound generation using \ntone\n, \nnoise\n, \nharmonic_complex\n or \naudible\n.\n\n\nsource\n\n\nplay(fn::Function)\n\n\n\n\nPlay the sound that's returned by calling \nfn\n.\n\n\nsource\n\n\n#\n\n\nWeber.setup_sound\n \n \nFunction\n.\n\n\nsetup_sound(;[sample_rate=samplerate()],[num_channels=8],[queue_size=8],\n            [stream_unit=2^11])\n\n\n\n\nInitialize format and capacity of audio playback.\n\n\nThis function is called automatically (using the default settings) the first time a \nSound\n object is created (e.g. during \nplay\n).  It need not normally be called explicitly, unless you wish to change one of the default settings.\n\n\nSample Rate\n\n\nSample rate determines the maximum playable frequency (max freq is \u2248 sample_rate/2). Changing the sample rate from the default 44100 to a new value will also change the default sample rate sounds will be created at, to match this new sample rate.\n\n\nChannel Number\n\n\nThe number of channels determines the number of sounds and streams that can be played concurrently. Note that discrete sounds and streams use a distinct set of channels.\n\n\nQueue Size\n\n\nSounds can be queued to play ahead of time (using the \ntime\n parameter of \nplay\n). When you request that a sound be played it may be queued to play on a channel where a sound is already playing. The number of sounds that can be queued to play at once is determined by queue size. The number of channels times the queue size determines the number of sounds that you can queue up to play ahead of time.\n\n\nStream Unit\n\n\nThe stream unit determines the number of samples that are streamed at one time. If this value is too small for your hardware, streams will sound jumpy. However the latency of streams will increase as the stream unit increases.\n\n\nsource\n\n\n#\n\n\nWeber.playable\n \n \nFunction\n.\n\n\nplayable(x,[cache=true],[sample_rate=samplerate()])\n\n\n\n\nPrepare a sound or stream to be played.\n\n\nA call to \nplayable\n will ensure the sound is in the format required by \nplay\n.  This automatically calls \nsound\n on \nx\n if it not already appear to be a sound or a stream.\n\n\n\n\nCalled Implicitly\n\n\nThis need not be called explicitly, as play will call it for you, if need be.\n\n\n\n\nsource\n\n\n#\n\n\nDSP.Filters.resample\n \n \nMethod\n.\n\n\nresample(x::Sound,samplerate)\n\n\n\n\nReturns a new sound representing the sound \nx\n at the given sampling rate.\n\n\nYou will loose all frequencies in the sound above samplerate/2. Resampling occurs automatically when you call \nsound\n\u2013which is called inside \nplay\n\u2013anytime the sampling rate of the sound and the current audio playback settings (determined by \nsetup_sound\n) are not the same.\n\n\nTo avoid automatic resampling you can either create sounds at the appropriate sampling rate, as determined by \nsamplerate\n (recommended), or change the sampling rate initialized during \nsetup_sound\n (not recommended).\n\n\nsource\n\n\n#\n\n\nWeber.stop\n \n \nFunction\n.\n\n\nstop(channel)\n\n\n\n\nStop the stream that is playing on the given channel.\n\n\nsource\n\n\n#\n\n\nSampledSignals.samplerate\n \n \nFunction\n.\n\n\nsamplerate([sound])\n\n\n\n\nReport the sampling rate of the sound or of any object that can be turned into a sound.\n\n\nThe sampling rate of an object determines how many samples per second are used to represent the sound. Objects that can be converted to sounds are assumed to be at the sampling rate of the current hardware settings as defined by \nsetup_sound\n.\n\n\nsource\n\n\nWith no argument samplerate reports the current playback sample rate, as defined by \nsetup_sound\n.\n\n\nsource\n\n\n#\n\n\nWeber.current_sound_latency\n \n \nFunction\n.\n\n\ncurrent_sound_latency()\n\n\n\n\nReports the current, minimum latency of audio playback.\n\n\nThe current latency depends on your hardware and software drivers. This estimate does not include the time it takes for a sound to travel from your sound card to speakers or headphones. This latency estimate is used internally by \nplay\n to present sounds at accurate times.\n\n\nsource\n\n\n#\n\n\nWeber.pause_sounds\n \n \nFunction\n.\n\n\npause_sounds([channel],[isstream])\n\n\n\n\nPause all sounds (or a stream) playing on a given channel.\n\n\nIf no channel is specified, then all sounds are paused.\n\n\nsource\n\n\n#\n\n\nWeber.resume_sounds\n \n \nFunction\n.\n\n\nresume_sounds([channel],[isstream])\n\n\n\n\nResume all sounds (or a stream) playing on a given channel.\n\n\nIf no channel is specified, then all sounds are resumed.\n\n\nsource\n\n\n#\n\n\nWeber.run_calibrate\n \n \nFunction\n.\n\n\nrun_calibrate()\n\n\nRuns a program that will allow you to play pure tones and adjust their level.\n\n\nThis program provides one means of calibrating the levels of sound in your experiment. Using a sound-level meter you can determine the dB SPL of each tone, and adjust the attenuation to achieve a desired sound level.\n\n\nsource", 
            "title": "Sound"
        }, 
        {
            "location": "/sound/#sound-creation", 
            "text": "#  Weber.sound     Function .  sound(x::Array,[cache=true];[sample_rate=samplerate()])  Creates a sound object from an arbitrary array.  Assumes 1 is the loudest and -1 the softest. The array should be 1d for mono signals, or an array of size (N,2) for stereo sounds.  When cache is set to true, sound will cache its results thus avoiding repeatedly creating a new sound for the same object.   Called Implicitly  This function is normally called implicitly in a call to  play(x) , so it need not normally be called directly.   source  sound(file,[cache=true];[sample_rate=samplerate(file)])  Load a specified file as a sound.  source  sound(stream,[len])  Consume some amount of the stream, converting it to a finite  sound .  If left unspecified, the entire stream is consumed.  Infinite streams throw an error.  source  #  Weber.tone     Function .  tone(freq,length;[sample_rate=samplerate()],[phase=0])  Creates a pure tone of the given frequency and length (in seconds).  You can create an infinitely long tone by passing a length of Inf, or leaving out the length entirely.  source  #  Weber.noise     Function .  noise(length=Inf;[sample_rate_Hz=44100],[rng=global RNG])  Creates a period of white noise of the given length (in seconds).  You can create an infinite stream of noise by passing a length of Inf, or leaving out the length entirely.  source  #  Weber.silence     Function .  silence(length;[sample_rate=samplerate()])  Creates period of silence of the given length (in seconds).  source  #  Weber.harmonic_complex     Function .  harmonic_complex(f0,harmonics,amps,length,\n                 [sample_rate=samplerate()],[phases=zeros(length(harmonics))])  Creates a harmonic complex of the given length, with the specified harmonics at the given amplitudes. This implementation is somewhat superior to simply summing a number of pure tones generated using  tone , because it avoids beating in the sound that may occur due floating point errors.  You can create an infinitely long complex by passing a length of Inf, or leaving out the length entirely.  source  #  Weber.audible     Function .  audible(fn,len=Inf,asseconds=true;[sample_rate=samplerate(),eltype=Float64])  Creates monaural sound where  fn(t)  returns the amplitudes for a given  Range  of time points.  If  asseconds  is false,  audible  creates a monaural sound where  fn(i)  returns the amplitudes for a given  Range  of sample indices.  The function  fn  should always return elements of type  eltype .  If an infinite length is specified, a stream is created rather than a sound.  The function  fn  need not be pure and it can be safely assumed that  fn  will only be called for a given range of indices once. While indices and times passed to  fn  normally begin from 0 and 1, respectively, this is not always the case.  source", 
            "title": "Sound Creation"
        }, 
        {
            "location": "/sound/#sound-manipulation", 
            "text": "#  Weber.highpass     Function .  highpass(x,high,[order=5],[sample_rate_Hz=samplerate(x)])  High-pass filter the sound (or stream) at the specified frequency.  Filtering uses a butterworth filter of the given order.  source  #  Weber.lowpass     Function .  lowpass(x,low,[order=5],[sample_rate_Hz=samplerate(x)])  Low-pass filter the sound (or stream) at the specified frequency.  Filtering uses a butterworth filter of the given order.  source  #  Weber.bandpass     Function .  bandpass(x,low,high;[order=5])  Band-pass filter the sound (or stream) at the specified frequencies.  Filtering uses a butterworth filter of the given order.  source  #  Weber.bandstop     Function .  bandstop(x,low,high,[order=5],[sample_rate_Hz=samplerate(x)])  Band-stop filter of the sound (or stream) at the specified frequencies.  Filtering uses a butterworth filter of the given order.  source  #  Weber.ramp     Function .  ramp(x,[length=5ms])  Applies a half cosine ramp to start and end of the sound.  Ramps prevent clicks at the start and end of sounds.  source  #  Weber.rampon     Function .  rampon(stream,[len=5ms])  Applies a half consine ramp to start of the sound or stream.  source  #  Weber.rampoff     Function .  rampoff(stream,[len=5ms],[after=0s])  Applies a half consine ramp to the end sound, or to a stream.  For streams, you may specify how many seconds after the call to rampff the stream should end.  source  #  Weber.fadeto     Function .  fadeto(stream,channel=1,transition=0.05)  A smooth transition from the currently playing stream to another stream.  source  fadeto(sound1,sound2,overlap=0.05)  A smooth transition from sound1 to sound2, overlapping the end of sound1 and the start of sound2 by  overlap  (in seconds).  source  #  Weber.attenuate     Function .  attenuate(x,atten_dB;[time_constant])  Apply the given decibels of attenuation to the sound (or stream) relative to a power level of 1.  This function normalizes the sound to have a root mean squared value of 1 and then reduces the sound by a factor of $10^{-a/20}$, where $a$ =  atten_dB .  The keyword argument  time_constant  determines the time across which the sound is normalized to power 1, which, for sounds, defaults to the entire sound and, for streams, defaults to 1 second.  source  #  Weber.mix     Function .  mix(x,y,...)  mix several sounds (or streams) together so that they play at the same time.  Unlike normal addition, this acts as if each sound is padded with zeros at the end so that the lengths of all sounds match.  source  #  Weber.mult     Function .  mult(x,y,...)  Mutliply several sounds (or streams) together. Typically used to apply an amplitude envelope.  Unlike normal multiplication, this acts as if each sound is padded with ones at the end so that the lengths of all sounds match.  source  #  Weber.envelope     Function .  envelope(mult,length;[sample_rate_Hz=44100])  creates an envelope of a given multiplier and length (in seconds).  If mult = 0 this is the same as calling  silence . This function is useful in conjunction with  fadeto  and  mult  when defining an envelope that changes in level. For example, the following will play a 1kHz tone for 1 second, which changes in volume halfway through to a softer level.  mult(tone(1000,1),fadeto(envelope(1,0.5),envelope(0.1,0.5)))  source  #  Weber.duration     Function .  duration(x)  Get the duration of the given sound in seconds.  source  #  Weber.nchannels     Method .  nchannels(sound)  Return the number of channels (1 for mono, 2 for stereo) in this sound.  source  #  Distributions.nsamples     Method .  nsamples(sound::Sound)  Returns the number of samples in the sound.  source  #  Weber.audiofn     Function .  audiofn(fn,x)  Apply  fn  to x for both sounds and streams.  For a sound this is the same as calling  fn(x) .  source  For a stream,  fn  will be applied to each unit of sound as it is requested from the stream.  source  #  Weber.leftright     Function .  leftright(left,right)  Create a stereo sound from two vectors or two monaural sounds.  For vectors, one can specify a sample_rate other than the default, if desired.  source  #  Weber.left     Function .  left(sound::Sound)  Extract the left channel a stereo sound or stream.  source  #  Weber.right     Function .  right(sound::Sound)  Extract the right channel of a stereo sound or stream.  source", 
            "title": "Sound Manipulation"
        }, 
        {
            "location": "/sound/#playback", 
            "text": "#  Weber.play     Function .  play(x;[channel=0])  Plays a sound (created via  sound ).  For convenience, play can also can be called on any object that can be turned into a sound (via  sound ).  This function returns immediately with the channel the sound is playing on. You may provide a specific channel that the sound plays on: only one sound can be played per channel. Normally it is unecessary to specify a channel, because an appropriate channel is selected for you. However, pausing and resuming of sounds occurs on a per channel basis, so if you plan to pause a specific sound, you can do so by specifying its channel.  Streams  Play can also be used to present a continuous stream of sound.  In this case, the channel defaults to channel 1 (there is no automatic selection of channels for streams). Streams are usually created by specifying an infinite length during sound generation using  tone ,  noise ,  harmonic_complex  or  audible .  source  play(fn::Function)  Play the sound that's returned by calling  fn .  source  #  Weber.setup_sound     Function .  setup_sound(;[sample_rate=samplerate()],[num_channels=8],[queue_size=8],\n            [stream_unit=2^11])  Initialize format and capacity of audio playback.  This function is called automatically (using the default settings) the first time a  Sound  object is created (e.g. during  play ).  It need not normally be called explicitly, unless you wish to change one of the default settings.  Sample Rate  Sample rate determines the maximum playable frequency (max freq is \u2248 sample_rate/2). Changing the sample rate from the default 44100 to a new value will also change the default sample rate sounds will be created at, to match this new sample rate.  Channel Number  The number of channels determines the number of sounds and streams that can be played concurrently. Note that discrete sounds and streams use a distinct set of channels.  Queue Size  Sounds can be queued to play ahead of time (using the  time  parameter of  play ). When you request that a sound be played it may be queued to play on a channel where a sound is already playing. The number of sounds that can be queued to play at once is determined by queue size. The number of channels times the queue size determines the number of sounds that you can queue up to play ahead of time.  Stream Unit  The stream unit determines the number of samples that are streamed at one time. If this value is too small for your hardware, streams will sound jumpy. However the latency of streams will increase as the stream unit increases.  source  #  Weber.playable     Function .  playable(x,[cache=true],[sample_rate=samplerate()])  Prepare a sound or stream to be played.  A call to  playable  will ensure the sound is in the format required by  play .  This automatically calls  sound  on  x  if it not already appear to be a sound or a stream.   Called Implicitly  This need not be called explicitly, as play will call it for you, if need be.   source  #  DSP.Filters.resample     Method .  resample(x::Sound,samplerate)  Returns a new sound representing the sound  x  at the given sampling rate.  You will loose all frequencies in the sound above samplerate/2. Resampling occurs automatically when you call  sound \u2013which is called inside  play \u2013anytime the sampling rate of the sound and the current audio playback settings (determined by  setup_sound ) are not the same.  To avoid automatic resampling you can either create sounds at the appropriate sampling rate, as determined by  samplerate  (recommended), or change the sampling rate initialized during  setup_sound  (not recommended).  source  #  Weber.stop     Function .  stop(channel)  Stop the stream that is playing on the given channel.  source  #  SampledSignals.samplerate     Function .  samplerate([sound])  Report the sampling rate of the sound or of any object that can be turned into a sound.  The sampling rate of an object determines how many samples per second are used to represent the sound. Objects that can be converted to sounds are assumed to be at the sampling rate of the current hardware settings as defined by  setup_sound .  source  With no argument samplerate reports the current playback sample rate, as defined by  setup_sound .  source  #  Weber.current_sound_latency     Function .  current_sound_latency()  Reports the current, minimum latency of audio playback.  The current latency depends on your hardware and software drivers. This estimate does not include the time it takes for a sound to travel from your sound card to speakers or headphones. This latency estimate is used internally by  play  to present sounds at accurate times.  source  #  Weber.pause_sounds     Function .  pause_sounds([channel],[isstream])  Pause all sounds (or a stream) playing on a given channel.  If no channel is specified, then all sounds are paused.  source  #  Weber.resume_sounds     Function .  resume_sounds([channel],[isstream])  Resume all sounds (or a stream) playing on a given channel.  If no channel is specified, then all sounds are resumed.  source  #  Weber.run_calibrate     Function .  run_calibrate()  Runs a program that will allow you to play pure tones and adjust their level.  This program provides one means of calibrating the levels of sound in your experiment. Using a sound-level meter you can determine the dB SPL of each tone, and adjust the attenuation to achieve a desired sound level.  source", 
            "title": "Playback"
        }, 
        {
            "location": "/video/", 
            "text": "Visual display is largely handled by the methods defined in \nImages\n. However, this objects must be prepared by Weber using \nvisual\n and then a call to \ndisplay\n is made to show the visual. The call to \nvisual\n is normally handled automatically for you when you call \nmoment\n.\n\n\n#\n\n\nBase.Multimedia.display\n \n \nFunction\n.\n\n\ndisplay(r::SDLRendered;kwds...)\n\n\n\n\nDisplays anything rendered by \nvisual\n onto the current experiment window.\n\n\nAny keyword arguments, available from \nvisual\n are also available here. They overload the arguments as specified during visual (but do not change them).\n\n\ndisplay(x;kwds...)\n\n\n\n\nShort-hand for \ndisplay(visual(x);kwds...)\n. This is the most common way to use display. For example:\n\n\nmoment(0.5s,display,\nHello, World!\n)\n\n\n\n\nThis code will show the text \"Hello, World!\" on the screen 0.5 seconds after the start of the previous moment.\n\n\n\n\nWarning\n\n\nAssuming your hardware and video drivers permit it, \ndisplay\n sycnrhonizes to the screen refresh rate so long as the experiment window uses accelerated graphics (true by default). The display of a visual can be no more accurate than that permitted by this refresh rate. In particular, display can block for up to the length of an entire refresh cycle. If you want accurate timing in your experiment, make sure that there is nothing you want to occur immediately after calling display. If you want to display multiple visuals at once remember that you can compose visuals using the \n+\n operator, do not call display multiple times and expect these visual to all display at the same time (also note that the default behavior of visuals is to disappear when the next visual is shown).\n\n\n\n\nsource\n\n\ndisplay(fn::Function;kwds...)\n\n\n\n\nDisplay the visual returned by calling \nfn\n.\n\n\nsource\n\n\n#\n\n\nWeber.visual\n \n \nFunction\n.\n\n\nvisual(obj,[duration=0s],[priority=0],keys...)\n\n\n\n\nRender an object, allowing \ndisplay\n to show the object in current experiment's window.\n\n\nArguments\n\n\n\n\nduration: A positive duration means the object is displayed for the given duration, otherwise the object displays until a new object is displayed.\n\n\npriority: Higher priority objects are always visible above lower priority ones. Newer objects display over same-priority older objects.\n\n\n\n\nIf coordinates are used they are in units of half screen widths (for x) and heights (for y), with (0,0) at the center of the screen.\n\n\n\n\nNote\n\n\nBy using using the \n+\n operator, multiple visual objects can be composed into one object, so that they are displayed together\n\n\n\n\nsource\n\n\nvisual(color,[duration=0s],[priority=0])\n\n\n\n\nRender a color, across the entire screen.\n\n\nsource\n\n\nvisual(str::String, [font=nothing], [font_name=\narial\n], [size=32],\n       [color=colorant\nwhite\n],\n       [wrap_width=0.8],[clean_whitespace=true],[x=0],[y=0],[duration=0s],\n       [priority=0])\n\n\n\n\nRender the given string as an image that can be displayed. An optional second argument can specify a font, loaded using the \nfont\n function.\n\n\n\n\nStrings treated as files...\n\n\nIf the string passed refers to an image file\u2013becasue the string ends in a file type, like .bmp or .png\u2013-it will be treated as an image to be loaded and displayed, rather than as a string to be printed to the screen. Refer to the documentation of \nvisual\n for image objects.\n\n\n\n\nArguments\n\n\n\n\nwrap_width: the proporition of the screen that the text can utilize before wrapping.\n\n\nclean_whitespace: if true, replace all consecutive white space with a single space.\n\n\n\n\nsource\n\n\nvisual(img, [x=0],[y=0],[duration=0s],[priority=0])\n\n\n\n\nPrepare the color or gray scale image to be displayed to the screen.\n\n\nFor a string or file reference, this loads and prepares for display the given image file. For an array this utilizes all the conventions in the \nImages\n package for representing images. Internally, real-number 2d arrays are interpreted as gray scale images, and real-number 3d arrays as an RGB image or RGBA image, depending on whether size(img,1) is of size 3 or 4. A 3d array with a size(img,1) \u2209 [3,4] results in an error.\n\n\nsource\n\n\n#\n\n\nWeber.instruct\n \n \nFunction\n.\n\n\ninstruct(str;keys...)\n\n\n\n\nPresents some instructions to the participant.\n\n\nThis adds \"(Hit spacebar to continue...)\" to the end of the text, and waits for the participant to press spacebar to move on. It records an \"instructions\" event to the data file.\n\n\nAny keyword arguments are passed onto to \nvisual\n, which can be used to adjust how the instructions are displayed.\n\n\nsource\n\n\n#\n\n\nWeber.font\n \n \nFunction\n.\n\n\nfont(name,size,[dirs=os_default],[color=colorant\nwhite\n])\n\n\n\n\nCreates an \nSDLFont\n object to be used for for rendering text as an image.\n\n\nBy default this function looks in the current directory and then an os specific default font directory for a font with the given name (case insensitive). You can specify a different list of directories using the \ndirs\n parameter.\n\n\nsource\n\n\n#\n\n\nWeber.window\n \n \nFunction\n.\n\n\nwindow([width=1024],[height=768];[fullscreen=true],[title=\nExperiment\n],\n       [accel=true])\n\n\n\n\nCreate a window to which various objects can be rendered. See the \nvisual\n method.\n\n\nsource\n\n\n#\n\n\nBase.close\n \n \nFunction\n.\n\n\nclose(win::SDLWindow)\n\n\n\n\nCloses a visible SDLWindow window.\n\n\nsource", 
            "title": "Video"
        }, 
        {
            "location": "/event/", 
            "text": "#\n\n\nWeber.@event\n \n \nMacro\n.\n\n\n@Weber.event type [name] \n: [ExpEvent or ExpEvent child]\n  [fields...]\nend\n\n\n\n\nMarks a concrete type as being an experiment event.\n\n\nThis tag is necessary to ensure that all watcher moments are properly precompiled. This macro adds the event to a list of concrete events for which each watcher method must have a precompiled method.\n\n\nsource\n\n\n#\n\n\nWeber.@key_str\n \n \nMacro\n.\n\n\nkey\nkeyname\n\n\n\n\n\nGenerate a key code, using a single character (e.g. key\"q\" or key\"]\"), or some special key name surrounded by colons (e.g. :escape:).\n\n\nNote that keys are orderd and you can list all implemented keys in order, using \nlistkeys\n. If you want to quickly see the name for a given button you can use \nrun_keycode_helper()\n.\n\n\n\n\nCreating Custom Keycodes\n\n\nExtensions to Weber can define their own keycodes. Such codes must but of some new type inheriting from \nWeber.Key\n, and can be added to the list of codes this macro can generate by updating the private constant \nWeber.str_to_code\n. See the section in the user guide on extensions for more details.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Libc.time\n \n \nMethod\n.\n\n\ntime(e::ExpEvent)\n\n\n\n\nGet the time an event occured relative to the start of the experiment. Resolution is limited by an experiment's input_resolution (which can be specified upon initialization), and the response rate of the device. For instance, keyboards usually have a latency on the order of 20-30ms.\n\n\nsource\n\n\n#\n\n\nWeber.keycode\n \n \nFunction\n.\n\n\nkeycode(e::ExpEvent)\n\n\n\n\nReport the key code for this event, if there is one.\n\n\nsource\n\n\n#\n\n\nWeber.iskeydown\n \n \nFunction\n.\n\n\niskeydown(event,[key])\n\n\n\n\nEvalutes to true if the event indicates that the given key (or any key) was pressed down. (See \n@key_str\n)\n\n\niskeydown(key)\n\n\n\n\nReturns a function which tests if an event indicates the given key was pressed down.\n\n\nsource\n\n\n#\n\n\nWeber.modifiedby\n \n \nFunction\n.\n\n\nmodifiedby([event],[modifier = :shift,:ctrl,:alt or :gui])\n\n\n\n\nReturns true if the given event represents a keydown event modified by a given modifier key.\n\n\nWithout the first argument, returns a function that tests if the given event is a keydown event modified by a given modifier key.\n\n\nsource\n\n\n#\n\n\nWeber.iskeyup\n \n \nFunction\n.\n\n\niskeyup(event,[key])\n\n\n\n\nEvalutes to true if the event indicates that the given keyboard key (or any key) was released.  (See \n@key_str\n)\n\n\niskeyup(key)\n\n\n\n\nReturns a function which tests if an event indicates the given key was released.\n\n\nsource\n\n\n#\n\n\nWeber.listkeys\n \n \nFunction\n.\n\n\nlistkeys()\n\n\n\n\nLists all available key codes in order.\n\n\nAlso see \n@key_str\n.\n\n\nsource\n\n\n#\n\n\nWeber.run_keycode_helper\n \n \nFunction\n.\n\n\nrun_keycode_helper(;extensions=[])\n\n\n\n\nRuns a program that will display the keycode for each key that you press.\n\n\nsource\n\n\n#\n\n\nWeber.endofpause\n \n \nFunction\n.\n\n\nendofpause(event)\n\n\n\n\nEvaluates to true if the event indicates the end of a pause requested by the user.\n\n\nsource", 
            "title": "Events"
        }, 
        {
            "location": "/extend_ref/", 
            "text": "Available Extensions\n\n\nExtensions provide additional functionality for Weber. Currently there are two extensions availble:\n\n\n#\n\n\nWeber.@Cedrus\n \n \nMacro\n.\n\n\nExtension Website\n\n\n@Cedrus()\n\n\n\n\nCreates an extension for Weber allowing experiments to respond to events from Cedrus response-pad hardware. You can use \niskeydown\n and \niskeyup\n to check for events. To find the keycodes of the buttons for your response pad, run the following code, and press each of the buttons on the response pad.\n\n\nrun_keycode_helper(extensions=[@Cedrus()])\n\n\n\n\n\n\nDo not call inside a package\n\n\nDo not call @Cedrus inside of a package or in tests. It should only be used in one-off scripts. If WeberCedrus is not currently installed it will be installed by this macro using \nPkg.add\n which can lead to problems when called in packages or tests.\n\n\nIf you want to include an extension without this behavior you can call @Cedrus_safe which mimics @Cedrus except that it will never call \nPkg.add\n.\n\n\n\n\nsource\n\n\n#\n\n\nWeber.@DAQmx\n \n \nMacro\n.\n\n\nExtension Website\n\n\n@DAQmx(port;eeg_sample_rate,[codes])\n\n\n\n\nCreate a Weber extension that writes \nrecord\n events to a digital out line via the DAQmx API. This can be used to send trigger codes during eeg recording.\n\n\nArguments\n\n\n\n\nport: should be \nnothing\n, to disable the extension, or the port name for the digital output line.\n\n\neeg_sample_rate: should be set to the sampling rate for eeg recording. This calibrates the code length for triggers.\n\n\ncodes: a Dict that maps record event codes (a string) to a number. This should be an Integer less than 256. Any codes not specified here will be automatically set, based on the order in which codes are recieved.\n\n\n\n\nExample\n\n\nThe following experiment sends the code 0x01 to port0 on TestDevice.\n\n\nport = \n/TestDevice/port0/line0:7\n\nexperiment = Experiment(extensions=[\n  @DAQmx(port;eeg_sample_rate=512,codes=Dict(\ntest\n =\n 0x01))])\nsetup(experiment) do\n  addtrial(moment(record,\ntest\n))\nend\nrun(experiment)\n\n\n\n\n\n\nDo not call inside a package\n\n\nDo not call @DAQmx inside of a package or in tests. It should only be used in one-off scripts. If WeberDAQmx is not currently installed it will be installed by this macro using \nPkg.add\n which can lead to problems when called in packages or tests.\n\n\nIf you want to include an extension without this behavior you can call @DAQmx_safe which mimics @DAQmx except that it will never call \nPkg.add\n.\n\n\n\n\nsource\n\n\n\n\nCreating Extensions\n\n\nThe following functions are used when \nextending experiments\n.\n\n\nTo register your extension within Weber, so users can import your extension with ease, you use can use the \n@extension\n macro.\n\n\n#\n\n\nWeber.@extension\n \n \nMacro\n.\n\n\n@extension [Symbol] begin\n  [docstring...]\nend\n\n\n\n\nRegisters a given Weber extension. This creates a macro called \n@[Symbol]\n which imports \nWeber[Symbol]\n and calls \nWeber[Symbol].InitExtension\n, with the given arguments. InitExtension should return either \nnothing\n or an extension object.\n\n\nThe doc string is used to document the usage of the extension, and should normally include a link to the website of a julia package for the extension.\n\n\nsource\n\n\n\n\nFunctions operating over extensions\n\n\nThese functions operate directly on an \nExtendedExperiment\n.\n\n\n#\n\n\nBase.next\n \n \nMethod\n.\n\n\n next(experiment::ExtendedExperiment)\n\n\n\n\nGet the next extended version of this experiment.\n\n\nsource\n\n\n#\n\n\nDataStructures.top\n \n \nMethod\n.\n\n\ntop(experiment::Experiment)\n\n\n\n\nGet the the top-most extended verison for this experiment, if any.\n\n\nsource\n\n\n#\n\n\nWeber.extension\n \n \nMethod\n.\n\n\nextension(experiment::ExtendedExperiment)\n\n\n\n\nGet the extension object for this extended expeirment\n\n\nsource\n\n\n\n\nExtendable Private Functions\n\n\n#\n\n\nWeber.poll_events\n \n \nFunction\n.\n\n\n Weber.poll_events(callback,experiment,time)\n\n\n\n\nCall the function \ncallback\n, possibility multiple times, passing it an event object each time. The time at which the events are polled is passed, allowing this time to be stored with the event.\n\n\n\n\nWarning\n\n\nThis function should never be called directly by user code. A new method of this function can be implemented to extend Weber, allowing it to report new kinds events.\n\n\n\n\nsource\n\n\n\n\nPrivate Moment Functions\n\n\nNew \nWeber.SimpleMoment\n subtypes can define methods for the following functions to extend the runtime behavior of Weber.\n\n\n#\n\n\nWeber.prepare!\n \n \nFunction\n.\n\n\nWeber.prepare!(m,[last_moment])\n\n\n\n\nIf there is anything the moment needs to do before it occurs, it is done during \nprepare!\n. Prepare can be used to set up precise timing even when hardware latency is high, if that latency can be predicted, and accounted for. A moment's prepare! method is called just before the first non-zero pause between moments that occurs before this moment: in the simplest case, when this moment has a non-zero value for \ndelta_t\n, preapre! will occur \ndelta_t\n seconds before this moment. However, if several moments with no pause occur, prepare! will occur before all of those moments as well.\n\n\nPrepare accepts an optional second argument used to indicate the time, in seconds from the start of the experiemnt when this moment will begin. This argument may be Inf, indicating that it is not possible to predict when the moment will occur at this point, because the timing depends on some stateful information (e.g. a participant's response). It is accetable in this case to throw an error, explaining that this kind of moment must be able to know when it occurs sooner.\n\n\n\n\nNote\n\n\nThis method is part of the private interface for moments. It should not be called directly, but implemented as part of an extension. You need only extend the method taking a single arugment unless you intend to use this information during prepartion.\n\n\n\n\nsource\n\n\n#\n\n\nWeber.handle\n \n \nFunction\n.\n\n\nhandle(exp,queue,moment,to_handle)\n\n\n\n\nInternal method to handle the given moment object in a manner specific to its type.\n\n\nThe function \nhandle\n is only called when the appropriate time has been reached for the next moment to be presented (according to \ndelta_t\n) or when an event occurs.\n\n\nThe \nto_handle\n object is either a \nFloat64\n, indicating the current experiment time, or it is an \nExpEvent\n indicating the event that just occured. As an example, a timed moment, will run when it recieves any \nFloat64\n value, but nothing occurs when passed an event.\n\n\nThe queue is a \nMomentQueue\n object, which has the same interface as the \nDequeue\n object (from the \nDataStructures\n package) but it is also iterable. Upon calling handle, \ntop(queue) == moment\n.\n\n\nHandle should return a boolean indicating whether the event was \"handled\" or not. If unhandled, the moment should remain on top of the queue. If returning true, handle should \nnormally\n remove the top moment from the queue. Exceptions exist (for instance, to allow for loops), but one does not normally need to implement custom moments that have such behavior.\n\n\n\n\nNote\n\n\nThis method is part of the private interface for moments. It should not be called directly, but implemented as part of an extension. It is called during the course of running an experiment.\n\n\n\n\nsource\n\n\n#\n\n\nWeber.moment_trace\n \n \nFunction\n.\n\n\nmoment_trace(m)\n\n\n\n\nReturns the stacktrace indicating where this moment was defined.\n\n\n\n\nNote\n\n\nThis method is part of the private interface for moments. It should not be called directly, but implemented as part of an extension.  You can get a stacktrace inside the function you define that constructs your custom moment using \nstacktrace()[2:end]\n.\n\n\n\n\nsource\n\n\n#\n\n\nWeber.delta_t\n \n \nFunction\n.\n\n\ndelta_t(m::AbstractMoment)\n\n\n\n\nReturns the time, since the start of the previous moment, at which this moment should begin. The default implementation returns zero.\n\n\n\n\nNote\n\n\nThis method is part of the private interface for moments. It should not be called directly, but implemented as part of an extension.\n\n\n\n\nsource", 
            "title": "Extensions"
        }, 
        {
            "location": "/extend_ref/#available-extensions", 
            "text": "Extensions provide additional functionality for Weber. Currently there are two extensions availble:  #  Weber.@Cedrus     Macro .  Extension Website  @Cedrus()  Creates an extension for Weber allowing experiments to respond to events from Cedrus response-pad hardware. You can use  iskeydown  and  iskeyup  to check for events. To find the keycodes of the buttons for your response pad, run the following code, and press each of the buttons on the response pad.  run_keycode_helper(extensions=[@Cedrus()])   Do not call inside a package  Do not call @Cedrus inside of a package or in tests. It should only be used in one-off scripts. If WeberCedrus is not currently installed it will be installed by this macro using  Pkg.add  which can lead to problems when called in packages or tests.  If you want to include an extension without this behavior you can call @Cedrus_safe which mimics @Cedrus except that it will never call  Pkg.add .   source  #  Weber.@DAQmx     Macro .  Extension Website  @DAQmx(port;eeg_sample_rate,[codes])  Create a Weber extension that writes  record  events to a digital out line via the DAQmx API. This can be used to send trigger codes during eeg recording.  Arguments   port: should be  nothing , to disable the extension, or the port name for the digital output line.  eeg_sample_rate: should be set to the sampling rate for eeg recording. This calibrates the code length for triggers.  codes: a Dict that maps record event codes (a string) to a number. This should be an Integer less than 256. Any codes not specified here will be automatically set, based on the order in which codes are recieved.   Example  The following experiment sends the code 0x01 to port0 on TestDevice.  port =  /TestDevice/port0/line0:7 \nexperiment = Experiment(extensions=[\n  @DAQmx(port;eeg_sample_rate=512,codes=Dict( test  =  0x01))])\nsetup(experiment) do\n  addtrial(moment(record, test ))\nend\nrun(experiment)   Do not call inside a package  Do not call @DAQmx inside of a package or in tests. It should only be used in one-off scripts. If WeberDAQmx is not currently installed it will be installed by this macro using  Pkg.add  which can lead to problems when called in packages or tests.  If you want to include an extension without this behavior you can call @DAQmx_safe which mimics @DAQmx except that it will never call  Pkg.add .   source", 
            "title": "Available Extensions"
        }, 
        {
            "location": "/extend_ref/#creating-extensions", 
            "text": "The following functions are used when  extending experiments .  To register your extension within Weber, so users can import your extension with ease, you use can use the  @extension  macro.  #  Weber.@extension     Macro .  @extension [Symbol] begin\n  [docstring...]\nend  Registers a given Weber extension. This creates a macro called  @[Symbol]  which imports  Weber[Symbol]  and calls  Weber[Symbol].InitExtension , with the given arguments. InitExtension should return either  nothing  or an extension object.  The doc string is used to document the usage of the extension, and should normally include a link to the website of a julia package for the extension.  source", 
            "title": "Creating Extensions"
        }, 
        {
            "location": "/extend_ref/#functions-operating-over-extensions", 
            "text": "These functions operate directly on an  ExtendedExperiment .  #  Base.next     Method .   next(experiment::ExtendedExperiment)  Get the next extended version of this experiment.  source  #  DataStructures.top     Method .  top(experiment::Experiment)  Get the the top-most extended verison for this experiment, if any.  source  #  Weber.extension     Method .  extension(experiment::ExtendedExperiment)  Get the extension object for this extended expeirment  source", 
            "title": "Functions operating over extensions"
        }, 
        {
            "location": "/extend_ref/#extendable-private-functions", 
            "text": "#  Weber.poll_events     Function .   Weber.poll_events(callback,experiment,time)  Call the function  callback , possibility multiple times, passing it an event object each time. The time at which the events are polled is passed, allowing this time to be stored with the event.   Warning  This function should never be called directly by user code. A new method of this function can be implemented to extend Weber, allowing it to report new kinds events.   source", 
            "title": "Extendable Private Functions"
        }, 
        {
            "location": "/extend_ref/#private-moment-functions", 
            "text": "New  Weber.SimpleMoment  subtypes can define methods for the following functions to extend the runtime behavior of Weber.  #  Weber.prepare!     Function .  Weber.prepare!(m,[last_moment])  If there is anything the moment needs to do before it occurs, it is done during  prepare! . Prepare can be used to set up precise timing even when hardware latency is high, if that latency can be predicted, and accounted for. A moment's prepare! method is called just before the first non-zero pause between moments that occurs before this moment: in the simplest case, when this moment has a non-zero value for  delta_t , preapre! will occur  delta_t  seconds before this moment. However, if several moments with no pause occur, prepare! will occur before all of those moments as well.  Prepare accepts an optional second argument used to indicate the time, in seconds from the start of the experiemnt when this moment will begin. This argument may be Inf, indicating that it is not possible to predict when the moment will occur at this point, because the timing depends on some stateful information (e.g. a participant's response). It is accetable in this case to throw an error, explaining that this kind of moment must be able to know when it occurs sooner.   Note  This method is part of the private interface for moments. It should not be called directly, but implemented as part of an extension. You need only extend the method taking a single arugment unless you intend to use this information during prepartion.   source  #  Weber.handle     Function .  handle(exp,queue,moment,to_handle)  Internal method to handle the given moment object in a manner specific to its type.  The function  handle  is only called when the appropriate time has been reached for the next moment to be presented (according to  delta_t ) or when an event occurs.  The  to_handle  object is either a  Float64 , indicating the current experiment time, or it is an  ExpEvent  indicating the event that just occured. As an example, a timed moment, will run when it recieves any  Float64  value, but nothing occurs when passed an event.  The queue is a  MomentQueue  object, which has the same interface as the  Dequeue  object (from the  DataStructures  package) but it is also iterable. Upon calling handle,  top(queue) == moment .  Handle should return a boolean indicating whether the event was \"handled\" or not. If unhandled, the moment should remain on top of the queue. If returning true, handle should  normally  remove the top moment from the queue. Exceptions exist (for instance, to allow for loops), but one does not normally need to implement custom moments that have such behavior.   Note  This method is part of the private interface for moments. It should not be called directly, but implemented as part of an extension. It is called during the course of running an experiment.   source  #  Weber.moment_trace     Function .  moment_trace(m)  Returns the stacktrace indicating where this moment was defined.   Note  This method is part of the private interface for moments. It should not be called directly, but implemented as part of an extension.  You can get a stacktrace inside the function you define that constructs your custom moment using  stacktrace()[2:end] .   source  #  Weber.delta_t     Function .  delta_t(m::AbstractMoment)  Returns the time, since the start of the previous moment, at which this moment should begin. The default implementation returns zero.   Note  This method is part of the private interface for moments. It should not be called directly, but implemented as part of an extension.   source", 
            "title": "Private Moment Functions"
        }
    ]
}