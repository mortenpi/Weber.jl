{
    "docs": [
        {
            "location": "/", 
            "text": "About\n\n\nWeber is a \nJulia\n package that can be used to generate simple psychology experiments that present visual and auditory stimuli at precise times. Julia is a recent programming language designed specifically for technical computing.\n\n\nWeber has been built with the assumption that most of its users have only minimal programming experience. The hope is that such users should be able to get started quickly, making simple experiments today.\n\n\nWeber's emphasis is currently on auditory psychophysics, but the package has the features necessary to generate most visual stimuli one would desire as well, thanks to \nImages.jl\n. It is named after Ernst Weber. Weber runs on Windows and Mac OS X. Additional functionality can be added through \nextensions\n\n\n\n\nInstallation\n\n\nThe following instructions are designed for those new to Julia, and coding in general.\n\n\n\n\n1. Install Julia and Juno\n\n\nTo use Weber you will need to have Julia, and an appropriate code editor installed. \nFollow these instructions\n to install Julia and the Juno IDE. Juno is an extension for the code editor Atom (which these instructions will also ask you to download).\n\n\n\n\n2. Install Weber\n\n\nOnce Julia and Juno are installed, open Atom. Go to \"Open Console\" under the Julia menu.\n\n\n\n\nA console window will appear. Type \nPkg.add(\"Weber\")\n in the console and hit enter.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#about", 
            "text": "Weber is a  Julia  package that can be used to generate simple psychology experiments that present visual and auditory stimuli at precise times. Julia is a recent programming language designed specifically for technical computing.  Weber has been built with the assumption that most of its users have only minimal programming experience. The hope is that such users should be able to get started quickly, making simple experiments today.  Weber's emphasis is currently on auditory psychophysics, but the package has the features necessary to generate most visual stimuli one would desire as well, thanks to  Images.jl . It is named after Ernst Weber. Weber runs on Windows and Mac OS X. Additional functionality can be added through  extensions", 
            "title": "About"
        }, 
        {
            "location": "/#installation", 
            "text": "The following instructions are designed for those new to Julia, and coding in general.", 
            "title": "Installation"
        }, 
        {
            "location": "/#1-install-julia-and-juno", 
            "text": "To use Weber you will need to have Julia, and an appropriate code editor installed.  Follow these instructions  to install Julia and the Juno IDE. Juno is an extension for the code editor Atom (which these instructions will also ask you to download).", 
            "title": "1. Install Julia and Juno"
        }, 
        {
            "location": "/#2-install-weber", 
            "text": "Once Julia and Juno are installed, open Atom. Go to \"Open Console\" under the Julia menu.   A console window will appear. Type  Pkg.add(\"Weber\")  in the console and hit enter.", 
            "title": "2. Install Weber"
        }, 
        {
            "location": "/start/", 
            "text": "In the following example, we'll run through all the basics of how to create an experiment in Weber. It's assumed you have already followed the \ndirections for installing Julia and Juno\n. First, open Atom.\n\n\nYou may want to familiarize yourself with the basics of Julia. There are a number of useful \nresources\n available to learn Julia.\n\n\nNext, open the Julia console, and enter the following lines of code.\n\n\nusing Weber\ncreate_new_project(\nsimple\n)\n\n\n\n\nThis will create a set of files in your current directory to get you started creating your experiment. Open the file called run_simple.jl in Atom.\n\n\nRemove all text in run_simple.jl and replace it with the following.\n\n\nusing Weber\nsid,skip = @read_args(\nA simple frequency discrimination experiment.\n)\n\nlow = ramp(tone(1000,0.5))\nhigh = ramp(tone(1100,0.5))\n\nfunction one_trial()\n  if rand(Bool)\n    stim1 = moment(0.5,play,low)\n    stim2 = moment(0.5,play,high)\n    resp = response(key\nq\n =\n \nlow_first\n, key\np\n =\n \nlow_second\n,correct = \nlow_first\n)\n  else\n    stim1 = moment(0.5,play,high)\n    stim2 = moment(0.5,play,low)\n    resp = response(key\nq\n =\n \nlow_first\n, key\np\n =\n \nlow_second\n,correct = \nlow_second\n)   \n  end\n  return [show_cross(),stim1,stim2,resp,await_response(iskeydown)]\nend\n\nexp = Experiment(columns = [:sid =\n sid,condition =\n \nConditionA\n,:correct],skip=skip)\nsetup(exp) do\n  addbreak(instruct(\nPress 'q' when you hear the low tone first and 'p' otherwise.\n))\n  for trial in 1:10\n    addtrial(one_trial())\n  end\nend\n\nrun(exp)\n\n\n\n\nFinally, \nopen the julia console\n, and enter the following:\n\n\ninclude(\nrun_simple.jl\n)\n\n\n\n\n\n\nMake sure you're in the correct directory\n\n\nYou may get an error that looks like \"could not open file [file name here]\". This probably means Julia's working directory is not set correctly. Open run_simple.jl in Atom, make sure you are focused on this file (by clicking inside the file), and then, in the menu, click \"Julia\" \n \"Working Directory\" \n \"Current File's Folder\". This will set Julia's working directory to run_simple.jl's directory.\n\n\n\n\nAfter running the experiment on yourself, let's walk through the parts of this experiment piece-by-piece.\n\n\n\n\nRead Experiment Parameters\n\n\nusing Weber\nsid,skip = @read_args(\nA simple frequency discrimination experiment.\n)\n\n\n\n\nThe first line loads Weber. Then, when the script is run, the second line will read two important experimental parameters from the user: their subject ID, and an \noffset\n.\n\n\nDon't worry about the offset right now. (If you wish to learn more you can read about the \nWeber.offset\n function).\n\n\n\n\nStimulus Generation\n\n\nlow = ramp(tone(1000,0.5))\nhigh = ramp(tone(1100,0.5))\n\n\n\n\nThese next two lines create two stimuli. A 1000 Hz tone (\nlow\n) and a 1100 Hz tone (\nhigh\n) each 0.5 seconds long. The \nramp\n function tapers the start and end of a sound to avoid click sounds.\n\n\nYou can generate many simple stimuli in Weber, or you can use \nload(\"sound.wav\")\n to open a sound file on your computer. Refer to the documentation in \nSound\n.\n\n\n\n\nCreating a trial\n\n\nfunction one_trial()\n  if rand(Bool)\n    stim1 = moment(0.5,play,low)\n    stim2 = moment(0.5,play,high)\n    resp = response(key\nq\n =\n \nlow_first\n, key\np\n =\n \nlow_second\n,correct = \nlow_first\n)\n  else\n    stim1 = moment(0.5,play,high)\n    stim2 = moment(0.5,play,low)\n    resp = response(key\nq\n =\n \nlow_first\n, key\np\n =\n \nlow_second\n,correct = \nlow_second\n)   \n  end\n  return [show_cross(),stim1,stim2,resp,await_response(iskeydown)]\nend\n\n\n\n\nThese lines define a function that is used to create a single trial of the experiment. To create a trial, a random boolean value (true or false) is produced. When true, the low stimulus is presented first, when false, the high stimulus is presented first. There are two basic components of trial creation: trial moments and trial events.\n\n\n\n\nTrial Moments\n\n\nEach trial is composed of a sequence of \nmoments\n. Most moments just run a short function at some well defined point in time. For example, during the experiment, the moment \nmoment(0.5,play,low)\n will call the function \nplay\n on the \nlow\n stimulus, doing so 0.5 seconds after the onset of the previous moment. All moments running at a specified time do so in reference to the onset of the prior moment.\n\n\nThere are two other moments created in this function: \nshow_cross\n\u2013which simply displays a \"+\" symbol in the middle of the screen\u2013and \nawait_response\n\u2013which is a moment that begins only once a key is pressed, and then immediately ends.\n\n\nOnce all of the moments have been defined, they are returned in an array and will be run in sequence during the experiment.\n\n\nFor more details on how to create trial moments you can refer to the \nTrial Creation\n section of the user guide and the \nTrials\n section of the reference.\n\n\n\n\nTrial Events\n\n\nThe \nresponse\n function also creates a moment. It's purpose is to record the keyboard presses to q or p. It works a little differently than other moments. Rather than running once after a specified time, it runs anytime an event occurs.\n\n\nEvents indicate that something has changed: e.g. a key has been pressed, a key has been released, the experiment has been paused. Keyboard events signal a particular code, referring to the key the experiment participant pressed. In the code above \nkey\"p\"\n and \nkey\"q\"\n are used to indicate the 'q' and 'p' keys on the keyboard. For details on how events work you can refer to the reference section on \nEvents\n. The \nresponse\n moment listens for events with the 'p' or 'q' key codes, and records those events.\n\n\n\n\nExperiment Definition\n\n\nexp = Experiment(columns = [:sid =\n sid,condition =\n \nConditionA\n,:correct],skip=skip) \n\n\n\n\nThis line creates the actual experiment. It creates a datafile with an appropriate name, and opens a window for the experiment to be displayed in.\n\n\nThe code \ncolumns\n creates a number of columns. Some of these columns have fixed values, that are the same for each row of the data (e.g. \n:sid =\n sid\n) but one of them, \n:correct\n, is different on each line. Note that in the call to \nresponse\n in \none_trial\n, the value of correct is set to the response listeners should have pressed during a trial.\n\n\nYou can add as many columns as you want, either when you first create an experiment, as above, or using \naddcolumn\n. Trying to record values to a column you haven't added results in an error.\n\n\n\n\nExperiment Setup\n\n\nsetup(exp) do\n  addbreak(instruct(\nPress 'q' when you hear the low tone first and 'p' otherwise.\n))\n  for trial in 1:10\n    addtrial(one_trial())\n  end\nend\n\n\n\n\nOnce the experiment is defined, you can setup any trials and instructions that you want the experiment to have. The above code adds a break providing instructions for the listeners, and 10 trials, created using the \none_trial\n function we defined above. Please refer to the \nTrial Creation\n section of the user guide for more details on how to add trials.\n\n\n\n\nSetup- vs. run-time\n\n\nrun(exp)\n\n\n\n\nThis final part of the code actually runs the experiment. Note that none of the code in setup actually runs during the experiment. This is \nimportant\n! Weber is designed to run as much code as possible before the experiment starts, during setup. This is called setup-time. This ensures that code which does run during the experiment, during run-time, can do so in a timely manner. The only code that actually runs during the experiment is the behavior defined within each moment.\n\n\n\n\nWhere to go from here\n\n\nFrom here you can begin writing your own simple experiments. Take a look at some of the example experiments under Weber's example directory to see what you can do. You can find the location of this directory by typing \nPkg.dir(\"Weber\",\"examples\")\n in the julia console. To further your understanding of the details of Weber, you can also read through the rest of the user guide. Topics in the guide have been organized from simplest, and most useful, to the more advanced, least-frequently-necessary features.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/start/#read-experiment-parameters", 
            "text": "using Weber\nsid,skip = @read_args( A simple frequency discrimination experiment. )  The first line loads Weber. Then, when the script is run, the second line will read two important experimental parameters from the user: their subject ID, and an  offset .  Don't worry about the offset right now. (If you wish to learn more you can read about the  Weber.offset  function).", 
            "title": "Read Experiment Parameters"
        }, 
        {
            "location": "/start/#stimulus-generation", 
            "text": "low = ramp(tone(1000,0.5))\nhigh = ramp(tone(1100,0.5))  These next two lines create two stimuli. A 1000 Hz tone ( low ) and a 1100 Hz tone ( high ) each 0.5 seconds long. The  ramp  function tapers the start and end of a sound to avoid click sounds.  You can generate many simple stimuli in Weber, or you can use  load(\"sound.wav\")  to open a sound file on your computer. Refer to the documentation in  Sound .", 
            "title": "Stimulus Generation"
        }, 
        {
            "location": "/start/#creating-a-trial", 
            "text": "function one_trial()\n  if rand(Bool)\n    stim1 = moment(0.5,play,low)\n    stim2 = moment(0.5,play,high)\n    resp = response(key q  =   low_first , key p  =   low_second ,correct =  low_first )\n  else\n    stim1 = moment(0.5,play,high)\n    stim2 = moment(0.5,play,low)\n    resp = response(key q  =   low_first , key p  =   low_second ,correct =  low_second )   \n  end\n  return [show_cross(),stim1,stim2,resp,await_response(iskeydown)]\nend  These lines define a function that is used to create a single trial of the experiment. To create a trial, a random boolean value (true or false) is produced. When true, the low stimulus is presented first, when false, the high stimulus is presented first. There are two basic components of trial creation: trial moments and trial events.", 
            "title": "Creating a trial"
        }, 
        {
            "location": "/start/#trial-moments", 
            "text": "Each trial is composed of a sequence of  moments . Most moments just run a short function at some well defined point in time. For example, during the experiment, the moment  moment(0.5,play,low)  will call the function  play  on the  low  stimulus, doing so 0.5 seconds after the onset of the previous moment. All moments running at a specified time do so in reference to the onset of the prior moment.  There are two other moments created in this function:  show_cross \u2013which simply displays a \"+\" symbol in the middle of the screen\u2013and  await_response \u2013which is a moment that begins only once a key is pressed, and then immediately ends.  Once all of the moments have been defined, they are returned in an array and will be run in sequence during the experiment.  For more details on how to create trial moments you can refer to the  Trial Creation  section of the user guide and the  Trials  section of the reference.", 
            "title": "Trial Moments"
        }, 
        {
            "location": "/start/#trial-events", 
            "text": "The  response  function also creates a moment. It's purpose is to record the keyboard presses to q or p. It works a little differently than other moments. Rather than running once after a specified time, it runs anytime an event occurs.  Events indicate that something has changed: e.g. a key has been pressed, a key has been released, the experiment has been paused. Keyboard events signal a particular code, referring to the key the experiment participant pressed. In the code above  key\"p\"  and  key\"q\"  are used to indicate the 'q' and 'p' keys on the keyboard. For details on how events work you can refer to the reference section on  Events . The  response  moment listens for events with the 'p' or 'q' key codes, and records those events.", 
            "title": "Trial Events"
        }, 
        {
            "location": "/start/#experiment-definition", 
            "text": "exp = Experiment(columns = [:sid =  sid,condition =   ConditionA ,:correct],skip=skip)   This line creates the actual experiment. It creates a datafile with an appropriate name, and opens a window for the experiment to be displayed in.  The code  columns  creates a number of columns. Some of these columns have fixed values, that are the same for each row of the data (e.g.  :sid =  sid ) but one of them,  :correct , is different on each line. Note that in the call to  response  in  one_trial , the value of correct is set to the response listeners should have pressed during a trial.  You can add as many columns as you want, either when you first create an experiment, as above, or using  addcolumn . Trying to record values to a column you haven't added results in an error.", 
            "title": "Experiment Definition"
        }, 
        {
            "location": "/start/#experiment-setup", 
            "text": "setup(exp) do\n  addbreak(instruct( Press 'q' when you hear the low tone first and 'p' otherwise. ))\n  for trial in 1:10\n    addtrial(one_trial())\n  end\nend  Once the experiment is defined, you can setup any trials and instructions that you want the experiment to have. The above code adds a break providing instructions for the listeners, and 10 trials, created using the  one_trial  function we defined above. Please refer to the  Trial Creation  section of the user guide for more details on how to add trials.", 
            "title": "Experiment Setup"
        }, 
        {
            "location": "/start/#setup-vs-run-time", 
            "text": "run(exp)  This final part of the code actually runs the experiment. Note that none of the code in setup actually runs during the experiment. This is  important ! Weber is designed to run as much code as possible before the experiment starts, during setup. This is called setup-time. This ensures that code which does run during the experiment, during run-time, can do so in a timely manner. The only code that actually runs during the experiment is the behavior defined within each moment.", 
            "title": "Setup- vs. run-time"
        }, 
        {
            "location": "/start/#where-to-go-from-here", 
            "text": "From here you can begin writing your own simple experiments. Take a look at some of the example experiments under Weber's example directory to see what you can do. You can find the location of this directory by typing  Pkg.dir(\"Weber\",\"examples\")  in the julia console. To further your understanding of the details of Weber, you can also read through the rest of the user guide. Topics in the guide have been organized from simplest, and most useful, to the more advanced, least-frequently-necessary features.", 
            "title": "Where to go from here"
        }, 
        {
            "location": "/trial_guide/", 
            "text": "We'll look in detail at how to create trials of an experiment. For a broad overview of trial creation refer to \nGetting Started\n. The two basic steps to creating a trial are (1) defining a set of moments and (2) add moments to a trial. \n\n\n\n\nDefining Moments\n\n\nTrials are composed of moments. There are several types of moments: timed moments, compound moments, watcher moments, and conditional moments.\n\n\n\n\nTimed Moments\n\n\nTimed moments are the simplest kind of moment. They are are normally created by calling \nmoment\n.\n\n\nmoment([delta_t],[fn],args...;keys...)\n\n\n\n\nA timed moment waits \ndelta_t\n seconds after the onset of the previous moment, and then runs the specified function (\nfn\n), if any, passing it any \nargs\n and \nkeys\n provided. Below is an example of creating a timed moment.\n\n\nmoment(0.5,play,mysound)\n\n\n\n\nThis moment plays \nmysound\n 0.5 seconds after the onset of the previous moment.\n\n\nThere are several other kinds of timed moments, other than those created by calling \nmoment\n. Specifically, \ntimeout\n and \nawait_response\n wait for a particular event to occur (such as a key press) before they begin.\n\n\n\n\nGuidlines for low-latency moments\n\n\nWeber aims to present moments at low latencies for accurate experiments.\n\n\nTo maintain low latency, as much of the experimental logic as possible should be precomputed, outside of trial moments, during \nsetup-time\n. The following operations are definitely safe to perform during a moment:\n\n\n\n\nCalls to \nplay\n to present a sound\n\n\nCalls to \ndisplay\n to present a visual.\n\n\nCalls to \nrecord\n to save something to a data file (usually after any calls to \nplay\n or \ndisplay\n)\n\n\n\n\nNote that Julia compiles functions on demand (known as just-in-time or JIT compilation), which can lead to very slow runtimes the first time a function runs.  To minimize JIT compilation during an experiment, any functions called directly by a moment are first precompiled.\n\n\n\n\nKeep Moments Short\n\n\nLong running moments will lead to latency issues. Make sure all functions that run in a moment terminate relatively quickly.\n\n\n\n\n\n\nSync visuals to the refresh rate.\n\n\nVisuals synchronize to the screen refresh rate. You can  find more details about this in the documentation of \ndisplay\n\n\n\n\n\n\nCompound Moments\n\n\nYou can create more complicated moments by concatenating simpler moments together using the \n operator or \nmoment(momoment1,moment2,...)\n.\n\n\nA concatenation of moments starts immediately, proceeding through each of the moments in order. This allows for a more complex relationship in inter-moment timing. For example, the following code will present two sounds, one at 100ms, the other at 200ms after the start of the trial. It will also display \"Too Late!\" on the screen if no keyboard key is pressed 150ms after the start of the trial. \n\n\naddtrial(moment(0.1,play,soundA) \n moment(0.1,play,soundB),\n         timeout(() -\n display(\nToo Late!\n),iskeydown,0.15))\n\n\n\n\nThis exact sequence of timing would not be possible withou using the \n operator because the timing of \ntimeout\n moment depends on user input, while we desire that soundB be played at a reliable time.\n\n\n\n\nWatcher Moments\n\n\nWatcher moments are used to respond to events. Often, watcher moments need not be directly used. Instead, the higher level \nresponse\n method can be used.\n\n\nAs long as a watcher moment is active it occurs any time an event is triggered. A watcher moment becomes active at the start of the preceding moment, or at the start of a trial (if it's the first moment in a trial). This latter form is most common, since generally one wishes to listen to all events during a trial. A watcher moments is simply a function that takes one argument: the event to be processed.\n\n\nIf the watcher is the first moment in a trial, the convenient \ndo\n block syntax is possible.\n\n\nmessage = visual(\nYou hit spacebar!\n)\naddtrial(moment2,moment3) do event\n  if iskeydown(key\n:space:\n)\n    display(message,duration=0.500)\n    record()\n  end\nend\n\n\n\n\nIn the above example, \"You hit spacebar!\" is displayed for 500ms every time the spacebar is hit.\n\n\nRefer to the documentation for \nEvents\n for full details on how to respond to events.\n\n\n\n\nConditional Moments\n\n\nConditional moments are a more advanced technique for creating moments and aren't normally necessary. They run a function only when a certain condition is true (the \nwhen\n moment) or repeat a function until a condition is false (the \nlooping\n moment). They require a good understanding of the difference between \nsetup- and run-time\n, \nanonymous functions\n, and \nscoping rules\n in julia.\n\n\n\n\nAdding Trials\n\n\nNormally, to add moments to a trial you simply call \naddtrial\n. There is also \naddpractice\n, and \naddbreak\n. These functions are nearly identical to \naddtrial\n but differ in how they update the trial and offset counters, and what they automatically \nrecord\n to a data file.\n\n\nAll of these functions take a series of iterable objects of moments. The moments of all arguments are added in sequence. For convience these iterables can be nested, allowing functions that return multiple moments themselves to be easily passed to \naddtrial\n.", 
            "title": "Trial Creation"
        }, 
        {
            "location": "/trial_guide/#defining-moments", 
            "text": "Trials are composed of moments. There are several types of moments: timed moments, compound moments, watcher moments, and conditional moments.", 
            "title": "Defining Moments"
        }, 
        {
            "location": "/trial_guide/#timed-moments", 
            "text": "Timed moments are the simplest kind of moment. They are are normally created by calling  moment .  moment([delta_t],[fn],args...;keys...)  A timed moment waits  delta_t  seconds after the onset of the previous moment, and then runs the specified function ( fn ), if any, passing it any  args  and  keys  provided. Below is an example of creating a timed moment.  moment(0.5,play,mysound)  This moment plays  mysound  0.5 seconds after the onset of the previous moment.  There are several other kinds of timed moments, other than those created by calling  moment . Specifically,  timeout  and  await_response  wait for a particular event to occur (such as a key press) before they begin.", 
            "title": "Timed Moments"
        }, 
        {
            "location": "/trial_guide/#guidlines-for-low-latency-moments", 
            "text": "Weber aims to present moments at low latencies for accurate experiments.  To maintain low latency, as much of the experimental logic as possible should be precomputed, outside of trial moments, during  setup-time . The following operations are definitely safe to perform during a moment:   Calls to  play  to present a sound  Calls to  display  to present a visual.  Calls to  record  to save something to a data file (usually after any calls to  play  or  display )   Note that Julia compiles functions on demand (known as just-in-time or JIT compilation), which can lead to very slow runtimes the first time a function runs.  To minimize JIT compilation during an experiment, any functions called directly by a moment are first precompiled.   Keep Moments Short  Long running moments will lead to latency issues. Make sure all functions that run in a moment terminate relatively quickly.    Sync visuals to the refresh rate.  Visuals synchronize to the screen refresh rate. You can  find more details about this in the documentation of  display", 
            "title": "Guidlines for low-latency moments"
        }, 
        {
            "location": "/trial_guide/#compound-moments", 
            "text": "You can create more complicated moments by concatenating simpler moments together using the   operator or  moment(momoment1,moment2,...) .  A concatenation of moments starts immediately, proceeding through each of the moments in order. This allows for a more complex relationship in inter-moment timing. For example, the following code will present two sounds, one at 100ms, the other at 200ms after the start of the trial. It will also display \"Too Late!\" on the screen if no keyboard key is pressed 150ms after the start of the trial.   addtrial(moment(0.1,play,soundA)   moment(0.1,play,soundB),\n         timeout(() -  display( Too Late! ),iskeydown,0.15))  This exact sequence of timing would not be possible withou using the   operator because the timing of  timeout  moment depends on user input, while we desire that soundB be played at a reliable time.", 
            "title": "Compound Moments"
        }, 
        {
            "location": "/trial_guide/#watcher-moments", 
            "text": "Watcher moments are used to respond to events. Often, watcher moments need not be directly used. Instead, the higher level  response  method can be used.  As long as a watcher moment is active it occurs any time an event is triggered. A watcher moment becomes active at the start of the preceding moment, or at the start of a trial (if it's the first moment in a trial). This latter form is most common, since generally one wishes to listen to all events during a trial. A watcher moments is simply a function that takes one argument: the event to be processed.  If the watcher is the first moment in a trial, the convenient  do  block syntax is possible.  message = visual( You hit spacebar! )\naddtrial(moment2,moment3) do event\n  if iskeydown(key :space: )\n    display(message,duration=0.500)\n    record()\n  end\nend  In the above example, \"You hit spacebar!\" is displayed for 500ms every time the spacebar is hit.  Refer to the documentation for  Events  for full details on how to respond to events.", 
            "title": "Watcher Moments"
        }, 
        {
            "location": "/trial_guide/#conditional-moments", 
            "text": "Conditional moments are a more advanced technique for creating moments and aren't normally necessary. They run a function only when a certain condition is true (the  when  moment) or repeat a function until a condition is false (the  looping  moment). They require a good understanding of the difference between  setup- and run-time ,  anonymous functions , and  scoping rules  in julia.", 
            "title": "Conditional Moments"
        }, 
        {
            "location": "/trial_guide/#adding-trials", 
            "text": "Normally, to add moments to a trial you simply call  addtrial . There is also  addpractice , and  addbreak . These functions are nearly identical to  addtrial  but differ in how they update the trial and offset counters, and what they automatically  record  to a data file.  All of these functions take a series of iterable objects of moments. The moments of all arguments are added in sequence. For convience these iterables can be nested, allowing functions that return multiple moments themselves to be easily passed to  addtrial .", 
            "title": "Adding Trials"
        }, 
        {
            "location": "/adaptive/", 
            "text": "Some experiments require the use of an adaptive adjustment of a stimulus based on participant responses. There are several basic adaptive tracking algorithms built into Weber, and you can also implement your own as well.\n\n\n\n\nUsing an Adaptive Track\n\n\nTo use an adaptive track in your experiment, you need to make use of some of the \nadvanced features\n of Weber. In this section we'll walk through the necessary steps, using a simple frequency discrimination experiment.\n\n\nIn this experiment, on each trial, listeners hear a low and a high tone, separated in frequency by an adaptively adjusted delta. Their task is to indicate which tone is lower, and the delta is adjusted to determine the difference in frequency at which listeners respond with 79% accuracy. The entire example code is provided below. \n\n\nusing Weber\nsid,trial_skip,adapt = @read_args(\nFrequency Discrimination ($version).\n,\n                                  adapt=[:levitt,:bayes])\n\nn_trials = 60\nisresponse(e) = iskeydown(e,key\np\n) || iskeydown(e,key\nq\n)\n\nexp = Experiment(sid = sid,condition = \nexample\n,version = version,\n                 skip=trial_skip,standard=1000)\n\nif adapt == :levitt\n  adapter = levitt_adapter(down=3,up=1,min_delta=0,max_delta=1,\n                           big=2,little=sqrt(2),mult=true)\nelse\n  adapter = bayesian_adapter(min_delta = 0,max_delta = 0.95)\nend\n\nstandard = attenuate(ramp(tone(1000,0.1)),atten_dB)\nfunction one_trial(adapter)\n  first_lower = rand(Bool)\n  resp = response(adapter,key\nq\n =\n \nfirst_lower\n,key\np\n =\n \nsecond_lower\n,\n                  correct=(first_lower ? \nfirst_lower\n : \nsecond_lower\n))\n\n  signal() = attenuate(ramp(tone(1000*(1-delta(adapter)),0.1)),atten_dB)\n  stimuli = first_lower? [signal,standard] : [standard,signal]\n\n  [show_cross(),\n   moment(play,stimuli[1]),moment(0.9,play,stimuli[2]),\n   moment(0.1 + 0.3,display,\n          \nWas the first [Q] or second sound [P] lower in pitch?\n),\n   resp,await_response(isresponse),moment(0.75)]\nend\n\nsetup(exp) do\n  addbreak(moment(record,\nstart\n))\n\n  addbreak(instruct(\n\n\n    On each trial, you will hear two beeps. Indicate which of the two beeps you\nheard was lower in pitch. Hit 'Q' if the first beep was lower, and 'P' if the\nsecond beep was lower.\n\n))\n\n  @addtrials let a = adapter\n    for trial in 1:n_trials\n      addtrial(one_trial(a))\n    end\n    addbreak(moment(display,() -\n \nEstimated threshold: $(estimate(adapter)[1])\\n\n,\n                                  \nHit spacebar to exit.\n),\n             await_response(iskeydown(key\n:space:\n)))\n  end\nend\n\nplay(attenuate(ramp(tone(1000,1)),atten_dB))\nrun(exp)\n\n\n\n\nIn what follows we'll walk through the parts of this code unique to creating an adaptive track. For more details on the basics of creating an experiment see \nGetting Started\n.\n\n\n\n\nCreating the Adapter\n\n\nif adapt == :levitt\n  adapter = levitt_adapter(down=3,up=1,min_delta=0,max_delta=1,\n                           big=2,little=sqrt(2),mult=true)\nelse\n  adapter = bayesian_adapter(min_delta = 0,max_delta = 0.95)\nend\n\n\n\n\nThe present experiment can be run using either of two built-in adapters: \nlevitt_adapter\n and \nbayesian_adapter\n. An adapter is the object you create to run an adaptive track, and defines the particular algorithm that will be used to select a new delta on each trial, based on the responses to previous deltas. \n\n\n\n\nGenerating Stimuli\n\n\nstandard = attenuate(ramp(tone(1000,0.1)),atten_dB)\n...\nsignal() = attenuate(ramp(tone(1000*(1-delta(adapter)),0.1)),atten_dB)\nstimuli = first_lower? [signal,standard] : [standard,signal]\n\n\n\n\nThe two stimuli presented to the listener are the standard (always at 1kHz) and the signal (1kHz - delta). The standard is always the same, and so can be generated in advance before the experiment begins. The signal must be generated during the experiment, on each trial. The next delta is queried from the adapter using \ndelta\n. The signal is defined as a function that takes no arguments. When passed a function, \nplay\n generates the stimulus defined by that function at runtime, rather than \nsetup time\n, which is precisely what we want in this case.\n\n\n\n\nCollecting Responses\n\n\nresp = response(adapter,key\nq\n =\n \nfirst_lower\n,key\np\n =\n \nsecond_lower\n,\n                  correct=(first_lower ? \nfirst_lower\n : \nsecond_lower\n))\n\n\n\n\nTo update the adapter after each response, a special method of the \nresponse\n function is used, which takes the adapter as its first argument. We also must indicate which response is correct by setting \ncorrect\n appropriately.\n\n\n\n\nGenerating Trials\n\n\n@addtrials let a = adapter\n  for trial in 1:n_trials\n    addtrial(one_trial(a))\n  end\n  addbreak(moment(display,() -\n \nEstimated threshold: $(estimate(adapter)[1])\\n\n,\n                                \nHit spacebar to exit.\n),\n           await_response(iskeydown(key\n:space:\n)))\nend\n\n\n\n\nTo generate the trials, which depend on the run-time state of the adapter, we use the \n@addtrials\n macro. Any time the behavior of listeners in one trial influences subsequent trials, this macro will be necessary. In this case it is used to signal to Weber that the trials added inside the loop depend on the run-time state of the adapter.\n\n\nAfter all trials have been run, we report the threshold estimated by the adapter using the \nestimate\n function, which returns both the mean and measurement error.\n\n\n\n\nCustom Adaptive Track Algorithms\n\n\nYou can define your own adaptive tracking algorithms by defining a new type that is a child of \nAdapter\n. You must define an appropriate function to generate the adapter, and methods of \nWeber.update!\n, \nestimate\n and \ndelta\n for this type. Strictly speaking estimate need not be implemented, if you choose not to make use of this method in your experiment.", 
            "title": "Adaptive Tracks"
        }, 
        {
            "location": "/adaptive/#using-an-adaptive-track", 
            "text": "To use an adaptive track in your experiment, you need to make use of some of the  advanced features  of Weber. In this section we'll walk through the necessary steps, using a simple frequency discrimination experiment.  In this experiment, on each trial, listeners hear a low and a high tone, separated in frequency by an adaptively adjusted delta. Their task is to indicate which tone is lower, and the delta is adjusted to determine the difference in frequency at which listeners respond with 79% accuracy. The entire example code is provided below.   using Weber\nsid,trial_skip,adapt = @read_args( Frequency Discrimination ($version). ,\n                                  adapt=[:levitt,:bayes])\n\nn_trials = 60\nisresponse(e) = iskeydown(e,key p ) || iskeydown(e,key q )\n\nexp = Experiment(sid = sid,condition =  example ,version = version,\n                 skip=trial_skip,standard=1000)\n\nif adapt == :levitt\n  adapter = levitt_adapter(down=3,up=1,min_delta=0,max_delta=1,\n                           big=2,little=sqrt(2),mult=true)\nelse\n  adapter = bayesian_adapter(min_delta = 0,max_delta = 0.95)\nend\n\nstandard = attenuate(ramp(tone(1000,0.1)),atten_dB)\nfunction one_trial(adapter)\n  first_lower = rand(Bool)\n  resp = response(adapter,key q  =   first_lower ,key p  =   second_lower ,\n                  correct=(first_lower ?  first_lower  :  second_lower ))\n\n  signal() = attenuate(ramp(tone(1000*(1-delta(adapter)),0.1)),atten_dB)\n  stimuli = first_lower? [signal,standard] : [standard,signal]\n\n  [show_cross(),\n   moment(play,stimuli[1]),moment(0.9,play,stimuli[2]),\n   moment(0.1 + 0.3,display,\n           Was the first [Q] or second sound [P] lower in pitch? ),\n   resp,await_response(isresponse),moment(0.75)]\nend\n\nsetup(exp) do\n  addbreak(moment(record, start ))\n\n  addbreak(instruct( \n\n    On each trial, you will hear two beeps. Indicate which of the two beeps you\nheard was lower in pitch. Hit 'Q' if the first beep was lower, and 'P' if the\nsecond beep was lower. ))\n\n  @addtrials let a = adapter\n    for trial in 1:n_trials\n      addtrial(one_trial(a))\n    end\n    addbreak(moment(display,() -   Estimated threshold: $(estimate(adapter)[1])\\n ,\n                                   Hit spacebar to exit. ),\n             await_response(iskeydown(key :space: )))\n  end\nend\n\nplay(attenuate(ramp(tone(1000,1)),atten_dB))\nrun(exp)  In what follows we'll walk through the parts of this code unique to creating an adaptive track. For more details on the basics of creating an experiment see  Getting Started .", 
            "title": "Using an Adaptive Track"
        }, 
        {
            "location": "/adaptive/#creating-the-adapter", 
            "text": "if adapt == :levitt\n  adapter = levitt_adapter(down=3,up=1,min_delta=0,max_delta=1,\n                           big=2,little=sqrt(2),mult=true)\nelse\n  adapter = bayesian_adapter(min_delta = 0,max_delta = 0.95)\nend  The present experiment can be run using either of two built-in adapters:  levitt_adapter  and  bayesian_adapter . An adapter is the object you create to run an adaptive track, and defines the particular algorithm that will be used to select a new delta on each trial, based on the responses to previous deltas.", 
            "title": "Creating the Adapter"
        }, 
        {
            "location": "/adaptive/#generating-stimuli", 
            "text": "standard = attenuate(ramp(tone(1000,0.1)),atten_dB)\n...\nsignal() = attenuate(ramp(tone(1000*(1-delta(adapter)),0.1)),atten_dB)\nstimuli = first_lower? [signal,standard] : [standard,signal]  The two stimuli presented to the listener are the standard (always at 1kHz) and the signal (1kHz - delta). The standard is always the same, and so can be generated in advance before the experiment begins. The signal must be generated during the experiment, on each trial. The next delta is queried from the adapter using  delta . The signal is defined as a function that takes no arguments. When passed a function,  play  generates the stimulus defined by that function at runtime, rather than  setup time , which is precisely what we want in this case.", 
            "title": "Generating Stimuli"
        }, 
        {
            "location": "/adaptive/#collecting-responses", 
            "text": "resp = response(adapter,key q  =   first_lower ,key p  =   second_lower ,\n                  correct=(first_lower ?  first_lower  :  second_lower ))  To update the adapter after each response, a special method of the  response  function is used, which takes the adapter as its first argument. We also must indicate which response is correct by setting  correct  appropriately.", 
            "title": "Collecting Responses"
        }, 
        {
            "location": "/adaptive/#generating-trials", 
            "text": "@addtrials let a = adapter\n  for trial in 1:n_trials\n    addtrial(one_trial(a))\n  end\n  addbreak(moment(display,() -   Estimated threshold: $(estimate(adapter)[1])\\n ,\n                                 Hit spacebar to exit. ),\n           await_response(iskeydown(key :space: )))\nend  To generate the trials, which depend on the run-time state of the adapter, we use the  @addtrials  macro. Any time the behavior of listeners in one trial influences subsequent trials, this macro will be necessary. In this case it is used to signal to Weber that the trials added inside the loop depend on the run-time state of the adapter.  After all trials have been run, we report the threshold estimated by the adapter using the  estimate  function, which returns both the mean and measurement error.", 
            "title": "Generating Trials"
        }, 
        {
            "location": "/adaptive/#custom-adaptive-track-algorithms", 
            "text": "You can define your own adaptive tracking algorithms by defining a new type that is a child of  Adapter . You must define an appropriate function to generate the adapter, and methods of  Weber.update! ,  estimate  and  delta  for this type. Strictly speaking estimate need not be implemented, if you choose not to make use of this method in your experiment.", 
            "title": "Custom Adaptive Track Algorithms"
        }, 
        {
            "location": "/advanced/", 
            "text": "There are several concepts and techniques best avoided unless they are really necessary. These generally complicate the creation of experiments. \n\n\n\n\nStateful Trials\n\n\nSome experiments require that what trials present depend on responses to previous trials. For instance, adaptive tracking to find a discrimination threshold.\n\n\nIf your trials depend on experiment-changing state, you need to use the macro \n@addtrials\n.\n\n\nThere are three kinds of trials you can add with this macro: blocks, conditionals and loops.\n\n\n\n\nBlocks of Trials\n\n\n@addtrials let [assignments]\n  body...\nend\n\n\n\n\nBlocks of trials are useful for setting up state that will change during the trials. Such state can then be used in a subsequent @addtrials expression. In fact all other types of @addtrials expression will likely be nested inside blocks. The main reason to use such a block is to ensure that  \nWeber.offset\n is well defined.\n\n\nThe offset counter is used to fast-forward through the expeirment by specifying an offset greater than 0.  However, if there is state that changes throughout the course of several trials, those trials cannot reliably be reproduced when only some of them are skipped. Either all or none of the trials that depend on one another should be skipped.\n\n\nAnytime you have a series of trials, some of which depend on what happens earlier in an expeirment, such trials should be placed inside of an @addtrials let block. Otherwise experiment fast forwarding will result in unexpected behaviors.\n\n\n\n\nConditional Trials\n\n\n@addtrials if [cond1]\n  body...\nelseif [cond2]\n  body...\n...\nelseif [condN]\n  body...\nelse\n  body...\nend\n\n\n\n\nAdds one or mores trials that are presented only if the given conditions are met. The expressions \ncond1\n through \ncondN\n are evaluted during the experiment, but each \nbody\n is executed before the experiment begins, and is used to indicate the set of trials (and breaks or practice trials) that will be run for a given condition.\n\n\nFor example, the following code only runs the second trial if the user hits the \"y\" key.\n\n\n@addtrials let y_hit = false\n  isresponse(e) = iskeydown(e,key\ny\n) || iskeydown(e,key\nn\n)\n  addtrial(moment(display,\nHit Y or N.\n),await_response(isresponse)) do event\n    if iskeydown(event,key\ny\n)\n      y_hit = true\n    end\n  end\n\n  @addtrials if !y_hit\n    addtrial(moment(display,\nYou did not hit Y!\n),await_response(iskeydown))\n  end\nend\n\n\n\n\nIf \n@addtrials if !y_hit\n was replaced with \nif !y_hit\n in the above example, the second trial would always run. This is because the \nif\n expression would be run during setup-time, before any trials were run (when \ny_hit\n is false).\n\n\n\n\nLooping Trials\n\n\n@addtrials while expr\n  body...\nend\n\n\n\n\nAdd some number of trials that repeat as long as \nexpr\n evalutes to true. For example the follow code runs as long as the user hits the \"y\" key.\n\n\n@addtrials let y_hit = true\n  @addtrials while y_hit\n    message = moment(display,\nHit Y if you want to continue\n)\n    addtrial(message,await_response(iskeydown)) do event\n      y_hit = iskeydown(event,key\ny\n)\n    end\n  end\nend\n\n\n\n\nIf \n@addtrials while y_hit\n was replaced with \nwhile y_hit\n in the above example, the while loop would never terminate, running an infinite loop, because \ny_hit\n is true before the experiment starts.\n\n\n\n\nRun-time stimulus generation.\n\n\nWhen stimuli need to be generated during an experiment the normal approach will not work. For instance, if you want a tone's frequency to depend on some delta value that changes during the experimrent the following will not work.\n\n\n# THIS WILL NOT WORK!!!\nmoment(play,tone(1000+my_delta))\n\n\n\n\nThe basic problem here is that tone is used to generate a sound at \nsetup-time\n. What we want is for the run-time value of \nmy_delta\n to be used. To do this you can pass a function to play. This function will be used to generate a sound during runtime.\n\n\nmoment(play,() -\n tone(1000+my_delta,1))\n\n\n\n\nSimilarly, we can use a runtime value in display by passing a function to display.\n\n\nmoment(display,() -\n \nhello $my_name.\n)\n\n\n\n\nWhen moments are created this way, the sound or visual is generated before the moment even begins, to eliminate any latency that would be introduced by loading the sound or visual into memory. Specifically, the stimulus is generated during the most recent non-zero pause occuring before a moment. So for instance, in the following example, \nmysound\n will be generated ~0.5 seconds before play is called right after \"Get ready!\" is displayed.\n\n\naddtrial(moment(display,\nGet ready!\n),moment(0.5),\n         moment(display,\nHere we go!\n),moment(play,mysound))", 
            "title": "Advanced Experiments"
        }, 
        {
            "location": "/advanced/#stateful-trials", 
            "text": "Some experiments require that what trials present depend on responses to previous trials. For instance, adaptive tracking to find a discrimination threshold.  If your trials depend on experiment-changing state, you need to use the macro  @addtrials .  There are three kinds of trials you can add with this macro: blocks, conditionals and loops.", 
            "title": "Stateful Trials"
        }, 
        {
            "location": "/advanced/#blocks-of-trials", 
            "text": "@addtrials let [assignments]\n  body...\nend  Blocks of trials are useful for setting up state that will change during the trials. Such state can then be used in a subsequent @addtrials expression. In fact all other types of @addtrials expression will likely be nested inside blocks. The main reason to use such a block is to ensure that   Weber.offset  is well defined.  The offset counter is used to fast-forward through the expeirment by specifying an offset greater than 0.  However, if there is state that changes throughout the course of several trials, those trials cannot reliably be reproduced when only some of them are skipped. Either all or none of the trials that depend on one another should be skipped.  Anytime you have a series of trials, some of which depend on what happens earlier in an expeirment, such trials should be placed inside of an @addtrials let block. Otherwise experiment fast forwarding will result in unexpected behaviors.", 
            "title": "Blocks of Trials"
        }, 
        {
            "location": "/advanced/#conditional-trials", 
            "text": "@addtrials if [cond1]\n  body...\nelseif [cond2]\n  body...\n...\nelseif [condN]\n  body...\nelse\n  body...\nend  Adds one or mores trials that are presented only if the given conditions are met. The expressions  cond1  through  condN  are evaluted during the experiment, but each  body  is executed before the experiment begins, and is used to indicate the set of trials (and breaks or practice trials) that will be run for a given condition.  For example, the following code only runs the second trial if the user hits the \"y\" key.  @addtrials let y_hit = false\n  isresponse(e) = iskeydown(e,key y ) || iskeydown(e,key n )\n  addtrial(moment(display, Hit Y or N. ),await_response(isresponse)) do event\n    if iskeydown(event,key y )\n      y_hit = true\n    end\n  end\n\n  @addtrials if !y_hit\n    addtrial(moment(display, You did not hit Y! ),await_response(iskeydown))\n  end\nend  If  @addtrials if !y_hit  was replaced with  if !y_hit  in the above example, the second trial would always run. This is because the  if  expression would be run during setup-time, before any trials were run (when  y_hit  is false).", 
            "title": "Conditional Trials"
        }, 
        {
            "location": "/advanced/#looping-trials", 
            "text": "@addtrials while expr\n  body...\nend  Add some number of trials that repeat as long as  expr  evalutes to true. For example the follow code runs as long as the user hits the \"y\" key.  @addtrials let y_hit = true\n  @addtrials while y_hit\n    message = moment(display, Hit Y if you want to continue )\n    addtrial(message,await_response(iskeydown)) do event\n      y_hit = iskeydown(event,key y )\n    end\n  end\nend  If  @addtrials while y_hit  was replaced with  while y_hit  in the above example, the while loop would never terminate, running an infinite loop, because  y_hit  is true before the experiment starts.", 
            "title": "Looping Trials"
        }, 
        {
            "location": "/advanced/#run-time-stimulus-generation", 
            "text": "When stimuli need to be generated during an experiment the normal approach will not work. For instance, if you want a tone's frequency to depend on some delta value that changes during the experimrent the following will not work.  # THIS WILL NOT WORK!!!\nmoment(play,tone(1000+my_delta))  The basic problem here is that tone is used to generate a sound at  setup-time . What we want is for the run-time value of  my_delta  to be used. To do this you can pass a function to play. This function will be used to generate a sound during runtime.  moment(play,() -  tone(1000+my_delta,1))  Similarly, we can use a runtime value in display by passing a function to display.  moment(display,() -   hello $my_name. )  When moments are created this way, the sound or visual is generated before the moment even begins, to eliminate any latency that would be introduced by loading the sound or visual into memory. Specifically, the stimulus is generated during the most recent non-zero pause occuring before a moment. So for instance, in the following example,  mysound  will be generated ~0.5 seconds before play is called right after \"Get ready!\" is displayed.  addtrial(moment(display, Get ready! ),moment(0.5),\n         moment(display, Here we go! ),moment(play,mysound))", 
            "title": "Run-time stimulus generation."
        }, 
        {
            "location": "/extend/", 
            "text": "Functionality can be added to Weber via extensions. You can add multiple extensions to the same experiment. The \nreference\n provides a list of available extensions. Here we'll cover how to create new extensions.\n\n\nTo handle multiple extensions properly, so that all extensions work, the following functions have special extension machinery.\n\n\n\n\naddcolumn\n\n\nsetup\n\n\nrun\n\n\nrecord\n\n\naddtrial\n\n\naddpractice\n\n\naddbreak\n\n\npoll_events\n\n\n\n\nTo extend one of these functions you must first define an extension type. For example:\n\n\ntype MyExtension \n: Weber.Extension\n  my_value::String\nend\n\n\n\n\nFor all of the public functions above (everything but \npoll_events\n), you can then define a new method of these functions that includes one additional argument beyond that listed in its documentation, located before all other arguments. This argument should be of type \nExtendedExperiment{MyExtension}\n. To extend the private \npoll_events\n function, replace the \nExperiment\n argument with an \nExtendedExperiment{MyExtension}\n argument.\n\n\n\n\nDon't extend unlisted functions\n\n\nThese functions have specific machinery setup to make extension possible. Don't use the same approach with other functions and expect your extension to work.\n\n\n\n\nAs an example, \nrecord\n could be extended as follows.\n\n\nfunction record(experiment::ExtendedExperiment{MyExtension},code;keys...)\n  record(next(experiment),code;my_extension=extension(experiment).my_value,keys...)\nend\n\n\n\n\nThere are a few things to note about this implementation. First,  the extension object is accessed using \nextension\n.\n\n\nSecond, \nrecord\n is called on the \nnext\n extension.  \nAll extended functions should follow this pattern\n. Each experiment can have multiple extensions, and each pairing of an experiment with a particular plugin is called an experiment \nversion\n. These are ordered from top-most to bottom-most version. The top-most version is the first extension in the list specified in the call to \nExperiment\n. Subsequent versions are accessed in this same order, using \nnext\n, until the bottom-most version, which is the experiment without any paired extension. \n\n\nFor this extension to actually work, \nsetup\n must also be extended to add the column \n:my_extension\n to the data file.\n\n\nfunction setup(fn::Function,experiment::ExtendedExperiment{MyExtension})\n  setup(next(experiment)) do\n    addcolumn(top(experiment),:my_extension)\n    fn()\n  end\nend\n\n\n\n\nThis demonstrates one last important concept. When calling \naddcolumn\n, the function \ntop\n is called on the experiment to get the top-most version of the experiment. This is done so that any functionality of versions above the current one will be utilized in the call to \naddcolumn\n.\n\n\n\n\nWhen to use \nnext\n and \ntop\n\n\nAs a general rule, inside an extended method, when you call the same function which that method implements, you should pass \nnext(experiment)\n while all other functions taking an experiment argument should be passed \ntop(experiment)\n.\n\n\n\n\n\n\nThe private interface of run-time objects.\n\n\nMost of the functionality above is for the extension of \nsetup-time\n behavior. However, there are two ways to implement new run-time behavior: the generation of custom events and custom moments.\n\n\n\n\nCustom Events\n\n\nExtensions to \npoll_events\n can be used to notify watcher functions of new kinds of events. An event is an object that inherits from \nWeber.ExpEvent\n and which is tagged with the \n@event\n macro. Custom events can implement new methods for the existing \npublic functions on events\n or their own new functions.\n\n\nIf you define new functions, instead of leveraging the existing ones, they should generally have some default behavior for all \nExpEvent\n objects, so it is easy to call the method on any event a watcher moment receives.\n\n\n\n\nEvent Timing\n\n\nTo specify event timing, you must define a \ntime\n method for your custom event. You can simply store the time passed to \npoll_events\n in your custom event, or, if you have more precise timing information for your hardware you can store it here. Internally, the value returend by \ntime\n is used to determine when to run the next moment when a prior moment triggers on the event.\n\n\n\n\nCustom Key Events\n\n\nOne approach, if you are implementing events for a hardware input device, is to implement methods for \niskeydown\n. You can define your own type of keycode (which should be of some new custom type \n: Weber.Key\n). Then, you can then make use of the \n@key_str\n macro by adding entries to the \nWeber.str_to_code\n dictionary (a private global constant). So for example, you could add the following to the module implementing your extension.\n\n\nWeber.str_to_code[\nmy_button1\n] = MyHardwareKey(1)\nWeber.str_to_code[\nmy_button1\n] = MyHardwareKey(2)\n\n\n\n\nSuch key types should implement \n==\n, \nhash\n and \nisless\n so that the events can be ordered. This allows them to be displayed in an organized fashion when printed using \nlistkeys\n.\n\n\nOnce these events are defined you can extend \npoll_events\n so that it generates events that return true for \niskeydown(myevent,key\"my_button1\")\n (and a corresponding method for \niskeyup\n). How this happens will depend on the specific hardware you are supporting. The buttons presses could then checked for during an experiment as follows.\n\n\nresponse(key\nmy_button1\n =\n \nbutton1_pressed\n,\n         key\nmy_button2\n =\n \nbutton2_pressed\n)\n\n\n\n\n\n\nCustom Moments\n\n\nYou can create your own moment types, which must be children of \nWeber.SimpleMoment\n. These new moments will have to be generated using some newly defined function, or added automatically by extending \naddtrial\n. Once created, and added to trials, these moments will be processed at run-time using the function \nhandle\n, which should define the moment's run-time behavior. Such a moment must also define \nmoment_trace\n.\n\n\nA moment can also define \ndelta_t\n\u2013to define when it occurs\u2013or \nprepare!\n\u2013to have some sort of initialization occur before its onset\u2013but these both have default implementations.\n\n\nMethods of \nhandle\n should not make use of the extension machinery described above. What this means is that methods of \nhandle\n should never dispatch on an extended experiment, and no calls to \ntop\n, \nnext\n or \nextension\n should occur on the experiment object. Further, each moment should belong to one specific extension, in which all functionality for that custom moment should be implemented.", 
            "title": "Extending Weber"
        }, 
        {
            "location": "/extend/#the-private-interface-of-run-time-objects", 
            "text": "Most of the functionality above is for the extension of  setup-time  behavior. However, there are two ways to implement new run-time behavior: the generation of custom events and custom moments.", 
            "title": "The private interface of run-time objects."
        }, 
        {
            "location": "/extend/#custom-events", 
            "text": "Extensions to  poll_events  can be used to notify watcher functions of new kinds of events. An event is an object that inherits from  Weber.ExpEvent  and which is tagged with the  @event  macro. Custom events can implement new methods for the existing  public functions on events  or their own new functions.  If you define new functions, instead of leveraging the existing ones, they should generally have some default behavior for all  ExpEvent  objects, so it is easy to call the method on any event a watcher moment receives.", 
            "title": "Custom Events"
        }, 
        {
            "location": "/extend/#event-timing", 
            "text": "To specify event timing, you must define a  time  method for your custom event. You can simply store the time passed to  poll_events  in your custom event, or, if you have more precise timing information for your hardware you can store it here. Internally, the value returend by  time  is used to determine when to run the next moment when a prior moment triggers on the event.", 
            "title": "Event Timing"
        }, 
        {
            "location": "/extend/#custom-key-events", 
            "text": "One approach, if you are implementing events for a hardware input device, is to implement methods for  iskeydown . You can define your own type of keycode (which should be of some new custom type  : Weber.Key ). Then, you can then make use of the  @key_str  macro by adding entries to the  Weber.str_to_code  dictionary (a private global constant). So for example, you could add the following to the module implementing your extension.  Weber.str_to_code[ my_button1 ] = MyHardwareKey(1)\nWeber.str_to_code[ my_button1 ] = MyHardwareKey(2)  Such key types should implement  == ,  hash  and  isless  so that the events can be ordered. This allows them to be displayed in an organized fashion when printed using  listkeys .  Once these events are defined you can extend  poll_events  so that it generates events that return true for  iskeydown(myevent,key\"my_button1\")  (and a corresponding method for  iskeyup ). How this happens will depend on the specific hardware you are supporting. The buttons presses could then checked for during an experiment as follows.  response(key my_button1  =   button1_pressed ,\n         key my_button2  =   button2_pressed )", 
            "title": "Custom Key Events"
        }, 
        {
            "location": "/extend/#custom-moments", 
            "text": "You can create your own moment types, which must be children of  Weber.SimpleMoment . These new moments will have to be generated using some newly defined function, or added automatically by extending  addtrial . Once created, and added to trials, these moments will be processed at run-time using the function  handle , which should define the moment's run-time behavior. Such a moment must also define  moment_trace .  A moment can also define  delta_t \u2013to define when it occurs\u2013or  prepare! \u2013to have some sort of initialization occur before its onset\u2013but these both have default implementations.  Methods of  handle  should not make use of the extension machinery described above. What this means is that methods of  handle  should never dispatch on an extended experiment, and no calls to  top ,  next  or  extension  should occur on the experiment object. Further, each moment should belong to one specific extension, in which all functionality for that custom moment should be implemented.", 
            "title": "Custom Moments"
        }, 
        {
            "location": "/experiment/", 
            "text": "#\n\n\nWeber.Experiment\n \n \nType\n.\n\n\nExperiment([skip=0],[columns=[symbols...]],[debug=false],\n           [moment_resolution=0.0015],[input_resolution=1/60],[data_dir=\ndata\n],\n           [width=1024],[height=768],[warn_on_trials_only=true],[extensions=[]])\n\n\n\n\nPrepares a new experiment to be run.\n\n\nKeyword Arguments\n\n\n\n\nskip\n the number of offsets to skip. Allows restarting of an experiment somewhere in the middle. When an experiment is terminated, the most recent offset is reported. The offset is also recorded in each row of the resulting data file (also reported on exit).\n\n\ncolumns\n the names (as symbols) of columns that will be recorded during the experiment (using \nrecord\n). These can be set to fixed values (using :name =\n value), or be filled in during a call to record (:name). The column \n:value\n is always included here, even if not specified, since there are number of events recorded automatically which make use of this column.\n\n\ndebug\n if true, experiment will show in a windowed view\n\n\nmoment_resolution\n the desired precision (in seconds) that moments should be presented at. Warnings will be printed for moments that lack this precision.\n\n\ninput_resolution\n the precision (in seconds) that input events should be queried at. This almost never needs to be changed. Keyboards do not provide precise timing, and the timing of response pads is queried independently from input_resolution, using \nresponse_time\n.\n\n\ndata_dir\n the directory where data files should be stored (can be set to nothing to prevent a file from being created)\n\n\nwidth\n and \nheight\n specified the screen resolution during the experiment\n\n\nextensions\n an array of Weber.Extension objects, which extend the behavior of an experiment.\n\n\nwarn_on_trials_only\n when true, latency warnings are only displayed when the trial count is greater than 0. Thus, practice and breaks that occur before the first trial do not raise latency warnings.\n\n\n\n\nsource\n\n\n#\n\n\nWeber.addcolumn\n \n \nFunction\n.\n\n\naddcolumn(column::Symbol)\n\n\n\n\nAdds a column to be recorded in the data file.\n\n\nThis function must be called during setup.  It cannot be called once the experiment has begun. Repeatedly adding the same column only adds the column once. After adding a column you can include that column as a keyword argument to \nrecord\n. You need not write to the column for every record. If left out, the column will be empty in the resulting row of the data file.\n\n\nsource\n\n\n#\n\n\nWeber.setup\n \n \nFunction\n.\n\n\nsetup(fn,experiment)\n\n\n\n\nSetup the experiment, adding breaks, practice, and trials.\n\n\nSetup creates the context necessary to generate elements of an experiment. All calls to \naddtrial\n, \naddbreak\n and \naddpractice\n must be called inside of \nfn\n. This function must be called before \nrun\n.\n\n\nsource\n\n\n#\n\n\nBase.run\n \n \nFunction\n.\n\n\nrun(experiment;await_input=true)\n\n\n\n\nRuns an experiment. You must call \nsetup\n first.\n\n\nBy default this function waits for user input before returning. This prevents a console from closing at the end of an experiment, preventing the user from viewing important messages. The exception is if run is called form within Juno: await_input should never be set to true in this case.\n\n\nsource\n\n\n#\n\n\nWeber.randomize_by\n \n \nFunction\n.\n\n\nrandomize_by(itr)\n\n\n\n\nRandomize by a given iterable object, usually a string (e.g. the subject id.)\n\n\nIf the same iterable is given, calls to random functions (e.g. \nrand\n, \nrandn\n and \nshuffle\n) will result in the same output.\n\n\nsource\n\n\n#\n\n\nWeber.@read_args\n \n \nMacro\n.\n\n\n@read_args(description,[keyword args...])\n\n\n\n\nReads experimental parameters from the user.\n\n\nWith no additional keyword arguments this requests the subject id, and an optional \nskip\n parameter (defaults to 0) from the user, and then returns them both in a tuple. The skip can be used to restart an experiment by passing it as the \nskip\n keyword argument to the \nExperiment\n constructor.\n\n\nYou can specify additional keyword arguments to request additional values from the user. Arguments that are a type will yield a request for textual input, and will verify that that input can be parsed as the given type. Arguments whose values are a list of symbols yield a request that the user select one of the specified values.\n\n\nArguments are requested from the user either as command-line arguments, or, if no command-line arguments were specified, interactively. Interactive arguments work both in the terminal or in Juno. This macro also generates useful help text that will be displayed to the user when they give a single command-line \"-h\" argument. This help text will print out the \ndesecription\n string.\n\n\nExample\n\n\nsubject_id,skip,condition,block = @read_args(\nA simple experiment\n,\n  condition=[:red,:green,:blue],block=Int)\n\n\n\n\nsource\n\n\n#\n\n\nWeber.@read_debug_args\n \n \nMacro\n.\n\n\n@read_debug_args(description,[keyword args...])\n\n\n\n\nSame as @read_args, but better suited to debugging errors in your program when running the experiment in Juno.\n\n\nSpecifically, this verison will never spawn a new process to run the experiment. This means that you can safely step through the code using debugging tools. In this case, you will also likely want to set \ndebug=true\n when defining your \nExperiment\n object.\n\n\nsource\n\n\n#\n\n\nWeber.create_new_project\n \n \nFunction\n.\n\n\ncreate_new_project(name,dir=\n.\n)\n\n\n\n\nCreates a set of files to help you get started on a new experiment.\n\n\nThis creates a file called run_[name].jl, and a README.md and setup.jl file for your expeirment. The readme provides useful information for running the experiment that is common across all experiments. The run file provides some guidelines to get you started creating an experiment and the setup file is a script that can be used to install Weber and any additional dependencies for the project, for anyone who wants to download and run your experiment.\n\n\nsource\n\n\n#\n\n\nWeber.trial\n \n \nFunction\n.\n\n\nWeber.trial()\n\n\n\n\nReturns the current trial of the experiment.\n\n\nsource\n\n\n#\n\n\nWeber.offset\n \n \nFunction\n.\n\n\nWeber.offset()\n\n\n\n\nReturns the current offset. The offset represents a well defined time in the experiment. The offset is typically incremented once for every call to \naddpractice\n \naddtrial\n and \naddbreak\n, unless you use \n@addtrials\n. You can use the offset to restart the experiment from a well defined location.\n\n\n\n\nWarning\n\n\nFor offsets to be well defined, all calls to \nmoment\n and \n@addtrials\n must follow the \nguidlines\n in the user guide. In particular, moments should not rely on state that changes during the experiment unless they are wrapped in an @addtrials macro.\n\n\n\n\nsource\n\n\n#\n\n\nWeber.tick\n \n \nFunction\n.\n\n\nWeber.tick()\n\n\n\n\nWith microsecond precision, this returns the number of elapsed seconds from the start of the experiment to the start of the most recent moment.\n\n\nIf there is no experiment running, this returns the time since epoch with microsecond precision.\n\n\nsource\n\n\n#\n\n\nWeber.metadata\n \n \nFunction\n.\n\n\nWeber.metadata() = Dict{Symbol,Any}()\n\n\nReturns metadata for this experiment. You can store global state, specific to this experiment, in this dictionary.\n\n\nsource", 
            "title": "Experiments"
        }, 
        {
            "location": "/trials/", 
            "text": "#\n\n\nWeber.addtrial\n \n \nFunction\n.\n\n\naddtrial(moments...)\n\n\n\n\nAdds a trial to the experiment, consisting of the specified moments.\n\n\nEach trial records a \"trial_start\" code, and increments a counter tracking the number of trials, and (normally) an offset counter. These two numbers are reported on every line of the resulting data file (see \nrecord\n). They can be retrieved using \nWeber.trial()\n and \nWeber.offset()\n.\n\n\nsource\n\n\n#\n\n\nWeber.addbreak\n \n \nFunction\n.\n\n\naddbreak(moments...)\n\n\n\n\nIdentical to \naddpractice\n, but records \"break_start\" instead of \"practice_start\".\n\n\nsource\n\n\n#\n\n\nWeber.addbreak_every\n \n \nFunction\n.\n\n\naddbreak_every(n,total,\n               [response=key\n:space:\n],[response_str=\nthe spacebar\n])\n\n\n\n\nAdds a break every \nn\n times this event is added given a known number of total such events.\n\n\nBy default this waits for the user to hit spacebar to move on.\n\n\nsource\n\n\n#\n\n\nWeber.addpractice\n \n \nFunction\n.\n\n\naddpractice(moments...)\n\n\n\n\nIdentical to \naddtrial\n, except that it does not incriment the trial count, and records a \"practice_start\" instead of \"trial_start\" code.\n\n\nsource\n\n\n#\n\n\nWeber.moment\n \n \nFunction\n.\n\n\nmoment([delta_t],[fn],args...;keys...)\n\n\n\n\nCreate a moment that occurs \ndelta_t\n (default 0) seconds after the onset of the previous moment, running the specified function.\n\n\nThe function \nfn\n is passed the arguments specified in \nargs\n and \nkeys\n.\n\n\nsource\n\n\nmoment(moments...)\nmoment(moments::Array)\n\n\n\n\nCreate a single, compound moment by concatentating several moments togethor.\n\n\nsource\n\n\n#\n\n\nWeber.response\n \n \nFunction\n.\n\n\nresponse(key1 =\n response1,key2 =\n response2,...;kwds...)\n\n\n\n\nCreate a watcher moment that records press of \nkey[n]\n as \nrecord(response[n];kwds...)\n.\n\n\nSee \nrecord\n for more details on how events are recorded.\n\n\nWhen a key is pressed down, the record event occurs. Key releases are also recorded, but are suffixed, by default, with \"_up\". This suffix can be changed using the \nkeyup_suffix\n keyword argument.\n\n\nsource\n\n\nresponse([fn],adapter,[key1] =\n [\nresp1\n],...;correct=[resp],\n         [show_feedback=true],\n         [feedback=Dict(true=\nCorrect\n,false=\nWrong!\n)]\n         keys...)\n\n\n\n\nRecord a response in a n-alternative forced choice task and update an adapter.\n\n\nThe first response recieved is interpreted as the actual response. Subsequent responses will be recorded, without a delta or correct value set, and appending \"late_\" to the specified response string.\n\n\nFunction Callback\n\n\nOptionally, upon participant response, \nfn\n receives two arguments: the provided response, and the correct response.\n\n\nKeyword Arguments\n\n\n\n\ncorrect\n the response string corresponding to the correct response\n\n\nshow_feedback\n (default = true): whether to show feedback to the participant after they respond.\n\n\nfeedback\n the text to display to a participant when they are correct (for the true key, defaults to \"Correct!\") or incorrect (for the false key, defaults to \"Wrong!\").\n\n\n\n\nAny additional keyword arguments are added as column values when the response is recorded.\n\n\nsource\n\n\n#\n\n\nWeber.await_response\n \n \nFunction\n.\n\n\nawait_response(isresponse;[atleast=0.0])\n\n\n\n\nThis moment starts when the \nisresponse\n function evaluates to true.\n\n\nThe \nisresponse\n function will be called anytime an event occurs. It should take one parameter (the event that just occured).\n\n\nIf the response is provided before \natleast\n seconds, the moment does not start until \natleast\n seconds have passed.\n\n\nsource\n\n\n#\n\n\nWeber.record\n \n \nFunction\n.\n\n\nrecord(code;keys...)\n\n\n\n\nRecord a row to the experiment data file using a given \ncode\n.\n\n\nEach event has a code which identifies it as being a particular type of experiment event. This is normally a string. Each keyword argument is the value of a column (with the same name). By convention when you record something with the same code you should specify the same set of columns.\n\n\nAll calls to record also result in many additional values being written to the data file. The start time and date of the experiment, the trial and offset number, the version of Weber, and the time at which the last moment started are all stored.  Additional information can be added during creation of the experiment (see \nExperiment\n).\n\n\nEach call to record writes a new row to the data file used for the experiment, so there should be no loss of data if the program is terminated prematurely for some reason.\n\n\n\n\nAutomatically Recorded Codes\n\n\nThere are several codes that are automatically recorded by Weber. They include:\n\n\n\n\ntrial_start\n - recorded at the start of moments added by \naddtrial\n\n\npractice_start\n - recorded at the start of moments added by \naddpractice\n\n\nbreak_start\n - recorded at the start of moments added by \naddbreak\n\n\nhigh_latency\n - recorded whenever a high latency warning is triggered. The \"value\" column is set to the error between the actual and the desired timing of a moment, in seconds.\n\n\npaused\n - recorded when user hits 'escape' and the experiment is paused.\n\n\nunpaused\n - recorded when the user ends the pause, continuuing the experiment.\n\n\nterminated\n - recorded when the user manually terminates the experiment (via 'escape')\n\n\nclosed\n - recorded just before the experiment window closes\n\n\n\n\n\n\nsource\n\n\n#\n\n\nWeber.timeout\n \n \nFunction\n.\n\n\ntimeout(fn,isresponse,timeout,[atleast=0.0])\n\n\n\n\nThis moment starts when either \nisresponse\n evaluates to true or timeout time (in seconds) passes.\n\n\nThe \nisresponse\n function will be called anytime an event occurs. It should take one parameter (the event that just occured).\n\n\nIf the moment times out, the function \nfn\n (with no arguments) will be called.\n\n\nIf the response is provided before \natleast\n seconds, the moment does not begin until \natleast\n seconds (\nfn\n will not be called).\n\n\nsource\n\n\n#\n\n\nWeber.show_cross\n \n \nFunction\n.\n\n\nshow_cross([delta_t])\n\n\n\n\nCreates a moment that shows a cross hair \ndelta_t\n seconds after the start of the previous moment (defaults to 0 seconds).\n\n\nsource\n\n\n#\n\n\nWeber.when\n \n \nFunction\n.\n\n\nwhen(condition,moments...)\n\n\n\n\nThis moment will begin at the \nstart\n of the previous moment, and presents the following moments (possibly in nested iterable objects) if the \ncondition\n function (which takes no arguments) evaluates to true.\n\n\nsource\n\n\n#\n\n\nWeber.looping\n \n \nFunction\n.\n\n\nlooping(when=fn,moments...)\n\n\n\n\nThis moment will begin at the \nstart\n of the previous moment, and repeats the listed moments (possibly in nested iterable objects) until the \nwhen\n function (which takes no arguments) evaluates to false.\n\n\nsource\n\n\n#\n\n\nWeber.@addtrials\n \n \nMacro\n.\n\n\n@addtrials expr...\n\n\n\n\nMarks a let block, a for loop, or an if expression as dependent on experiment run-time state, leaving the offset counter unincremented within that block.  The immediately proceeding loop or conditional logic will be run during experiment run-time rather than setup-time.\n\n\nRefer to the \nAdvanced Topics\n of the manual section for more details.\n\n\nsource\n\n\n#\n\n\nWeber.update!\n \n \nFunction\n.\n\n\nupdate!(adapter,response,correct)\n\n\n\n\nUpdates any internal state for the adapter when the listener responds with \nresponse\n and the correct response is \ncorrect\n. Usually not called directly, but instead called within \nresponse\n, when the adapter is passed as the first argument. May take a while to run.\n\n\nsource\n\n\n#\n\n\nWeber.estimate\n \n \nFunction\n.\n\n\nestimate(adapter)\n\n\n\n\nReturns the mean and error of the adapters threshold estimate. May take some time to run.\n\n\nsource\n\n\n#\n\n\nWeber.delta\n \n \nFunction\n.\n\n\ndelta(adapter)\n\n\n\n\nReturns the next delta that should be tested to help estimate the threshold.\n\n\nsource\n\n\n#\n\n\nWeber.oddball_paradigm\n \n \nFunction\n.\n\n\noddball_paradigm(trial_body_fn,n_oddballs,n_standards;\n                 lead=20,no_oddball_repeats=true)\n\n\n\n\nHelper to generate trials for an oddball paradigm.\n\n\nThe trial_body_fn should setup stimulus presentation: it takes one argument, indicating if the stimulus should be a standard (false) or oddball (true) stimulus.\n\n\nIt is usually best to use oddball_paradigm with a do block syntax. For instance, the following code sets up 20 oddball and 150 standard trials.\n\n\noddball_paradigm(20,150) do isoddball\n  if isoddball\n    addtrial(...create oddball trial here...)\n  else\n    addtrial(...create standard trial here...)\n  end\nend\n\n\n\n\nKeyword arguments\n\n\n\n\nlead\n: determines the number of standards that repeat before any oddballs get presented\n\n\nno_oddball_repeats\n: determines if at least one standard must occur between each oddball (true) or not (false).\n\n\n\n\nsource\n\n\n#\n\n\nWeber.levitt_adapter\n \n \nFunction\n.\n\n\nlevit_adapter([first_delta=0.1],[down=3],[up=1],\n              [big_reverse=3],[big=0.01],[little=0.005],\n              [min_reversals=7],[min_delta=-Inf],[max_delta=Inf],\n              [mult=false])\n\n\n\n\nAn adapter that finds a threshold according to a non-parametric statistical procedure. This approach makes fewer explicit assumptions than \nbayesian_adapter\n but may be slower to converge to a threshold.\n\n\nThis finds a threshold by moving the delta down after three correct responses and up after one incorrect response (these default up and down counts can be changed). This is the same approach described in Levitt (1971).\n\n\nKeyword Arguments\n\n\n\n\nfirst_delta\n: the delta that the first trial should present.\n\n\nup\n: how many incorrect responses in a row must occur for the delta to move up\n\n\ndown\n: how many correct responses in a row must occur for the delta to move down.\n\n\nbig\n: the amount delta changes by (up or down) at first\n\n\nbig_reverse\n: how many reveresals (up to down or down to up) must occur before \nlittle\n is used instead of \nbig\n\n\nlittle\n: the amount delat changes by (up or down) after \nbig_reverse\n reversals.\n\n\nmin_reversals\n: the smallest number of reversals that can be used to estimate a threshold.\n\n\nmin_delta\n: the smallest delta allowed\n\n\nmax_delta\n: the largest delta allowed\n\n\nmult\n: whether the delta change should be additive (false) or  multiplicative (true).\n\n\n\n\nsource\n\n\n#\n\n\nWeber.bayesian_adapter\n \n \nFunction\n.\n\n\nbayesian_adapter(;first_delta=0.1,\n                 n_samples=1000,miss=0.01,threshold=0.79,\n                 min_delta=0,max_delta=1,\n                 min_plausible_delta = 0.0001,\n                 max_plausible_delta = 0.2,\n                 repeat3_thresh=1.0,repeat2_thresh=0.1,\n                 thresh_prior=\n                 Truncated(LogNormal(log(min_plausible_delta),\n                                     log(max_plausible_delta/\n                                         min_plausible_delta/2)),\n                           min_delta,max_delta),\n                      inv_slope_prior=TruncatedNormal(0,0.25,0,Inf),\n                      thresh_d=thresh_prior,\n                      inv_slope_d=inv_slope_prior)\n\n\n\n\nAn adapter that finds a threshold according to a parametric statistical model. This makes more explicit assumptions than the \nlevitt_adapter\n but will normally find the threshold faster.\n\n\nThe psychmetric curve is estimated from user responses using a bayesian approach. After estimation, each new delta is selected in a greedy fashion, picking the response that best minimizes entropy according to this psychometric function. This is a modified version of the approach described in Kontsevich \n Tyler 1999. Specifically, the approach here uses importance sampling instead of sampling parmeters over a deterministic, uniform grid. This should increase measurement efficiency if the priors are chosen well.\n\n\nThis algorithm assumes the following functional form for the psychometric response as a function of the stimulus difference $\u0394$.\n\n\n$f(\u0394) = \u03bb/2 + (1-\u03bb) \u03a6((\u0394 - \u03b8)\u22c5\u03c3/sqrt{2})$\n\n\nIn the above $\u03a6$ is the cumulative distribution function of a normal distribution, $\u03bb$ is the miss-rate parameter, indicating the rate at which listeners make a mistake, even when the delta is large and easily heard, $\u03b8$ is the 50%-correct threshold, and $\u03c3$ is the psychometric slope.\n\n\nFor stability and robustness, this adapter begins by repeating the same delta multiple times and only begins quickly changing deltas trial-by-trial when the ratio of standard deviation to the mean is small. This functionality can be adjusted using \nrepeat3_thresh\n and \nrepeat2_thresh\n, or, if you do not wish to have any repeats, both values can be set to Inf.\n\n\nKeyword Arugments\n\n\n\n\nfirst_delta\n: the delta to start measuring with\n\n\nn_samples\n: the number of samples to use during importance sampling. The algorithm for selecting new deltas is O(n\u00b2).\n\n\nmiss\n: the expected rate at which listeners will make mistakes even for easy to percieve differences.\n\n\nthreshold\n: the %-response threshold to be estimated\n\n\nmin_delta\n: the smallest possible delta\n\n\nmax_delta\n: the largest possible delta\n\n\nmin_plausible_delta\n: the smallest plausible delta, should be \n 0. Used to define a reasonable value for thresh_prior and inv_slope_prior.\n\n\nmax_plausible_delta\n: the largest plausible delta, should be \n max_delta. Used to define a reasonable value for thresh_prior and inv_slope_prior.\n\n\nthresh_prior\n: the prior probability distribution across thresholds. This influence the way the delta is adapted. By default this is defined in terms of min_plausible_delta and max_plausible_delta.\n\n\ninv_slope_prior\n: the prior probability distribution across inverse slopes. By default this is defined in terms of min_plausible_delta and max_plausible_delta.\n\n\nthresh_d\n: the distribution over-which to draw samples for the threshold during importance sampling. This defaults to thresh_prior\n\n\ninv_slope_d\n: the distribution over-which to draw samples for the inverse slope during importance sampling. This defaults to inv_slope_prior.\n\n\nrepeat2_thresh\n: the ratio of sd / mean for theta must suprass to repeat each delta twice.\n\n\nrepeat3_thresh\n: the ratio of sd / mean for theta must surpass to repeat each delta thrice.\n\n\n\n\nsource\n\n\n#\n\n\nWeber.constant_adapter\n \n \nFunction\n.\n\n\nconstant_adapter(stimuli)\n\n\n\n\nAn adapter that can be used to implement the method of constant stimuli: the specified sequence of stimulus deltas is presented in order to participants.\n\n\nStrictly speaking, this is not an adaptive tracking procedure. However, it can be convienient to have the same programming interface for this method as for adaptive methods. In this way you can easily select between the method of constant stimuli or some kind of adaptive procedure.\n\n\nsource", 
            "title": "Trials"
        }, 
        {
            "location": "/sound/", 
            "text": "In addition to functions available below you can also call \nFileIO.jl\n's \nload\n and \nsave\n functions for common audio file formats (e.g. \"wav\", \"aiff\", \"ogg\").\n\n\n\n\nSound Creation\n\n\n#\n\n\nWeber.tone\n \n \nFunction\n.\n\n\ntone(freq,length,[sample_rate_Hz=44100],[phase=0])\n\n\n\n\nCreates a pure tone of the given frequency and length (in seconds).\n\n\nYou can create an infinitely long tone (playable with \nstream\n) by passing a length of Inf, or leaving out the length entirely.\n\n\nsource\n\n\n#\n\n\nWeber.noise\n \n \nFunction\n.\n\n\nnoise(length,[sample_rate_Hz=44100])\n\n\n\n\nCreates a period of white noise of the given length (in seconds).\n\n\nYou can create an infinite stream of noise (playable with \nstream\n) by passing a length of Inf, or leaving out the length entirely.\n\n\nsource\n\n\n#\n\n\nWeber.silence\n \n \nFunction\n.\n\n\nsilence(length,[sample_rate_Hz=44100])\n\n\n\n\nCreates period of silence of the given length (in seconds).\n\n\nsource\n\n\n#\n\n\nWeber.harmonic_complex\n \n \nFunction\n.\n\n\nharmonic_complex(f0,harmonics,amps,length,\n                 [sample_rate_Hz=44100],[phases=zeros(length(harmonics))])\n\n\n\n\nCreates a harmonic complex of the given length, with the specified harmonics at the given amplitudes. This implementation is somewhat superior to simply summing a number of pure tones generated using \ntone\n, because it avoids beating in the sound that may occur due floating point errors.\n\n\nYou can create an infinitely long complex (playable with \nstream\n) by passing a length of Inf, or leaving out the length entirely.\n\n\nsource\n\n\n#\n\n\nWeber.asstream\n \n \nFunction\n.\n\n\nasstream(fn;[sample_rate_Hz=44100])\n\n\n\n\nConverts the function \nfn\n into a sound stream.\n\n\nThe function \nfn\n should take a single argument\u2013the time in seconds from the start of the stream\u2013and should return a number between -1 and 1.\n\n\nsource\n\n\n#\n\n\nWeber.stream_unit\n \n \nFunction\n.\n\n\nstream_unit()\n\n\n\n\nReport the length in samples of each unit that all sound streams should generate.\n\n\nsource\n\n\n#\n\n\nWeber.sound\n \n \nFunction\n.\n\n\nsound(x::Array,[cache=true];[sample_rate_Hz=44100])\n\n\n\n\nCreates a sound object from an arbitrary array.\n\n\nFor real numbers, assumes 1 is the loudest and -1 the softest. Assumes 16-bit PCM for integers. The array should be 1d for mono signals, or an array of size (N,2) for stereo sounds.\n\n\nWhen cache is set to true, sound will cache its results thus avoiding repeatedly creating a new sound for the same object.\n\n\n\n\nCalled Implicitly\n\n\nThis function is normally called implicitly in a call to \nplay(x)\n, where x is an arbitrary array, so it need not normally be called.\n\n\n\n\nsource\n\n\nsound(x::SampleBuff,[cache=true])\n\n\n\n\nCreates a sound object from a \nSampleBuf\n (from the \nSampledSignals\n module).\n\n\nsource\n\n\n#\n\n\nWeber.buffer\n \n \nFunction\n.\n\n\nbuffer(s::Sound)\n\n\n\n\nGets the \nSampleBuf\n associated with this sound (c.f. \nSampledSignals\n package).\n\n\nsource\n\n\n\n\nSound Manipulation\n\n\n#\n\n\nWeber.highpass\n \n \nFunction\n.\n\n\nhighpass(x,high,[order=5],[sample_rate_Hz=samplerate(x)])\n\n\n\n\nHigh-pass filter the sound (or stream) at the specified frequency.\n\n\nFiltering uses a butterworth filter of the given order.\n\n\nsource\n\n\n#\n\n\nWeber.lowpass\n \n \nFunction\n.\n\n\nlowpass(x,low,[order=5],[sample_rate_Hz=samplerate(x)])\n\n\n\n\nLow-pass filter the sound (or stream) at the specified frequency.\n\n\nFiltering uses a butterworth filter of the given order.\n\n\nsource\n\n\n#\n\n\nWeber.bandpass\n \n \nFunction\n.\n\n\nbandpass(x,low,high,[order=5],[sample_rate_Hz=samplerate(x)])\n\n\n\n\nBand-pass filter the sound (or stream) at the specified frequencies.\n\n\nFiltering uses a butterworth filter of the given order.\n\n\nsource\n\n\n#\n\n\nWeber.ramp\n \n \nFunction\n.\n\n\nramp(x,[ramp_s=0.005];[sample_rate_Hz=samplerate(x)])\n\n\n\n\nApplies a half cosine ramp to start and end of the sound.\n\n\nRamps prevent clicks at the start and end of sounds.\n\n\nsource\n\n\n#\n\n\nWeber.rampon\n \n \nFunction\n.\n\n\nrampon(stream,[ramp_s=0.005])\n\n\n\n\nApplies a half consine ramp to start of the sound or stream.\n\n\nsource\n\n\n#\n\n\nWeber.rampoff\n \n \nFunction\n.\n\n\nrampoff(stream,[ramp_s=0.005],[after=0])\n\n\n\n\nApplies a half consine ramp to the sound or stream after \nafter\n seconds, ending the stream at that point.\n\n\nsource\n\n\n#\n\n\nWeber.fadeto\n \n \nFunction\n.\n\n\nfadeto(stream,channel=1,transition=0.05)\n\n\n\n\nSmoothly transition from the currently playing stream to another stream.\n\n\nsource\n\n\nfadeto(sound1,sound2,overlap=0.05)\n\n\n\n\nCreate a sound that is a smooth transition from sound1 to sound2.\n\n\nsource\n\n\n#\n\n\nWeber.attenuate\n \n \nFunction\n.\n\n\nattenuate(x,atten_dB)\n\n\n\n\nApply the given decibels of attenuation to the sound (or stream) relative to a power level of 1.\n\n\nThis function normalizes the sound to have a root mean squared value of 1 and then reduces the sound by a factor of $10^{-a/20}$, where $a$ = \natten_dB\n.\n\n\nIf \nx\n is a stream, attenuate takes an additional keyword argument \ntime_constant\n. This determines the time across which the sound is normalized to power 1, which defaults to 1 second.\n\n\nsource\n\n\n#\n\n\nWeber.mix\n \n \nFunction\n.\n\n\nmix(x,y,...)\n\n\n\n\nMix several sounds (or streams) together so that they play at the same time.\n\n\nsource\n\n\n#\n\n\nWeber.mult\n \n \nFunction\n.\n\n\nmult(x,y,...)\n\n\n\n\nMutliply several sounds (or streams) together. Typically used to apply an amplitude envelope.\n\n\nsource\n\n\n#\n\n\nWeber.envelope\n \n \nFunction\n.\n\n\nenvelope(mult,length,[sample_rate_Hz=44100])\n\n\n\n\nCreates an evelope of a given multiplier and length (in seconds).\n\n\nIf mult = 0 this is the same as calling silence. This function is useful in conjunction with \nfadeto\n and \nmult\n when defining an envelope that changes in level. For example, the following will play a 1kHz tone for 1 second, which changes in volume halfway through to a softer level.\n\n\nmult(tone(1000,1),fadeto(envelope(1,0.5),envelope(0.1,0.5)))\n\n\n\n\nsource\n\n\n\n\nPlayback\n\n\n#\n\n\nWeber.setup_sound\n \n \nFunction\n.\n\n\nsetup_sound([sample_rate_Hz=44100],[num_channels=8],[queue_size=8],\n            [stream_unit=2^10])\n\n\n\n\nInitialize format and capacity of audio playback.\n\n\nThis function is called automatically (using the default settings) the first time a \nSound\n object is created (normally during \nplay\n or \nstream\n).  It need not normally be called explicitly, unless you wish to change one of the default settings.\n\n\nSample Rate\n\n\nSample rate determines the maximum playable frequency (max freq is \u2248 sample_rate/2). Changing the sample rate from the default 44100 to a new value will also change the default sample rate sounds will be created at, to match this new sample rate.\n\n\n\n\nThere is no check for sampling rate\n\n\nUpon playback, there is no check to ensure that the sample rate of a given sound is the same as that setup here, and no resampling of the sound is made, so it will play incorrectly if the sample rates differ. This minimizes the latency of audio playback.\n\n\n\n\nChannel Number\n\n\nThe number of channels determines the number of sounds and streams that can be played concurrently. Note that discrete sounds and streams use a distinct set of channels.\n\n\nQueue Size\n\n\nSounds can be queued to play ahead of time (using the \ntime\n parameter of \nplay\n). When you request that a sound be played it may be queued to play on a channel where a sound is already playing. The number of sounds that can be queued to play at once is determined by queue size. The number of channels times the queue size determines the number of sounds that you can queue up to play ahead of time.\n\n\nStream Unit\n\n\nThe stream unit determines the number of samples that are streamed at one time. Iterators to be used as streams should generate this many samples at a time.  If this value is two small for your hardware, streams will sound jumpy. However the latency for changing from one stream to another will increase as the stream unit increases.\n\n\nsource\n\n\n#\n\n\nWeber.play\n \n \nFunction\n.\n\n\nplay(x;[time=0.0],[channel=0])\n\n\n\n\nPlays a sound (created via \nsound\n).\n\n\nFor convenience, play can also can be called on any object that can be turned into a sound (via \nsound\n).\n\n\nThis function returns immediately with the channel the sound is playing on. You may provide a specific channel that the sound plays on: only one sound can be played per channel. Normally it is unecessary to specify a channel, because an appriate channel is selected for you. However, pausing and resuming of sounds occurs on a per channel basis, so if you plan to pause a specific sound, you can do so by specifiying its channel.\n\n\nIf \ntime \n 0\n, the sound plays at the given time (in seconds from epoch, or seconds from experiment start if an experiment is running), otherwise the sound plays as close to right now as is possible.\n\n\nsource\n\n\nplay(fn::Function)\n\n\n\n\nPlay the sound that's returned by calling \nfn\n.\n\n\nsource\n\n\n#\n\n\nWeber.duration\n \n \nFunction\n.\n\n\nduration(x)\n\n\n\n\nGet the duration of the given sound.\n\n\nsource\n\n\n#\n\n\nWeber.stream\n \n \nFunction\n.\n\n\nstream([itr | fn],channel=1)\n\n\n\n\nPlays sounds continuously on a given channel by reading from the iterator \nitr\n whenever more data is required. The iterator should return objects that can be turned into sounds (via \nsound\n). The number of available streaming channels is determined by \nsetup_sound\n. The size, in samples, of each sound returned by this iterator should be equal to \nstream_unit\n.\n\n\nAlternatively a \nfn\n can be streamed: this transforms a previously streamed itr into a new iterator by calling \nfn(itr)\n. If no stream already exists on the given channel, \nfn\n is passed the result of \ncountfrom()\n.\n\n\nA stream stops playing if the iterator is finished. There can only be one stream per channel.  Streaming a new iterator on the same channel as another stream stops the older stream. The channels for \nstream\n are separate from the channels for \nplay\n. That is, \nplay(mysound,channel=1)\n plays a sound on a channel separate from \nstream(mystream,1)\n.\n\n\n\n\nStreams are not precisely timed\n\n\nStreams cannot occur at a precise time. Their latency is variable and depends on the value of \nstream_unit()\n. Future versions of Weber will likely allow for precisely timed audio streams.\n\n\n\n\nsource\n\n\n#\n\n\nWeber.stop\n \n \nFunction\n.\n\n\nstop(channel)\n\n\n\n\nStop the stream that is playing on the given channel.\n\n\nsource\n\n\n#\n\n\nSampledSignals.samplerate\n \n \nFunction\n.\n\n\nsamplerate([sound])\n\n\n\n\nReport the sampling rate of the sound or of any object that can be turned into a sound.\n\n\nIf no sound is passed, the curent playback sampling rate is reported (as determiend by \nsetup_sound\n).  The sampling rate of object determines how many samples per second are used to represent the sound. Objects that can be converted to sounds assume the sampling rate of the current hardware settings as defined by \nsetup_sound\n.\n\n\nsource\n\n\n#\n\n\nWeber.current_sound_latency\n \n \nFunction\n.\n\n\ncurrent_sound_latency()\n\n\n\n\nReports the current, minimum latency of audio playback.\n\n\nThe current latency depends on your hardware and software drivers. This estimate does not include the time it takes for a sound to travel from your sound card to speakers or headphones. This latency estimate is used internally by \nplay\n to present sounds at accurate times.\n\n\nsource\n\n\n#\n\n\nWeber.pause_sounds\n \n \nFunction\n.\n\n\npause_sounds([channel],[isstream])\n\n\n\n\nPause all sounds (or a stream) playing on a given channel.\n\n\nIf no channel is specified, then all sounds are paused.\n\n\nsource\n\n\n#\n\n\nWeber.resume_sounds\n \n \nFunction\n.\n\n\nresume_sounds([channel],[isstream])\n\n\n\n\nResume all sounds (or a stream) playing on a given channel.\n\n\nIf no channel is specified, then all sounds are resumed.\n\n\nsource\n\n\n#\n\n\nWeber.run_calibrate\n \n \nFunction\n.\n\n\nrun_calibrate()\n\n\nRuns a program that will allow you to play pure tones and adjust their level.\n\n\nThis program provides one means of calibrating the levels of sound in your experiment. Using a sound-level meter you can determine the dB SPL of each tone, and adjust the attenuation to achieve a desired sound level.\n\n\nsource", 
            "title": "Sound"
        }, 
        {
            "location": "/sound/#sound-creation", 
            "text": "#  Weber.tone     Function .  tone(freq,length,[sample_rate_Hz=44100],[phase=0])  Creates a pure tone of the given frequency and length (in seconds).  You can create an infinitely long tone (playable with  stream ) by passing a length of Inf, or leaving out the length entirely.  source  #  Weber.noise     Function .  noise(length,[sample_rate_Hz=44100])  Creates a period of white noise of the given length (in seconds).  You can create an infinite stream of noise (playable with  stream ) by passing a length of Inf, or leaving out the length entirely.  source  #  Weber.silence     Function .  silence(length,[sample_rate_Hz=44100])  Creates period of silence of the given length (in seconds).  source  #  Weber.harmonic_complex     Function .  harmonic_complex(f0,harmonics,amps,length,\n                 [sample_rate_Hz=44100],[phases=zeros(length(harmonics))])  Creates a harmonic complex of the given length, with the specified harmonics at the given amplitudes. This implementation is somewhat superior to simply summing a number of pure tones generated using  tone , because it avoids beating in the sound that may occur due floating point errors.  You can create an infinitely long complex (playable with  stream ) by passing a length of Inf, or leaving out the length entirely.  source  #  Weber.asstream     Function .  asstream(fn;[sample_rate_Hz=44100])  Converts the function  fn  into a sound stream.  The function  fn  should take a single argument\u2013the time in seconds from the start of the stream\u2013and should return a number between -1 and 1.  source  #  Weber.stream_unit     Function .  stream_unit()  Report the length in samples of each unit that all sound streams should generate.  source  #  Weber.sound     Function .  sound(x::Array,[cache=true];[sample_rate_Hz=44100])  Creates a sound object from an arbitrary array.  For real numbers, assumes 1 is the loudest and -1 the softest. Assumes 16-bit PCM for integers. The array should be 1d for mono signals, or an array of size (N,2) for stereo sounds.  When cache is set to true, sound will cache its results thus avoiding repeatedly creating a new sound for the same object.   Called Implicitly  This function is normally called implicitly in a call to  play(x) , where x is an arbitrary array, so it need not normally be called.   source  sound(x::SampleBuff,[cache=true])  Creates a sound object from a  SampleBuf  (from the  SampledSignals  module).  source  #  Weber.buffer     Function .  buffer(s::Sound)  Gets the  SampleBuf  associated with this sound (c.f.  SampledSignals  package).  source", 
            "title": "Sound Creation"
        }, 
        {
            "location": "/sound/#sound-manipulation", 
            "text": "#  Weber.highpass     Function .  highpass(x,high,[order=5],[sample_rate_Hz=samplerate(x)])  High-pass filter the sound (or stream) at the specified frequency.  Filtering uses a butterworth filter of the given order.  source  #  Weber.lowpass     Function .  lowpass(x,low,[order=5],[sample_rate_Hz=samplerate(x)])  Low-pass filter the sound (or stream) at the specified frequency.  Filtering uses a butterworth filter of the given order.  source  #  Weber.bandpass     Function .  bandpass(x,low,high,[order=5],[sample_rate_Hz=samplerate(x)])  Band-pass filter the sound (or stream) at the specified frequencies.  Filtering uses a butterworth filter of the given order.  source  #  Weber.ramp     Function .  ramp(x,[ramp_s=0.005];[sample_rate_Hz=samplerate(x)])  Applies a half cosine ramp to start and end of the sound.  Ramps prevent clicks at the start and end of sounds.  source  #  Weber.rampon     Function .  rampon(stream,[ramp_s=0.005])  Applies a half consine ramp to start of the sound or stream.  source  #  Weber.rampoff     Function .  rampoff(stream,[ramp_s=0.005],[after=0])  Applies a half consine ramp to the sound or stream after  after  seconds, ending the stream at that point.  source  #  Weber.fadeto     Function .  fadeto(stream,channel=1,transition=0.05)  Smoothly transition from the currently playing stream to another stream.  source  fadeto(sound1,sound2,overlap=0.05)  Create a sound that is a smooth transition from sound1 to sound2.  source  #  Weber.attenuate     Function .  attenuate(x,atten_dB)  Apply the given decibels of attenuation to the sound (or stream) relative to a power level of 1.  This function normalizes the sound to have a root mean squared value of 1 and then reduces the sound by a factor of $10^{-a/20}$, where $a$ =  atten_dB .  If  x  is a stream, attenuate takes an additional keyword argument  time_constant . This determines the time across which the sound is normalized to power 1, which defaults to 1 second.  source  #  Weber.mix     Function .  mix(x,y,...)  Mix several sounds (or streams) together so that they play at the same time.  source  #  Weber.mult     Function .  mult(x,y,...)  Mutliply several sounds (or streams) together. Typically used to apply an amplitude envelope.  source  #  Weber.envelope     Function .  envelope(mult,length,[sample_rate_Hz=44100])  Creates an evelope of a given multiplier and length (in seconds).  If mult = 0 this is the same as calling silence. This function is useful in conjunction with  fadeto  and  mult  when defining an envelope that changes in level. For example, the following will play a 1kHz tone for 1 second, which changes in volume halfway through to a softer level.  mult(tone(1000,1),fadeto(envelope(1,0.5),envelope(0.1,0.5)))  source", 
            "title": "Sound Manipulation"
        }, 
        {
            "location": "/sound/#playback", 
            "text": "#  Weber.setup_sound     Function .  setup_sound([sample_rate_Hz=44100],[num_channels=8],[queue_size=8],\n            [stream_unit=2^10])  Initialize format and capacity of audio playback.  This function is called automatically (using the default settings) the first time a  Sound  object is created (normally during  play  or  stream ).  It need not normally be called explicitly, unless you wish to change one of the default settings.  Sample Rate  Sample rate determines the maximum playable frequency (max freq is \u2248 sample_rate/2). Changing the sample rate from the default 44100 to a new value will also change the default sample rate sounds will be created at, to match this new sample rate.   There is no check for sampling rate  Upon playback, there is no check to ensure that the sample rate of a given sound is the same as that setup here, and no resampling of the sound is made, so it will play incorrectly if the sample rates differ. This minimizes the latency of audio playback.   Channel Number  The number of channels determines the number of sounds and streams that can be played concurrently. Note that discrete sounds and streams use a distinct set of channels.  Queue Size  Sounds can be queued to play ahead of time (using the  time  parameter of  play ). When you request that a sound be played it may be queued to play on a channel where a sound is already playing. The number of sounds that can be queued to play at once is determined by queue size. The number of channels times the queue size determines the number of sounds that you can queue up to play ahead of time.  Stream Unit  The stream unit determines the number of samples that are streamed at one time. Iterators to be used as streams should generate this many samples at a time.  If this value is two small for your hardware, streams will sound jumpy. However the latency for changing from one stream to another will increase as the stream unit increases.  source  #  Weber.play     Function .  play(x;[time=0.0],[channel=0])  Plays a sound (created via  sound ).  For convenience, play can also can be called on any object that can be turned into a sound (via  sound ).  This function returns immediately with the channel the sound is playing on. You may provide a specific channel that the sound plays on: only one sound can be played per channel. Normally it is unecessary to specify a channel, because an appriate channel is selected for you. However, pausing and resuming of sounds occurs on a per channel basis, so if you plan to pause a specific sound, you can do so by specifiying its channel.  If  time   0 , the sound plays at the given time (in seconds from epoch, or seconds from experiment start if an experiment is running), otherwise the sound plays as close to right now as is possible.  source  play(fn::Function)  Play the sound that's returned by calling  fn .  source  #  Weber.duration     Function .  duration(x)  Get the duration of the given sound.  source  #  Weber.stream     Function .  stream([itr | fn],channel=1)  Plays sounds continuously on a given channel by reading from the iterator  itr  whenever more data is required. The iterator should return objects that can be turned into sounds (via  sound ). The number of available streaming channels is determined by  setup_sound . The size, in samples, of each sound returned by this iterator should be equal to  stream_unit .  Alternatively a  fn  can be streamed: this transforms a previously streamed itr into a new iterator by calling  fn(itr) . If no stream already exists on the given channel,  fn  is passed the result of  countfrom() .  A stream stops playing if the iterator is finished. There can only be one stream per channel.  Streaming a new iterator on the same channel as another stream stops the older stream. The channels for  stream  are separate from the channels for  play . That is,  play(mysound,channel=1)  plays a sound on a channel separate from  stream(mystream,1) .   Streams are not precisely timed  Streams cannot occur at a precise time. Their latency is variable and depends on the value of  stream_unit() . Future versions of Weber will likely allow for precisely timed audio streams.   source  #  Weber.stop     Function .  stop(channel)  Stop the stream that is playing on the given channel.  source  #  SampledSignals.samplerate     Function .  samplerate([sound])  Report the sampling rate of the sound or of any object that can be turned into a sound.  If no sound is passed, the curent playback sampling rate is reported (as determiend by  setup_sound ).  The sampling rate of object determines how many samples per second are used to represent the sound. Objects that can be converted to sounds assume the sampling rate of the current hardware settings as defined by  setup_sound .  source  #  Weber.current_sound_latency     Function .  current_sound_latency()  Reports the current, minimum latency of audio playback.  The current latency depends on your hardware and software drivers. This estimate does not include the time it takes for a sound to travel from your sound card to speakers or headphones. This latency estimate is used internally by  play  to present sounds at accurate times.  source  #  Weber.pause_sounds     Function .  pause_sounds([channel],[isstream])  Pause all sounds (or a stream) playing on a given channel.  If no channel is specified, then all sounds are paused.  source  #  Weber.resume_sounds     Function .  resume_sounds([channel],[isstream])  Resume all sounds (or a stream) playing on a given channel.  If no channel is specified, then all sounds are resumed.  source  #  Weber.run_calibrate     Function .  run_calibrate()  Runs a program that will allow you to play pure tones and adjust their level.  This program provides one means of calibrating the levels of sound in your experiment. Using a sound-level meter you can determine the dB SPL of each tone, and adjust the attenuation to achieve a desired sound level.  source", 
            "title": "Playback"
        }, 
        {
            "location": "/video/", 
            "text": "Visual display is largely handled by the methods defined in \nImages\n. However, this objects must be prepared by Weber using \nvisual\n and then a call to \ndisplay\n is made to show the visual. The call to \nvisual\n is normally handled automatically for you when you call \nmoment\n.\n\n\n#\n\n\nBase.Multimedia.display\n \n \nFunction\n.\n\n\ndisplay(r::SDLRendered;kwds...)\n\n\n\n\nDisplays anything rendered by \nvisual\n onto the current experiment window.\n\n\nAny keyword arguments, available from \nvisual\n are also available here.  They overload the arguments as specified during visual (but do not change them).\n\n\ndisplay(x;kwds...)\n\n\n\n\nShort-hand for \ndisplay(visual(x);kwds...)\n. Commonly used when calling display as part of an trial moment. For example:\n\n\nmoment(0.5,display,\nHello, World!\n)\n\n\n\n\nThis code will show the text \"Hello, World!\" on the screen 0.5 seconds after the start of the previous moment.\n\n\n\n\nWarning\n\n\nAssuming your hardware and video drivers permit it, \ndisplay\n sycnrhonizes to the screen refresh rate so long as the experiment window uses accelerated graphics (true by default). The display of a visual can be no more accurate than that permitted by this refresh rate. In particular display can block for up to the length of an entire refresh cycle. If you want accurate timing in your experiment, make sure that there is nothing you want to occur immediately after calling display. If you want to display multiple visuals at once remember that you can compose visuals using the \n+\n operator, do not call display multiple times and expect these visual to all display at the same time (also note that the default behavior of visuals is to disappear when the next visual is shown).\n\n\n\n\nsource\n\n\ndisplay(fn::Function;kwds...)\n\n\n\n\nDisplay the visual returned by calling \nfn\n.\n\n\nsource\n\n\n#\n\n\nWeber.visual\n \n \nFunction\n.\n\n\nvisual(obj,[duration=0],[priority=0],keys...)\n\n\n\n\nRender an object, allowing \ndisplay\n to show the object in current experiment's window.\n\n\nArguments\n\n\n\n\nduration: A positive duration means the object is displayed for the given duration, otherwise the object displays until a new object is displayed.\n\n\npriority: Higher priority objects are always visible above lower priority ones. Newer objects display over same-priority older objects.\n\n\n\n\nIf coordinates are used they are in units of half screen widths (for x) and heights (for y), with (0,0) at the center of the screen.\n\n\n\n\nNote\n\n\nBy using using the \n+\n operator, multiple visual objects can be composed into one object, so that they are displayed together\n\n\n\n\nsource\n\n\nvisual(color,[duration=0],[priority=0])\n\n\n\n\nRender a color, across the entire screen.\n\n\nsource\n\n\nvisual(str::String, [font=nothing], [font_name=\narial\n], [size=32],\n       [color=colorant\nwhite\n],\n       [wrap_width=0.8],[clean_whitespace=true],[x=0],[y=0],[duration=0],\n       [priority=0])\n\n\n\n\nRender the given string as an image that can be displayed. An optional second argument can specify a font, loaded using the \nfont\n function.\n\n\nArguments\n\n\n\n\nwrap_width: the proporition of the screen that the text can utilize\n\n\n\n\nbefore wrapping.\n\n\n\n\nclean_whitespace: if true, replace all consecutive white space with a single space.\n\n\n\n\nsource\n\n\nvisual(img::Array, [x=0],[y=0],[duration=0],[priority=0])\n\n\n\n\nPrepare the color or gray scale image to be displayed to the screen.\n\n\nThis utilizes all the conventions in the \nImages\n package for representing images. Internally, real-number 2d arrays are interpreted as gray scale images, and real-number 3d arrays as an RGB image or RGBA image, depending on whether size(img,1) is of size 3 or 4. A 3d array with a size(img,1) \u2209 [3,4] results in an error.\n\n\nsource\n\n\n#\n\n\nWeber.instruct\n \n \nFunction\n.\n\n\ninstruct(str;keys...)\n\n\n\n\nPresents some instructions to the participant.\n\n\nThis adds \"(Hit spacebar to continue...)\" to the end of the text, and waits for the participant to press spacebar to move on. It records an \"instructions\" event to the data file.\n\n\nAny keyword arguments are passed onto to \nvisual\n, which can be used to adjust how the instructions are displayed.\n\n\nsource\n\n\n#\n\n\nWeber.font\n \n \nFunction\n.\n\n\nfont(name,size,[dirs=os_default],[color=colorant\nwhite\n])\n\n\n\n\nCreates an \nSDLFont\n object to be used for for rendering text as an image.\n\n\nBy default this function looks in the current directory and then an os specific default font directory for a font with the given name (case insensitive). You can specify a different list of directories using the \ndirs\n parameter.\n\n\nsource\n\n\n#\n\n\nWeber.window\n \n \nFunction\n.\n\n\nwindow([width=1024],[height=768];[fullscreen=true],[title=\nExperiment\n],\n       [accel=true])\n\n\n\n\nCreate a window to which various objects can be rendered. See the \nvisual\n method.\n\n\nsource\n\n\n#\n\n\nBase.close\n \n \nFunction\n.\n\n\nclose(win::SDLWindow)\n\n\n\n\nCloses a visible SDLWindow window.\n\n\nsource", 
            "title": "Video"
        }, 
        {
            "location": "/event/", 
            "text": "#\n\n\nWeber.@event\n \n \nMacro\n.\n\n\n@Weber.event type [name] \n: [ExpEvent or ExpEvent child]\n  [fields...]\nend\n\n\n\n\nMarks a concrete type as being an experiment event.\n\n\nThis tag is necessary to ensure that all watcher moments are properly precompiled. This macro adds the event to a list of concrete events for which each watcher method must have a precompiled method.\n\n\nsource\n\n\n#\n\n\nWeber.@key_str\n \n \nMacro\n.\n\n\nkey\nkeyname\n\n\n\n\n\nGenerate a key code, using a single character (e.g. key\"q\" or key\"]\"), or some special key name surrounded by colons (e.g. :escape:).\n\n\nNote that keys are orderd and you can list all implemented keys in order, using \nlistkeys\n. If you want to quickly see the name for a given button you can use \nrun_keycode_helper()\n.\n\n\n\n\nCreating Custom Keycodes\n\n\nExtensions to Weber can define their own keycodes. Such codes must but of some new type inheriting from \nWeber.Key\n, and can be added to the list of codes this macro can generate by updating the private constant \nWeber.str_to_code\n. See the section in the user guide on extensions for more details.\n\n\n\n\nsource\n\n\n#\n\n\nBase.Libc.time\n \n \nMethod\n.\n\n\ntime(e::ExpEvent)\n\n\n\n\nGet the time an event occured relative to the start of the experiment. Resolution is limited by an experiment's input_resolution (which can be specified upon initialization), and the response rate of the device. For instance, keyboards usually have a latency on the order of 20-30ms.\n\n\nsource\n\n\n#\n\n\nWeber.keycode\n \n \nFunction\n.\n\n\nkeycode(e::ExpEvent)\n\n\n\n\nReport the key code for this event, if there is one.\n\n\nsource\n\n\n#\n\n\nWeber.iskeydown\n \n \nFunction\n.\n\n\niskeydown(event,[key])\n\n\n\n\nEvalutes to true if the event indicates that the given key (or any key) was pressed down. (See \n@key_str\n)\n\n\niskeydown(key)\n\n\n\n\nReturns a function which tests if an event indicates the given key was pressed down.\n\n\nsource\n\n\n#\n\n\nWeber.iskeyup\n \n \nFunction\n.\n\n\niskeyup(event,[key])\n\n\n\n\nEvalutes to true if the event indicates that the given keyboard key (or any key) was released.  (See \n@key_str\n)\n\n\niskeyup(key)\n\n\n\n\nReturns a function which tests if an event indicates the given key was released.\n\n\nsource\n\n\n#\n\n\nWeber.listkeys\n \n \nFunction\n.\n\n\nlistkeys()\n\n\n\n\nLists all available key codes in order.\n\n\nAlso see \n@key_str\n.\n\n\nsource\n\n\n#\n\n\nWeber.run_keycode_helper\n \n \nFunction\n.\n\n\nrun_keycode_helper(;extensions=[])\n\n\n\n\nRuns a program that will display the keycode for each key that you press.\n\n\nsource\n\n\n#\n\n\nWeber.endofpause\n \n \nFunction\n.\n\n\nendofpause(event)\n\n\n\n\nEvaluates to true if the event indicates the end of a pause requested by the user.\n\n\nsource", 
            "title": "Events"
        }, 
        {
            "location": "/extend_ref/", 
            "text": "Available Extensions\n\n\nExtensions provide additional functionality.\n\n\nCurrently there are two extensions availble:\n\n\n\n\nWeberCedrus\n\n\nWeberDAQmx\n\n\n\n\n\n\nCreating Extensions\n\n\nThe following functions are used when \nextending experiments\n.\n\n\n\n\nFunctions operating over extensions\n\n\nThese functions operate directly on an \nExtendedExperiment\n.\n\n\n#\n\n\nBase.next\n \n \nMethod\n.\n\n\n next(experiment::ExtendedExperiment)\n\n\n\n\nGet the next extended version of this experiment.\n\n\nsource\n\n\n#\n\n\nDataStructures.top\n \n \nMethod\n.\n\n\ntop(experiment::Experiment)\n\n\n\n\nGet the the top-most extended verison for this experiment, if any.\n\n\nsource\n\n\n#\n\n\nWeber.extension\n \n \nMethod\n.\n\n\nextension(experiment::ExtendedExperiment)\n\n\n\n\nGet the extension object for this extended expeirment\n\n\nsource\n\n\n\n\nExtendable Private Functions\n\n\n#\n\n\nWeber.poll_events\n \n \nFunction\n.\n\n\n Weber.poll_events(callback,experiment,time)\n\n\n\n\nCall the function \ncallback\n, possibility multiple times, passing it an event object each time. The time at which the events are polled is passed, allowing this time to be stored with the event.\n\n\n\n\nWarning\n\n\nThis function should never be called directly by user code. A new method of this function can be implemented to extend Weber, allowing it to report new kinds events.\n\n\n\n\nsource\n\n\n\n\nPrivate Moment Functions\n\n\nNew \nWeber.SimpleMoment\n subtypes can define methods for the following functions to extend the runtime behavior of Weber.\n\n\n#\n\n\nWeber.prepare!\n \n \nFunction\n.\n\n\nWeber.prepare!(m,[last_moment])\n\n\n\n\nIf there is anything the moment needs to do before it occurs, it is done during \nprepare!\n. Prepare can be used to set up precise timing even when hardware latency is high, if that latency can be predicted, and accounted for. A moment's prepare! method is called just before the first non-zero pause between moments that occurs before this moment: in the simplest case, when this moment has a non-zero value for \ndelta_t\n, preapre! will occur \ndelta_t\n seconds before this moment. However, if several moments with no pause occur, prepare! will occur before all of those moments as well.\n\n\nPrepare accepts an optional second argument used to indicate the time, in seconds from the start of the experiemnt when this moment will begin. This argument may be Inf, indicating that it is not possible to predict when the moment will occur at this point, because the timing depends on some stateful information (e.g. a participant's response). It is accetable in this case to throw an error, explaining that this kind of moment must be able to know when it occurs sooner.\n\n\n\n\nNote\n\n\nThis method is part of the private interface for moments. It should not be called directly, but implemented as part of an extension. You need only extend the method taking a single arugment unless you intend to use this information during prepartion.\n\n\n\n\nsource\n\n\n#\n\n\nWeber.handle\n \n \nFunction\n.\n\n\nhandle(exp,queue,moment,to_handle)\n\n\n\n\nInternal method to handle the given moment object in a manner specific to the type of moment. The \nto_handle\n object is either a \nFloat64\n, indicating the current time, or it is an \nExpEvent\n indicating the event that just occured. A timed moment, for instance, will run when it recieves a \nFloat64\n value. The queue is a \nMomentQueue\n object, which has the same interface as the \nDequeue\n object (from the \nDataStructures\n package) but it is also iterable. Upon calling handle, \ntop(queue) == moment\n.\n\n\nHandle returns a boolean indicating whether the event was \"handled\" or not. If unhandled, the moment should remain on top of the queue. If returning true, handle should \nnormally\n remove the top moment from the queue. Exceptions exist (for instance, to allow for loops), but one does not normally need to implement custom moments that have such behavior.\n\n\n\n\nNote\n\n\nThis method is part of the private interface for moments. It should not be called directly, but implemented as part of an extension. It is called during the course of running an experiment.\n\n\n\n\nsource\n\n\n#\n\n\nWeber.moment_trace\n \n \nFunction\n.\n\n\nmoment_trace(m)\n\n\n\n\nReturns the stacktrace indicating where this moment was defined.\n\n\n\n\nNote\n\n\nThis method is part of the private interface for moments. It should not be called directly, but implemented as part of an extension.  You can get a stacktrace inside the function you define that constructs your custom moment using \nstacktrace()[2:end]\n.\n\n\n\n\nsource\n\n\n#\n\n\nWeber.delta_t\n \n \nFunction\n.\n\n\ndelta_t(m::AbstractMoment)\n\n\n\n\nReturns the time, since the start of the previous moment, at which this moment should begin. The default implementation returns zero.\n\n\n\n\nNote\n\n\nThis method is part of the private interface for moments. It should not be called directly, but implemented as part of an extension.\n\n\n\n\nsource", 
            "title": "Extensions"
        }, 
        {
            "location": "/extend_ref/#available-extensions", 
            "text": "Extensions provide additional functionality.  Currently there are two extensions availble:   WeberCedrus  WeberDAQmx", 
            "title": "Available Extensions"
        }, 
        {
            "location": "/extend_ref/#creating-extensions", 
            "text": "The following functions are used when  extending experiments .", 
            "title": "Creating Extensions"
        }, 
        {
            "location": "/extend_ref/#functions-operating-over-extensions", 
            "text": "These functions operate directly on an  ExtendedExperiment .  #  Base.next     Method .   next(experiment::ExtendedExperiment)  Get the next extended version of this experiment.  source  #  DataStructures.top     Method .  top(experiment::Experiment)  Get the the top-most extended verison for this experiment, if any.  source  #  Weber.extension     Method .  extension(experiment::ExtendedExperiment)  Get the extension object for this extended expeirment  source", 
            "title": "Functions operating over extensions"
        }, 
        {
            "location": "/extend_ref/#extendable-private-functions", 
            "text": "#  Weber.poll_events     Function .   Weber.poll_events(callback,experiment,time)  Call the function  callback , possibility multiple times, passing it an event object each time. The time at which the events are polled is passed, allowing this time to be stored with the event.   Warning  This function should never be called directly by user code. A new method of this function can be implemented to extend Weber, allowing it to report new kinds events.   source", 
            "title": "Extendable Private Functions"
        }, 
        {
            "location": "/extend_ref/#private-moment-functions", 
            "text": "New  Weber.SimpleMoment  subtypes can define methods for the following functions to extend the runtime behavior of Weber.  #  Weber.prepare!     Function .  Weber.prepare!(m,[last_moment])  If there is anything the moment needs to do before it occurs, it is done during  prepare! . Prepare can be used to set up precise timing even when hardware latency is high, if that latency can be predicted, and accounted for. A moment's prepare! method is called just before the first non-zero pause between moments that occurs before this moment: in the simplest case, when this moment has a non-zero value for  delta_t , preapre! will occur  delta_t  seconds before this moment. However, if several moments with no pause occur, prepare! will occur before all of those moments as well.  Prepare accepts an optional second argument used to indicate the time, in seconds from the start of the experiemnt when this moment will begin. This argument may be Inf, indicating that it is not possible to predict when the moment will occur at this point, because the timing depends on some stateful information (e.g. a participant's response). It is accetable in this case to throw an error, explaining that this kind of moment must be able to know when it occurs sooner.   Note  This method is part of the private interface for moments. It should not be called directly, but implemented as part of an extension. You need only extend the method taking a single arugment unless you intend to use this information during prepartion.   source  #  Weber.handle     Function .  handle(exp,queue,moment,to_handle)  Internal method to handle the given moment object in a manner specific to the type of moment. The  to_handle  object is either a  Float64 , indicating the current time, or it is an  ExpEvent  indicating the event that just occured. A timed moment, for instance, will run when it recieves a  Float64  value. The queue is a  MomentQueue  object, which has the same interface as the  Dequeue  object (from the  DataStructures  package) but it is also iterable. Upon calling handle,  top(queue) == moment .  Handle returns a boolean indicating whether the event was \"handled\" or not. If unhandled, the moment should remain on top of the queue. If returning true, handle should  normally  remove the top moment from the queue. Exceptions exist (for instance, to allow for loops), but one does not normally need to implement custom moments that have such behavior.   Note  This method is part of the private interface for moments. It should not be called directly, but implemented as part of an extension. It is called during the course of running an experiment.   source  #  Weber.moment_trace     Function .  moment_trace(m)  Returns the stacktrace indicating where this moment was defined.   Note  This method is part of the private interface for moments. It should not be called directly, but implemented as part of an extension.  You can get a stacktrace inside the function you define that constructs your custom moment using  stacktrace()[2:end] .   source  #  Weber.delta_t     Function .  delta_t(m::AbstractMoment)  Returns the time, since the start of the previous moment, at which this moment should begin. The default implementation returns zero.   Note  This method is part of the private interface for moments. It should not be called directly, but implemented as part of an extension.   source", 
            "title": "Private Moment Functions"
        }
    ]
}