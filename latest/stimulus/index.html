<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Stimulus Generation · Weber.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Weber.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><span class="toctext">User guide</span><ul><li><a class="toctext" href="../start/">Getting Started</a></li><li><a class="toctext" href="../trial_guide/">Trial Creation</a></li><li class="current"><a class="toctext" href>Stimulus Generation</a><ul class="internal"><li><a class="toctext" href="#Loading-a-file-1">Loading a file</a></li><li><a class="toctext" href="#Sound-Primitives-1">Sound Primitives</a></li><li><a class="toctext" href="#Sounds-are-arrays-1">Sounds are arrays</a></li><li><a class="toctext" href="#Stereo-Sounds-1">Stereo Sounds</a></li><li><a class="toctext" href="#Streams-1">Streams</a></li><li><a class="toctext" href="#Low-level-Sound/Stream-Generation-1">Low-level Sound/Stream Generation</a></li><li class="toplevel"><a class="toctext" href="#Images-1">Images</a></li><li><a class="toctext" href="#Loading-a-file-2">Loading a file</a></li><li><a class="toctext" href="#Image-Primitives-1">Image Primitives</a></li></ul></li><li><a class="toctext" href="../adaptive/">Adaptive Tracks</a></li><li><a class="toctext" href="../advanced/">Advanced Experiments</a></li><li><a class="toctext" href="../extend/">Extending Weber</a></li></ul></li><li><span class="toctext">Reference</span><ul><li><a class="toctext" href="../experiment/">Experiments</a></li><li><a class="toctext" href="../trials/">Trials</a></li><li><a class="toctext" href="../sound/">Sound</a></li><li><a class="toctext" href="../video/">Video</a></li><li><a class="toctext" href="../event/">Events</a></li><li><a class="toctext" href="../extend_ref/">Extensions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>User guide</li><li><a href>Stimulus Generation</a></li></ul><a class="edit-page" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/docs/src/stimulus.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Stimulus Generation</span><a class="fa fa-bars" href="#"></a></div></header><p>So far we have seen several examples of how to generate sounds and simple images (text). Here we&#39;ll cover stimulus generation in more detail.</p><h1><a class="nav-anchor" id="Sounds-1" href="#Sounds-1">Sounds</a></h1><p>Weber&#39;s primary focus is on psychoacoustics, so there are many methods for generating and manipulating sounds. There are two primary ways to create sound stimuli: loading a file and composing sound primitives.</p><h2><a class="nav-anchor" id="Loading-a-file-1" href="#Loading-a-file-1">Loading a file</a></h2><p>Generating stimuli by loading a file is easy. You simply play the given file, like so.</p><pre><code class="language-julia">addtrial(moment(play,&quot;mysound_file.wav&quot;))</code></pre><div class="admonition note"><div class="admonition-title">Sounds are cached</div><div class="admonition-text"><p>You can safely play the same file multiple times: the sound is cached, and will only load into memory once.</p></div></div><p>If you need to manipulate the sound before playing it, you can load it using <a href="../sound/#Weber.sound"><code>sound</code></a>.  For example, to remove any frequencies from <code>&quot;mysound_file.wav&quot;</code> above 400Hz before playing the sound, you could do the following.</p><pre><code class="language-julia">mysound = lowpass(sound(&quot;mysound_file.wav&quot;),400Hz)
addtrial(moment(play,mysound))</code></pre><h2><a class="nav-anchor" id="Sound-Primitives-1" href="#Sound-Primitives-1">Sound Primitives</a></h2><p>There are several primitives you can use to generate simple sounds directly in Weber. They are <a href="../sound/#Weber.tone"><code>tone</code></a> (to create pure tones), <a href="../sound/#Weber.noise"><code>noise</code></a> (to generate white noise), <a href="../sound/#Weber.silence"><code>silence</code></a> (for a silent period) and <a href="../sound/#Weber.harmonic_complex"><code>harmonic_complex</code></a> (to create multiple pure tones with integer frequency ratios).</p><p>These primitives can then be combined and manipulated to generate more interesting sounds. You can filter sounds (<a href="../sound/#Weber.bandpass"><code>bandpass</code></a>, <a href="../sound/#Weber.bandstop"><code>bandstop</code></a>, <a href="../sound/#Weber.lowpass"><code>lowpass</code></a>, <a href="../sound/#Weber.highpass"><code>highpass</code></a> and <a href="../sound/#Weber.lowpass"><code>lowpass</code></a>), mix them together (<a href="../sound/#Weber.mix"><code>mix</code></a>) and set an appropriate decibel level (<a href="../sound/#Weber.attenuate"><code>attenuate</code></a>). You can also manipulate the envelope of the sound (<a href="../sound/#Weber.ramp"><code>ramp</code></a>, <a href="../sound/#Weber.rampon"><code>rampon</code></a>, <a href="../sound/#Weber.rampoff"><code>rampoff</code></a>, <a href="../sound/#Weber.fadeto"><code>fadeto</code></a>, <a href="../sound/#Weber.envelope"><code>envelope</code></a> and <a href="../sound/#Weber.mult"><code>mult</code></a>).</p><p>For instance, to play a 1 kHz tone for 1 second inside of a noise with a notch from 0.5 to 1.5 kHz, with 5 dB SNR you could call the following.</p><pre><code class="language-julia">mysound = tone(1kHz,1s)
mysound = ramp(mysound)
mysound = attenuate(mysound,20)

mynoise = noise(1s)
mynoise = bandstop(mynoise,0.5kHz,1.5kHz)
mynoise = attenuate(mynoise,25)

addtrial(moment(play,mix(mysound,mynoise))</code></pre><p>Weber exports the macro <code>@&gt;</code> (from <a href="https://github.com/MikeInnes/Lazy.jl#macros">Lazy.jl</a>) to simplify this pattern. It is easiest to understand the macro by example: the below code yields the same result as the code above.</p><pre><code class="language-juila">mytone = @&gt; tone(1kHz,1s) ramp attenuate(20)
mynoise = @&gt; noise(1s) bandstop(0.5kHz,1.5kHz) attenuate(25)
addtrial(moment(play, mix(mytone,mynoise)))</code></pre><p>Weber also exports <code>@&gt;&gt;</code>, and <code>@_</code> (refer to <a href="https://github.com/MikeInnes/Lazy.jl#macros">Lazy.jl</a> for details).</p><h2><a class="nav-anchor" id="Sounds-are-arrays-1" href="#Sounds-are-arrays-1">Sounds are arrays</a></h2><p>Sounds can be manipulated in the same way that any array can be manipulated in Julia, with some additional support for indexing sounds using time units. For instance, to get the first 5 seconds of a sound you can do the following.</p><pre><code class="language-julia">mytone = tone(1kHz,10s)
mytone[0s .. 5s]</code></pre><p>Furthermore, we can concatenate multiple sounds, to play them in sequence. The following code plays two tones in sequence, with a 100 ms gap between them.</p><pre><code class="language-julia">interval = [tone(400Hz,50ms); silence(100ms); tone(400Hz * 2^(5/12),50ms)]
addtrial(moment(play,interval))</code></pre><h2><a class="nav-anchor" id="Stereo-Sounds-1" href="#Stereo-Sounds-1">Stereo Sounds</a></h2><p>You can create stereo sounds with using <a href="../sound/#Weber.leftright"><code>leftright</code></a>, and reference their left and right channel sound using <code>:left</code> or <code>:right</code> as a second index, like so.</p><pre><code class="language-julia">stereo_sound = leftright(tone(1kHz,2s),tone(2kHz,2s))
addtrial(moment(play,stereo_sound[:,:left],
         moment(2s,play,stereo_sound[:,:right]))</code></pre><p>The functions <a href="../sound/#Weber.left"><code>left</code></a> and <a href="../sound/#Weber.right"><code>right</code></a> serve the same purpose, but can also operate on streams.</p><h2><a class="nav-anchor" id="Streams-1" href="#Streams-1">Streams</a></h2><p>In addition to the discrete sounds that have been discussed so far, Weber also supports sound streams. Streams are arbitrarily long: you need not decide when they should stop until after they start playing. All of the primitives described so far can apply to streams, except that streams cannot be indexed.</p><div class="admonition note"><div class="admonition-title">Streaming operations are lazy</div><div class="admonition-text"><p>All manipulations of streams are lazy: they are applied just as the stream is played. The more operators you apply to a stream the more processing that has to occur during playback. If you have a particularly complicated stream you may have to increase streaming latency by changing the <code>stream_unit</code> parameter of <a href="../sound/#Weber.setup_sound"><code>setup_sound</code></a>, or consider an alternative approach (e.g. <a href="../sound/#Weber.audible"><code>audible</code></a>).</p></div></div><p>To create a stream you can use one of the standard primitives, leaving out the length parameter. For example, the following will play a 1 kHz pure tone until Weber quits.</p><pre><code class="language-julia">addtrial(moment(play,tone(1kHz)))</code></pre><p>Streams always play on a specific stream channel, so if you want to stop the stream at some point you can request that the channel stop. The following plays a pure tone until the experiment participant hits spacebar.</p><pre><code class="language-julia">addtrial(moment(play,tone(1kHz),channel=1),
         await_response(iskeydown(key&quot;:space:&quot;)),
         moment(stop,1))</code></pre><p>Streams can be manipulated as they are playing as well, so if you wanted to have a ramp at the start and end of the stream to avoid clicks, you could change the example above, to the following.</p><pre><code class="language-julia">ongoing_tone = @&gt; tone(1kHz) rampon
addtrial(moment(play,ongoing_tone,channel=1),
         await_response(iskeydown(key&quot;:space:&quot;)),
         moment(play,rampoff(ongoing_tone),channel=1))</code></pre><div class="admonition warning"><div class="admonition-title">Streams are stateful</div><div class="admonition-text"><p>This example also demonstrates the stateful nature of streams. Once some part of a stream has been played it is forever consumed, and cannot be played again. After the stream is played, subsequent modifications only apply to unplayed frames of the stream. <em>BEWARE</em>: this means that you cannot play two different modifications of the same stream.</p></div></div><p>Just as with any moment, these manipulations to streams can be precisely timed. The following will turn the sound off precisely 1 second after the space key is pressed.</p><pre><code class="language-julia">ongoing_tone = @&gt; tone(1kHz) rampon
addtrial(moment(play,ongoing_tone,channel=1),
         await_response(iskeydown(key&quot;:space:&quot;)),
         moment(1s,play,rampoff(ongoing_tone),channel=1))</code></pre><p>If you wish to turn the entirety of a finite stream into a sound, you can use <a href="../sound/#Weber.sound"><code>sound</code></a>. You can also grab the next section of an infinite stream using <a href="../sound/#Weber.sound"><code>sound</code></a> if you provide a second parameter specifying the length of the stream you want to turn into a sound.</p><p>Some manipulations of streams require that the stream be treated as a sound. You can modify individual sound segments as they play from the stream using <a href="../sound/#Weber.audiofn"><code>audiofn</code></a>. (Calling <a href="../sound/#Weber.audiofn"><code>audiofn</code></a> on a sound, rather than a stream, is the same as applying the given function to the sound directly).</p><h2><a class="nav-anchor" id="Low-level-Sound/Stream-Generation-1" href="#Low-level-Sound/Stream-Generation-1">Low-level Sound/Stream Generation</a></h2><p>Finally, if none of the functions above suit your purposes for generating sounds or streams, you can use the function <a href="../sound/#Weber.audible"><code>audible</code></a>, which can be used to generate any arbitrary sound or stream you want. Please refer to the source code for <a href="../sound/#Weber.tone"><code>tone</code></a> and <a href="../sound/#Weber.noise"><code>noise</code></a> to see examples of the two ways to use this function.</p><h1><a class="nav-anchor" id="Images-1" href="#Images-1">Images</a></h1><p>Images can also be generated by either displaying a file or generating image primitives.</p><h2><a class="nav-anchor" id="Loading-a-file-2" href="#Loading-a-file-2">Loading a file</a></h2><p>Displaying an image file is a simple matter of calling display on that file.</p><pre><code class="language-julia">addtrial(moment(display,&quot;myimage.png&quot;))</code></pre><div class="admonition note"><div class="admonition-title">Images are cached</div><div class="admonition-text"><p>You can safely display the same file multiple times: the image is cached, and will only load into memory once.</p></div></div><p>Analogous to sounds, if you need to manipulate the image before displaying it you can load it using <a href="../video/#Weber.visual"><code>visual</code></a>. For example, the following displays the upper quarter of an image.</p><pre><code class="language-julia">myimage = visual(&quot;myimage.png&quot;)
addtrial(moment(display,myimage[1:div(end,2),1:div(end,2)]))</code></pre><p>Note that displaying a string can also result in that string being printed to the screen. Weber determines the difference between a string you want to display and a string referring to an image file by looking at the end of the string. If the string ends in a file type (.bmp, .jpeg, .png, etc...), Weber assumes it is an image file you want to load, otherwise it assumes it is a string you want to print to the screen. </p><h2><a class="nav-anchor" id="Image-Primitives-1" href="#Image-Primitives-1">Image Primitives</a></h2><p>Support for generating images in Weber comes from <a href="https://github.com/JuliaImages/Images.jl">Images.jl</a>. In this package, images are represented as arrays. For instance, to display a white 100x100 pixel box next to a black 100x100 pixel box, we could do the following.</p><pre><code class="language-julia">addtrial(moment(display,[ones(100,100); zeros(100,100)]))</code></pre><p>For more information about generating images please refer to the <a href="http://juliaimages.github.io/latest/">JuliaImages</a> documentation.</p><footer><hr/><a class="previous" href="../trial_guide/"><span class="direction">Previous</span><span class="title">Trial Creation</span></a><a class="next" href="../adaptive/"><span class="direction">Next</span><span class="title">Adaptive Tracks</span></a></footer></article></body></html>
