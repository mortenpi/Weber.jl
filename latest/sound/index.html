<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sound · Weber.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Weber.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><span class="toctext">User guide</span><ul><li><a class="toctext" href="../start/">Getting Started</a></li><li><a class="toctext" href="../trial_guide/">Trial Creation</a></li><li><a class="toctext" href="../stimulus/">Stimulus Generation</a></li><li><a class="toctext" href="../adaptive/">Adaptive Tracks</a></li><li><a class="toctext" href="../advanced/">Advanced Experiments</a></li><li><a class="toctext" href="../extend/">Extending Weber</a></li></ul></li><li><span class="toctext">Reference</span><ul><li><a class="toctext" href="../experiment/">Experiments</a></li><li><a class="toctext" href="../trials/">Trials</a></li><li class="current"><a class="toctext" href>Sound</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Sound-Manipulation-1">Sound Manipulation</a></li><li class="toplevel"><a class="toctext" href="#Playback-1">Playback</a></li></ul></li><li><a class="toctext" href="../video/">Video</a></li><li><a class="toctext" href="../event/">Events</a></li><li><a class="toctext" href="../extend_ref/">Extensions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Reference</li><li><a href>Sound</a></li></ul><a class="edit-page" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/docs/src/sound.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Sound</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Sound-Creation-1" href="#Sound-Creation-1">Sound Creation</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.sound" href="#Weber.sound"><code>Weber.sound</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sound(x::Array,[cache=true];[sample_rate=samplerate()])</code></pre><p>Creates a sound object from an arbitrary array.</p><p>Assumes 1 is the loudest and -1 the softest. The array should be 1d for mono signals, or an array of size (N,2) for stereo sounds.</p><p>When cache is set to true, sound will cache its results thus avoiding repeatedly creating a new sound for the same object.</p><div class="admonition note"><div class="admonition-title">Called Implicitly</div><div class="admonition-text"><p>This function is normally called implicitly in a call to <code>play(x)</code>, so it need not normally be called directly.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/sound.jl#L381-L397">source</a><br/><div><pre><code class="language-none">sound(file,[cache=true];[sample_rate=samplerate(file)])</code></pre><p>Load a specified file as a sound.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/sound.jl#L482-L486">source</a><br/><div><pre><code class="language-none">sound(stream,[len])</code></pre><p>Consume some amount of the stream, converting it to a finite <code>sound</code>.</p><p>If left unspecified, the entire stream is consumed.  Infinite streams throw an error.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/stream.jl#L34-L41">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.tone" href="#Weber.tone"><code>Weber.tone</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">tone(freq,length;[sample_rate=samplerate()],[phase=0])</code></pre><p>Creates a pure tone of the given frequency and length (in seconds).</p><p>You can create an infinitely long tone by passing a length of Inf, or leaving out the length entirely.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/audio.jl#L74-L81">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.noise" href="#Weber.noise"><code>Weber.noise</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">noise(length=Inf;[sample_rate_Hz=44100],[rng=global RNG])</code></pre><p>Creates a period of white noise of the given length (in seconds).</p><p>You can create an infinite stream of noise by passing a length of Inf, or leaving out the length entirely.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/audio.jl#L61-L68">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.silence" href="#Weber.silence"><code>Weber.silence</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">silence(length;[sample_rate=samplerate()])</code></pre><p>Creates period of silence of the given length (in seconds).</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/audio.jl#L34-L38">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.harmonic_complex" href="#Weber.harmonic_complex"><code>Weber.harmonic_complex</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">harmonic_complex(f0,harmonics,amps,length,
                 [sample_rate=samplerate()],[phases=zeros(length(harmonics))])</code></pre><p>Creates a harmonic complex of the given length, with the specified harmonics at the given amplitudes. This implementation is somewhat superior to simply summing a number of pure tones generated using <code>tone</code>, because it avoids beating in the sound that may occur due floating point errors.</p><p>You can create an infinitely long complex by passing a length of Inf, or leaving out the length entirely.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/audio.jl#L111-L122">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.audible" href="#Weber.audible"><code>Weber.audible</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">audible(fn,len=Inf,asseconds=true;[sample_rate=samplerate(),eltype=Float64])</code></pre><p>Creates monaural sound where <code>fn(t)</code> returns the amplitudes for a given <code>Range</code> of time points.</p><p>If <code>asseconds</code> is false, <code>audible</code> creates a monaural sound where <code>fn(i)</code> returns the amplitudes for a given <code>Range</code> of sample indices.</p><p>The function <code>fn</code> should always return elements of type <code>eltype</code>.</p><p>If an infinite length is specified, a stream is created rather than a sound.</p><p>The function <code>fn</code> need not be pure and it can be safely assumed that <code>fn</code> will only be called for a given range of indices once. While indices and times passed to <code>fn</code> normally begin from 0 and 1, respectively, this is not always the case.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/stream.jl#L58-L74">source</a><br/></section><h1><a class="nav-anchor" id="Sound-Manipulation-1" href="#Sound-Manipulation-1">Sound Manipulation</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.highpass" href="#Weber.highpass"><code>Weber.highpass</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">highpass(x,high,[order=5],[sample_rate_Hz=samplerate(x)])</code></pre><p>High-pass filter the sound (or stream) at the specified frequency.</p><p>Filtering uses a butterworth filter of the given order.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/audio.jl#L159-L165">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.lowpass" href="#Weber.lowpass"><code>Weber.lowpass</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">lowpass(x,low,[order=5],[sample_rate_Hz=samplerate(x)])</code></pre><p>Low-pass filter the sound (or stream) at the specified frequency.</p><p>Filtering uses a butterworth filter of the given order.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/audio.jl#L150-L156">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.bandpass" href="#Weber.bandpass"><code>Weber.bandpass</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">bandpass(x,low,high;[order=5])</code></pre><p>Band-pass filter the sound (or stream) at the specified frequencies.</p><p>Filtering uses a butterworth filter of the given order.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/audio.jl#L132-L138">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.bandstop" href="#Weber.bandstop"><code>Weber.bandstop</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">bandstop(x,low,high,[order=5],[sample_rate_Hz=samplerate(x)])</code></pre><p>Band-stop filter of the sound (or stream) at the specified frequencies.</p><p>Filtering uses a butterworth filter of the given order.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/audio.jl#L141-L147">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.ramp" href="#Weber.ramp"><code>Weber.ramp</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ramp(x,[length=5ms])</code></pre><p>Applies a half cosine ramp to start and end of the sound.</p><p>Ramps prevent clicks at the start and end of sounds.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/audio.jl#L186-L192">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.rampon" href="#Weber.rampon"><code>Weber.rampon</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rampon(stream,[len=5ms])</code></pre><p>Applies a half consine ramp to start of the sound or stream.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/audio.jl#L211-L215">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.rampoff" href="#Weber.rampoff"><code>Weber.rampoff</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rampoff(stream,[len=5ms],[after=0s])</code></pre><p>Applies a half consine ramp to the end sound, or to a stream.</p><p>For streams, you may specify how many seconds after the call to rampff the stream should end.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/audio.jl#L229-L236">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.fadeto" href="#Weber.fadeto"><code>Weber.fadeto</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">fadeto(stream,channel=1,transition=0.05)</code></pre><p>A smooth transition from the currently playing stream to another stream.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/audio.jl#L265-L269">source</a><br/><div><pre><code class="language-none">fadeto(sound1,sound2,overlap=0.05)</code></pre><p>A smooth transition from sound1 to sound2, overlapping the end of sound1 and the start of sound2 by <code>overlap</code> (in seconds).</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/audio.jl#L279-L284">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.attenuate" href="#Weber.attenuate"><code>Weber.attenuate</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">attenuate(x,atten_dB;[time_constant])</code></pre><p>Apply the given decibels of attenuation to the sound (or stream) relative to a power level of 1.</p><p>This function normalizes the sound to have a root mean squared value of 1 and then reduces the sound by a factor of <span>$10^{-a/20}$</span>, where <span>$a$</span> = <code>atten_dB</code>.</p><p>The keyword argument <code>time_constant</code> determines the time across which the sound is normalized to power 1, which, for sounds, defaults to the entire sound and, for streams, defaults to 1 second.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/audio.jl#L290-L302">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.mix" href="#Weber.mix"><code>Weber.mix</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">mix(x,y,...)</code></pre><p>mix several sounds (or streams) together so that they play at the same time.</p><p>Unlike normal addition, this acts as if each sound is padded with zeros at the end so that the lengths of all sounds match.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/audio.jl#L13-L20">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.mult" href="#Weber.mult"><code>Weber.mult</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">mult(x,y,...)</code></pre><p>Mutliply several sounds (or streams) together. Typically used to apply an amplitude envelope.</p><p>Unlike normal multiplication, this acts as if each sound is padded with ones at the end so that the lengths of all sounds match.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/audio.jl#L23-L31">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.envelope" href="#Weber.envelope"><code>Weber.envelope</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">envelope(mult,length;[sample_rate_Hz=44100])</code></pre><p>creates an envelope of a given multiplier and length (in seconds).</p><p>If mult = 0 this is the same as calling <a href="#Weber.silence"><code>silence</code></a>. This function is useful in conjunction with <a href="#Weber.fadeto"><code>fadeto</code></a> and <a href="#Weber.mult"><code>mult</code></a> when defining an envelope that changes in level. For example, the following will play a 1kHz tone for 1 second, which changes in volume halfway through to a softer level.</p><pre><code class="language-none">mult(tone(1000,1),fadeto(envelope(1,0.5),envelope(0.1,0.5)))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/audio.jl#L43-L56">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.duration" href="#Weber.duration"><code>Weber.duration</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">duration(x)</code></pre><p>Get the duration of the given sound in seconds.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/sound.jl#L80-L84">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.nchannels-Tuple{Weber.Sound}" href="#Weber.nchannels-Tuple{Weber.Sound}"><code>Weber.nchannels</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">nchannels(sound)</code></pre><p>Return the number of channels (1 for mono, 2 for stereo) in this sound.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/sound.jl#L87-L91">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Distributions.nsamples-Tuple{Weber.Sound}" href="#Distributions.nsamples-Tuple{Weber.Sound}"><code>Distributions.nsamples</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">nsamples(sound::Sound)</code></pre><p>Returns the number of samples in the sound.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/sound.jl#L94-L98">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.audiofn" href="#Weber.audiofn"><code>Weber.audiofn</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">audiofn(fn,x)</code></pre><p>Apply <code>fn</code> to x for both sounds and streams.</p><p>For a sound this is the same as calling <code>fn(x)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/sound.jl#L521-L527">source</a><br/><div><p>For a stream, <code>fn</code> will be applied to each unit of sound as it is requested from the stream.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/stream.jl#L168-L171">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.leftright" href="#Weber.leftright"><code>Weber.leftright</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">leftright(left,right)</code></pre><p>Create a stereo sound from two vectors or two monaural sounds.</p><p>For vectors, one can specify a sample_rate other than the default, if desired.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/sound.jl#L496-L503">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.left" href="#Weber.left"><code>Weber.left</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">left(sound::Sound)</code></pre><p>Extract the left channel a stereo sound or stream.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/sound.jl#L167-L171">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.right" href="#Weber.right"><code>Weber.right</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">right(sound::Sound)</code></pre><p>Extract the right channel of a stereo sound or stream.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/sound.jl#L180-L184">source</a><br/></section><h1><a class="nav-anchor" id="Playback-1" href="#Playback-1">Playback</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.play" href="#Weber.play"><code>Weber.play</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">play(x;[channel=0])</code></pre><p>Plays a sound (created via <a href="#Weber.sound"><code>sound</code></a>).</p><p>For convenience, play can also can be called on any object that can be turned into a sound (via <code>sound</code>).</p><p>This function returns immediately with the channel the sound is playing on. You may provide a specific channel that the sound plays on: only one sound can be played per channel. Normally it is unecessary to specify a channel, because an appropriate channel is selected for you. However, pausing and resuming of sounds occurs on a per channel basis, so if you plan to pause a specific sound, you can do so by specifying its channel.</p><p><strong>Streams</strong></p><p>Play can also be used to present a continuous stream of sound.  In this case, the channel defaults to channel 1 (there is no automatic selection of channels for streams). Streams are usually created by specifying an infinite length during sound generation using <a href="#Weber.tone"><code>tone</code></a>, <a href="#Weber.noise"><code>noise</code></a>, <a href="#Weber.harmonic_complex"><code>harmonic_complex</code></a> or <a href="#Weber.audible"><code>audible</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/playback.jl#L170-L192">source</a><br/><div><pre><code class="language-none">play(fn::Function)</code></pre><p>Play the sound that&#39;s returned by calling <code>fn</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/playback.jl#L259-L263">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.setup_sound" href="#Weber.setup_sound"><code>Weber.setup_sound</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">setup_sound(;[sample_rate=samplerate()],[num_channels=8],[queue_size=8],
            [stream_unit=2^11])</code></pre><p>Initialize format and capacity of audio playback.</p><p>This function is called automatically (using the default settings) the first time a <code>Sound</code> object is created (e.g. during <a href="#Weber.play"><code>play</code></a>).  It need not normally be called explicitly, unless you wish to change one of the default settings.</p><p><strong>Sample Rate</strong></p><p>Sample rate determines the maximum playable frequency (max freq is ≈ sample_rate/2). Changing the sample rate from the default 44100 to a new value will also change the default sample rate sounds will be created at, to match this new sample rate.</p><p><strong>Channel Number</strong></p><p>The number of channels determines the number of sounds and streams that can be played concurrently. Note that discrete sounds and streams use a distinct set of channels.</p><p><strong>Queue Size</strong></p><p>Sounds can be queued to play ahead of time (using the <code>time</code> parameter of <a href="#Weber.play"><code>play</code></a>). When you request that a sound be played it may be queued to play on a channel where a sound is already playing. The number of sounds that can be queued to play at once is determined by queue size. The number of channels times the queue size determines the number of sounds that you can queue up to play ahead of time.</p><p><strong>Stream Unit</strong></p><p>The stream unit determines the number of samples that are streamed at one time. If this value is too small for your hardware, streams will sound jumpy. However the latency of streams will increase as the stream unit increases.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/playback.jl#L73-L111">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.playable" href="#Weber.playable"><code>Weber.playable</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">playable(x,[cache=true],[sample_rate=samplerate()])</code></pre><p>Prepare a sound or stream to be played.</p><p>A call to <code>playable</code> will ensure the sound is in the format required by <a href="#Weber.play"><code>play</code></a>.  This automatically calls <a href="#Weber.sound"><code>sound</code></a> on <code>x</code> if it not already appear to be a sound or a stream.</p><div class="admonition note"><div class="admonition-title">Called Implicitly</div><div class="admonition-text"><p>This need not be called explicitly, as play will call it for you, if need be.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/sound.jl#L431-L443">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DSP.Filters.resample-Tuple{Weber.Sound,Any}" href="#DSP.Filters.resample-Tuple{Weber.Sound,Any}"><code>DSP.Filters.resample</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">resample(x::Sound,samplerate)</code></pre><p>Returns a new sound representing the sound <code>x</code> at the given sampling rate.</p><p>You will loose all frequencies in the sound above samplerate/2. Resampling occurs automatically when you call <a href="#Weber.sound"><code>sound</code></a>–which is called inside <a href="#Weber.play"><code>play</code></a>–anytime the sampling rate of the sound and the current audio playback settings (determined by <a href="#Weber.setup_sound"><code>setup_sound</code></a>) are not the same.</p><p>To avoid automatic resampling you can either create sounds at the appropriate sampling rate, as determined by <a href="#SampledSignals.samplerate"><code>samplerate</code></a> (recommended), or change the sampling rate initialized during <a href="#Weber.setup_sound"><code>setup_sound</code></a> (not recommended).</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/sound.jl#L344-L357">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.stop" href="#Weber.stop"><code>Weber.stop</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">stop(channel)</code></pre><p>Stop the stream that is playing on the given channel.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/playback.jl#L343-L347">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SampledSignals.samplerate" href="#SampledSignals.samplerate"><code>SampledSignals.samplerate</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">samplerate([sound])</code></pre><p>Report the sampling rate of the sound or of any object that can be turned into a sound.</p><p>The sampling rate of an object determines how many samples per second are used to represent the sound. Objects that can be converted to sounds are assumed to be at the sampling rate of the current hardware settings as defined by <a href="#Weber.setup_sound"><code>setup_sound</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/sound.jl#L48-L58">source</a><br/><div><p>With no argument samplerate reports the current playback sample rate, as defined by <a href="#Weber.setup_sound"><code>setup_sound</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/playback.jl#L31-L34">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.current_sound_latency" href="#Weber.current_sound_latency"><code>Weber.current_sound_latency</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">current_sound_latency()</code></pre><p>Reports the current, minimum latency of audio playback.</p><p>The current latency depends on your hardware and software drivers. This estimate does not include the time it takes for a sound to travel from your sound card to speakers or headphones. This latency estimate is used internally by <a href="#Weber.play"><code>play</code></a> to present sounds at accurate times.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/playback.jl#L155-L164">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.pause_sounds" href="#Weber.pause_sounds"><code>Weber.pause_sounds</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">pause_sounds([channel],[isstream])</code></pre><p>Pause all sounds (or a stream) playing on a given channel.</p><p>If no channel is specified, then all sounds are paused.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/playback.jl#L393-L399">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.resume_sounds" href="#Weber.resume_sounds"><code>Weber.resume_sounds</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">resume_sounds([channel],[isstream])</code></pre><p>Resume all sounds (or a stream) playing on a given channel.</p><p>If no channel is specified, then all sounds are resumed.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/playback.jl#L409-L415">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.run_calibrate" href="#Weber.run_calibrate"><code>Weber.run_calibrate</code></a> — <span class="docstring-category">Function</span>.</div><div><p>run_calibrate()</p><p>Runs a program that will allow you to play pure tones and adjust their level.</p><p>This program provides one means of calibrating the levels of sound in your experiment. Using a sound-level meter you can determine the dB SPL of each tone, and adjust the attenuation to achieve a desired sound level.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/helpers.jl#L28-L36">source</a><br/></section><footer><hr/><a class="previous" href="../trials/"><span class="direction">Previous</span><span class="title">Trials</span></a><a class="next" href="../video/"><span class="direction">Next</span><span class="title">Video</span></a></footer></article></body></html>
