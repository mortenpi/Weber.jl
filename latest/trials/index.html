<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Trials · Weber.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Weber.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><span class="toctext">User guide</span><ul><li><a class="toctext" href="../start/">Getting Started</a></li><li><a class="toctext" href="../trial_guide/">Trial Creation</a></li><li><a class="toctext" href="../stimulus/">Stimulus Generation</a></li><li><a class="toctext" href="../adaptive/">Adaptive Tracks</a></li><li><a class="toctext" href="../advanced/">Advanced Experiments</a></li><li><a class="toctext" href="../extend/">Extending Weber</a></li></ul></li><li><span class="toctext">Reference</span><ul><li><a class="toctext" href="../experiment/">Experiments</a></li><li class="current"><a class="toctext" href>Trials</a><ul class="internal"></ul></li><li><a class="toctext" href="../sound/">Sound</a></li><li><a class="toctext" href="../video/">Video</a></li><li><a class="toctext" href="../event/">Events</a></li><li><a class="toctext" href="../extend_ref/">Extensions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Reference</li><li><a href>Trials</a></li></ul><a class="edit-page" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/docs/src/trials.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Trials</span><a class="fa fa-bars" href="#"></a></div></header><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.addtrial" href="#Weber.addtrial"><code>Weber.addtrial</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">addtrial(moments...)</code></pre><p>Adds a trial to the experiment, consisting of the specified moments.</p><p>Each trial records a &quot;trial_start&quot; code, and increments a counter tracking the number of trials, and (normally) an offset counter. These two numbers are reported on every line of the resulting data file (see <a href="#Weber.record"><code>record</code></a>). They can be retrieved using <a href="../experiment/#Weber.trial"><code>Weber.trial()</code></a> and <a href="../experiment/#Weber.offset"><code>Weber.offset()</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/trial.jl#L290-L299">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.addbreak" href="#Weber.addbreak"><code>Weber.addbreak</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">addbreak(moments...)</code></pre><p>Identical to <a href="#Weber.addpractice"><code>addpractice</code></a>, but records &quot;break_start&quot; instead of &quot;practice_start&quot;.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/trial.jl#L334-L338">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.addbreak_every" href="#Weber.addbreak_every"><code>Weber.addbreak_every</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">addbreak_every(n,total,
               [response=key&quot;:space:&quot;],[response_str=&quot;the spacebar&quot;])</code></pre><p>Adds a break every <code>n</code> times this event is added given a known number of total such events.</p><p>By default this waits for the user to hit spacebar to move on.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/primitives.jl#L52-L60">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.addpractice" href="#Weber.addpractice"><code>Weber.addpractice</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">addpractice(moments...)</code></pre><p>Identical to <a href="#Weber.addtrial"><code>addtrial</code></a>, except that it does not incriment the trial count, and records a &quot;practice_start&quot; instead of &quot;trial_start&quot; code.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/trial.jl#L319-L324">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.moment" href="#Weber.moment"><code>Weber.moment</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">moment([delta_t],[fn],args...;keys...)</code></pre><p>Create a moment that occurs <code>delta_t</code> (default 0) seconds after the onset of the previous moment, running the specified function.</p><p>The function <code>fn</code> is passed the arguments specified in <code>args</code> and <code>keys</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/trial.jl#L348-L355">source</a><br/><div><pre><code class="language-none">moment(moments...)
moment(moments::Array)</code></pre><p>Create a single, compound moment by concatentating several moments togethor.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/trial.jl#L387-L392">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.response" href="#Weber.response"><code>Weber.response</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">response(key1 =&gt; response1,key2 =&gt; response2,...;kwds...)</code></pre><p>Create a watcher moment that records press of <code>key[n]</code> as <code>record(response[n];kwds...)</code>.</p><p>See <a href="#Weber.record"><code>record</code></a> for more details on how events are recorded.</p><p>When a key is pressed down, the record event occurs. Key releases are also recorded, but are suffixed, by default, with &quot;_up&quot;. This suffix can be changed using the <code>keyup_suffix</code> keyword argument.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/primitives.jl#L7-L18">source</a><br/><div><pre><code class="language-none">response([fn],adapter,[key1] =&gt; [&quot;resp1&quot;],...;correct=[resp],
         [show_feedback=true],
         [feedback=Dict(true=&gt;&quot;Correct&quot;,false=&gt;&quot;Wrong!&quot;)]
         keys...)</code></pre><p>Record a response in a n-alternative forced choice task and update an adapter.</p><p>The first response recieved is interpreted as the actual response. Subsequent responses will be recorded, without a delta or correct value set, and appending &quot;late_&quot; to the specified response string.</p><p><strong>Function Callback</strong></p><p>Optionally, upon participant response, <code>fn</code> receives two arguments: the provided response, and the correct response.</p><p><strong>Keyword Arguments</strong></p><ul><li><p><code>correct</code> the response string corresponding to the correct response</p></li><li><p><code>show_feedback</code> (default = true): whether to show feedback to the participant after they respond.</p></li><li><p><code>feedback</code> the text to display to a participant when they are correct (for the true key, defaults to &quot;Correct!&quot;) or incorrect (for the false key, defaults to &quot;Wrong!&quot;).</p></li></ul><p>Any additional keyword arguments are added as column values when the response is recorded.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/adaptive.jl#L35-L65">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.await_response" href="#Weber.await_response"><code>Weber.await_response</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">await_response(isresponse;[atleast=0.0])</code></pre><p>This moment starts when the <code>isresponse</code> function evaluates to true.</p><p>The <code>isresponse</code> function will be called anytime an event occurs. It should take one parameter (the event that just occured).</p><p>If the response is provided before <code>atleast</code> seconds, the moment does not start until <code>atleast</code> seconds have passed.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/trial.jl#L409-L419">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.record" href="#Weber.record"><code>Weber.record</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">record(code;keys...)</code></pre><p>Record a row to the experiment data file using a given <code>code</code>.</p><p>Each event has a code which identifies it as being a particular type of experiment event. This is normally a string. Each keyword argument is the value of a column (with the same name). By convention when you record something with the same code you should specify the same set of columns.</p><p>All calls to record also result in many additional values being written to the data file. The start time and date of the experiment, the trial and offset number, the version of Weber, and the time at which the last moment started are all stored.  Additional information can be added during creation of the experiment (see <code>Experiment</code>).</p><p>Each call to record writes a new row to the data file used for the experiment, so there should be no loss of data if the program is terminated prematurely for some reason.</p><div class="admonition note"><div class="admonition-title">Automatically Recorded Codes</div><div class="admonition-text"><p>There are several codes that are automatically recorded by Weber. They include:</p><ol><li><p><strong>trial_start</strong> - recorded at the start of moments added by <code>addtrial</code></p></li><li><p><strong>practice_start</strong> - recorded at the start of moments added by <code>addpractice</code></p></li><li><p><strong>break_start</strong> - recorded at the start of moments added by <code>addbreak</code></p></li><li><p><strong>high_latency</strong> - recorded whenever a high latency warning is triggered. The &quot;value&quot; column is set to the error between the actual and the desired timing of a moment, in seconds.</p></li><li><p><strong>paused</strong> - recorded when user hits &#39;escape&#39; and the experiment is paused.</p></li><li><p><strong>unpaused</strong> - recorded when the user ends the pause, continuuing the experiment.</p></li><li><p><strong>terminated</strong> - recorded when the user manually terminates the experiment (via &#39;escape&#39;)</p></li><li><p><strong>closed</strong> - recorded just before the experiment window closes</p></li></ol></div></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/trial.jl#L90-L127">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.timeout" href="#Weber.timeout"><code>Weber.timeout</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">timeout(fn,isresponse,timeout,[atleast=0.0])</code></pre><p>This moment starts when either <code>isresponse</code> evaluates to true or timeout time (in seconds) passes.</p><p>The <code>isresponse</code> function will be called anytime an event occurs. It should take one parameter (the event that just occured).</p><p>If the moment times out, the function <code>fn</code> (with no arguments) will be called.</p><p>If the response is provided before <code>atleast</code> seconds, the moment does not begin until <code>atleast</code> seconds (<code>fn</code> will not be called).</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/trial.jl#L428-L441">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.show_cross" href="#Weber.show_cross"><code>Weber.show_cross</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">show_cross([delta_t])</code></pre><p>Creates a moment that shows a cross hair <code>delta_t</code> seconds after the start of the previous moment (defaults to 0 seconds).</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/primitives.jl#L128-L133">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.when" href="#Weber.when"><code>Weber.when</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">when(condition,moments...)</code></pre><p>This moment will begin at the <em>start</em> of the previous moment, and presents the following moments (possibly in nested iterable objects) if the <code>condition</code> function (which takes no arguments) evaluates to true.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/trial.jl#L475-L481">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.looping" href="#Weber.looping"><code>Weber.looping</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">looping(when=fn,moments...)</code></pre><p>This moment will begin at the <em>start</em> of the previous moment, and repeats the listed moments (possibly in nested iterable objects) until the <code>when</code> function (which takes no arguments) evaluates to false.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/trial.jl#L464-L470">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.@addtrials" href="#Weber.@addtrials"><code>Weber.@addtrials</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@addtrials expr...</code></pre><p>Marks a let block, a for loop, or an if expression as dependent on experiment <a href="../start/#setup_time-1">run-time</a> state, leaving the offset counter unincremented within that block.  The immediately proceeding loop or conditional logic will be run during experiment run-time rather than setup-time.</p><p>Refer to the <a href="../advanced/"><code>Advanced Topics</code></a> of the manual section for more details.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/trial.jl#L203-L213">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.update!" href="#Weber.update!"><code>Weber.update!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">update!(adapter,response,correct)</code></pre><p>Updates any internal state for the adapter when the listener responds with <code>response</code> and the correct response is <code>correct</code>. Usually not called directly, but instead called within <code>response</code>, when the adapter is passed as the first argument. May take a while to run.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/adaptive.jl#L7-L14">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.estimate" href="#Weber.estimate"><code>Weber.estimate</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">estimate(adapter)</code></pre><p>Returns the mean and error of the adapters threshold estimate. May take some time to run.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/adaptive.jl#L18-L23">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.delta" href="#Weber.delta"><code>Weber.delta</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">delta(adapter)</code></pre><p>Returns the next delta that should be tested to help estimate the threshold.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/adaptive.jl#L27-L31">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.oddball_paradigm" href="#Weber.oddball_paradigm"><code>Weber.oddball_paradigm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">oddball_paradigm(trial_body_fn,n_oddballs,n_standards;
                 lead=20,no_oddball_repeats=true)</code></pre><p>Helper to generate trials for an oddball paradigm.</p><p>The trial_body_fn should setup stimulus presentation: it takes one argument, indicating if the stimulus should be a standard (false) or oddball (true) stimulus.</p><p>It is usually best to use oddball_paradigm with a do block syntax. For instance, the following code sets up 20 oddball and 150 standard trials.</p><pre><code class="language-none">oddball_paradigm(20,150) do isoddball
  if isoddball
    addtrial(...create oddball trial here...)
  else
    addtrial(...create standard trial here...)
  end
end</code></pre><p><strong>Keyword arguments</strong></p><ul><li><p><strong>lead</strong>: determines the number of standards that repeat before any oddballs get presented</p></li><li><p><strong>no_oddball_repeats</strong>: determines if at least one standard must occur between each oddball (true) or not (false).</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/primitives.jl#L76-L103">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.levitt_adapter" href="#Weber.levitt_adapter"><code>Weber.levitt_adapter</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">levitt_adapter([first_delta=0.1],[down=3],[up=1],
               [big_reverse=3],[big=0.01],[little=0.005],
               [min_reversals=7],[min_delta=-Inf],[max_delta=Inf],
               [mult=false])</code></pre><p>An adapter that finds a threshold according to a non-parametric statistical procedure. This approach makes fewer explicit assumptions than <a href="#Weber.bayesian_adapter"><code>bayesian_adapter</code></a> but may be slower to converge to a threshold.</p><p>This finds a threshold by moving the delta down after three correct responses and up after one incorrect response (these default up and down counts can be changed). This is the same approach described in Levitt (1971).</p><p><strong>Keyword Arguments</strong></p><ul><li><p><code>first_delta</code>: the delta that the first trial should present.</p></li><li><p><code>up</code>: how many incorrect responses in a row must occur for the delta to move up</p></li><li><p><code>down</code>: how many correct responses in a row must occur for the delta to move down.</p></li><li><p><code>big</code>: the amount delta changes by (up or down) at first</p></li><li><p><code>big_reverse</code>: how many reveresals (up to down or down to up) must occur before <code>little</code> is used instead of <code>big</code></p></li><li><p><code>little</code>: the amount delta changes by (up or down) after <code>big_reverse</code> reversals.</p></li><li><p><code>min_reversals</code>: the smallest number of reversals that can be used to estimate a threshold.</p></li><li><p><code>min_delta</code>: the smallest delta allowed</p></li><li><p><code>max_delta</code>: the largest delta allowed</p></li><li><p><code>mult</code>: whether the delta change should be additive (false) or  multiplicative (true).</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/adaptive.jl#L137-L169">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.bayesian_adapter" href="#Weber.bayesian_adapter"><code>Weber.bayesian_adapter</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">bayesian_adapter(;first_delta=0.1,
                 n_samples=1000,miss=0.01,threshold=0.79,
                 min_delta=0,max_delta=1,
                 min_plausible_delta = 0.0001,
                 max_plausible_delta = 0.2,
                 repeat3_thresh=1.0,repeat2_thresh=0.1,
                 thresh_prior=
                 Truncated(LogNormal(log(min_plausible_delta),
                                     log(max_plausible_delta/
                                         min_plausible_delta/2)),
                           min_delta,max_delta),
                      inv_slope_prior=TruncatedNormal(0,0.25,0,Inf),
                      thresh_d=thresh_prior,
                      inv_slope_d=inv_slope_prior)</code></pre><p>An adapter that finds a threshold according to a parametric statistical model. This makes more explicit assumptions than the <a href="#Weber.levitt_adapter"><code>levitt_adapter</code></a> but will normally find a threshold faster.</p><p>The psychometric curve is estimated from user responses using a bayesian approach. After estimation, each new delta is selected in a greedy fashion, picking the response that best minimizes entropy according to this psychometric function. This is a modified version of the approach described in Kontsevich &amp; Tyler 1999. Specifically, the approach here uses importance sampling instead of sampling parmeters over a deterministic, uniform grid. This should increase measurement efficiency if the priors are chosen well.</p><p>This algorithm assumes the following functional form for the psychometric response as a function of the stimulus difference <span>$Δ$</span>.</p><p><span>$f(Δ) = λ/2 + (1-λ) Φ((Δ - θ)⋅σ/√2)$</span></p><p>In the above <span>$Φ$</span> is the cumulative distribution function of a normal distribution, <span>$λ$</span> is the miss-rate parameter, indicating the rate at which listeners make a mistake, even when the delta is large and easily heard, <span>$θ$</span> is the 50%-correct threshold, and <span>$σ$</span> is the psychometric slope.</p><p>For stability and robustness, this adapter begins by repeating the same delta multiple times and only begins quickly changing deltas trial-by-trial when the ratio of estiamted standard deviation to mean is small. This functionality can be adjusted using <code>repeat3_thresh</code> and <code>repeat2_thresh</code>, or, if you do not wish to have any repeats, both values can be set to Inf.</p><p><strong>Keyword Arugments</strong></p><ul><li><p><strong>first_delta</strong>: the delta to start measuring with</p></li><li><p><strong>n_samples</strong> the number of samples to use during importance sampling. The algorithm for selecting new deltas is O(n²).</p></li><li><p><strong>miss</strong> the expected rate at which listeners will make mistakes even for easy to percieve differences.</p></li><li><p><strong>threshold</strong> the %-response threshold to be estimated</p></li><li><p><strong>min_delta</strong> the smallest possible delta</p></li><li><p><strong>max_delta</strong> the largest possible delta</p></li><li><p><strong>min_plausible_delta</strong> the smallest plausible delta, should be &gt; 0. Used to define a reasonable value for thresh_prior and inv_slope_prior.</p></li><li><p><strong>max_plausible_delta</strong> the largest plausible delta, should be &lt; max_delta. Used to define a reasonable value for thresh_prior and inv_slope_prior.</p></li><li><p><strong>thresh_prior</strong> the prior probability distribution across thresholds. This influence the way the delta is adapted. By default this is defined in terms of min_plausible_delta and max_plausible_delta.</p></li><li><p><strong>inv_slope_prior</strong> the prior probability distribution across inverse slopes. By default this is defined in terms of min_plausible_delta and max_plausible_delta.</p></li><li><p><strong>thresh_d</strong> the distribution over-which to draw samples for the threshold during importance sampling. This defaults to thresh_prior</p></li><li><p><strong>inv_slope_d</strong> the distribution over-which to draw samples for the inverse slope during importance sampling. This defaults to inv_slope_prior.</p></li><li><p><strong>repeat2_thresh</strong> the ratio of sd / mean for theta must suprass to repeat each delta twice.</p></li><li><p><strong>repeat3_thresh</strong> the ratio of sd / mean for theta must surpass to repeat each delta thrice.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/adaptive.jl#L296-L370">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.constant_adapter" href="#Weber.constant_adapter"><code>Weber.constant_adapter</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">constant_adapter(stimuli)</code></pre><p>An adapter that can be used to implement the method of constant stimuli: the specified sequence of stimulus deltas is presented in order to participants.</p><p>Strictly speaking, this is not an adaptive tracking procedure. However, it can be convienient to have the same programming interface for this method as for adaptive methods. In this way you can easily select between the method of constant stimuli or some kind of adaptive procedure.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/src/adaptive.jl#L113-L123">source</a><br/></section><footer><hr/><a class="previous" href="../experiment/"><span class="direction">Previous</span><span class="title">Experiments</span></a><a class="next" href="../sound/"><span class="direction">Next</span><span class="title">Sound</span></a></footer></article></body></html>
