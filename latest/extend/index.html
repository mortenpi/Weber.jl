<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Extending Weber · Weber.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Weber.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><span class="toctext">User guide</span><ul><li><a class="toctext" href="../start/">Getting Started</a></li><li><a class="toctext" href="../trial_guide/">Trial Creation</a></li><li><a class="toctext" href="../stimulus/">Stimulus Generation</a></li><li><a class="toctext" href="../adaptive/">Adaptive Tracks</a></li><li><a class="toctext" href="../advanced/">Advanced Experiments</a></li><li class="current"><a class="toctext" href>Extending Weber</a><ul class="internal"><li><a class="toctext" href="#Custom-Events-1">Custom Events</a></li><li><a class="toctext" href="#Custom-Moments-1">Custom Moments</a></li><li class="toplevel"><a class="toctext" href="#Registering-Your-Extension-1">Registering Your Extension</a></li></ul></li></ul></li><li><span class="toctext">Reference</span><ul><li><a class="toctext" href="../experiment/">Experiments</a></li><li><a class="toctext" href="../trials/">Trials</a></li><li><a class="toctext" href="../sound/">Sound</a></li><li><a class="toctext" href="../video/">Video</a></li><li><a class="toctext" href="../event/">Events</a></li><li><a class="toctext" href="../extend_ref/">Extensions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>User guide</li><li><a href>Extending Weber</a></li></ul><a class="edit-page" href="https://github.com/haberdashPI/Weber.jl/tree/094bb7a81fb349c1297888576c20bdeaf16b63c9/docs/src/extend.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Extending Weber</span><a class="fa fa-bars" href="#"></a></div></header><p>Functionality can be added to Weber via extensions. You can add multiple extensions to the same experiment. The <a href="../extend_ref/">reference</a> provides a list of available extensions. Here we&#39;ll cover how to create new extensions.</p><p>Extensions can create new methods of existing Weber functions on custom types, just like any Julia package, and this may be all that&#39;s necessary to extend Weber.</p><p>However, extensions also have several ways to insert additional behavior into a number of methods via special extension machinery.</p><ul><li><p><a href="../experiment/#Weber.addcolumn"><code>addcolumn</code></a></p></li><li><p><a href="../experiment/#Weber.setup"><code>setup</code></a></p></li><li><p><a href="../experiment/#Base.run"><code>run</code></a></p></li><li><p><a href="../trials/#Weber.record"><code>record</code></a></p></li><li><p><a href="../trials/#Weber.addtrial"><code>addtrial</code></a></p></li><li><p><a href="../trials/#Weber.addpractice"><code>addpractice</code></a></p></li><li><p><a href="../trials/#Weber.addbreak"><code>addbreak</code></a></p></li><li><p><a href="../extend_ref/#Weber.poll_events"><code>poll_events</code></a></p></li></ul><p>To extend one of these functions you first define an extension type. For example:</p><pre><code class="language-julia">type MyExtension &lt;: Weber.Extension
  my_value::String
end</code></pre><p>For all of the public functions above (everything but <code>poll_events</code>), you can then define a new method of these functions that includes one additional argument beyond that listed in its documentation, located before all other arguments. This argument should be of type <code>ExtendedExperiment{MyExtension}</code>. To extend the private <code>poll_events</code> function, replace the <code>Experiment</code> argument with an <code>ExtendedExperiment{MyExtension}</code> argument.</p><div class="admonition warning"><div class="admonition-title">Don&#39;t extend unlisted functions</div><div class="admonition-text"><p>These functions have specific machinery setup to make extension possible. Don&#39;t use this same approach with other functions and expect your extension to work.</p></div></div><p>As an example, <a href="../trials/#Weber.record"><code>record</code></a> could be extended as follows.</p><pre><code class="language-julia">function record(experiment::ExtendedExperiment{MyExtension},code;keys...)
  record(next(experiment),code;my_extension=extension(experiment).my_value,keys...)
end</code></pre><p>There are a few things to note about this implementation. First,  the extension object is accessed using <a href="../extend_ref/#Weber.extension-Tuple{Weber.ExtendedExperiment}"><code>extension</code></a>.</p><p>Second, <code>record</code> is called on the <a href="../extend_ref/#Base.next-Tuple{Weber.ExtendedExperiment}"><code>next</code></a> extension.  <strong>All extended functions should follow this pattern</strong>. Each experiment can have multiple extensions, and each pairing of an experiment with a particular extension is called an experiment <em>version</em>. These are ordered from top-most to bottom-most version. The top-most version is paired with the first extension in the list specified during the call to <a href="../experiment/#Weber.Experiment"><code>Experiment</code></a>. Subsequent versions are accessed in this same order, using <a href="../extend_ref/#Base.next-Tuple{Weber.ExtendedExperiment}"><code>next</code></a>, until the bottom-most version, which is the experiment without any paired extension.</p><p>For the extension to <code>record</code> to actually work, <code>setup</code> must also be extended to add the column <code>:my_extension</code> to the data file.</p><pre><code class="language-julia">function setup(fn::Function,experiment::ExtendedExperiment{MyExtension})
  setup(next(experiment)) do
    addcolumn(top(experiment),:my_extension)
    fn()
  end
end</code></pre><p>This demonstrates one last important concept. When calling <code>addcolumn</code>, the function <a href="../extend_ref/#DataStructures.top-Tuple{Weber.Experiment}"><code>top</code></a> is called on the experiment to get the top-most version of the experiment. This is done so that any functionality of versions above the current one will be utilized in the call to <code>addcolumn</code>.</p><div class="admonition note"><div class="admonition-title">When to use `next` and `top`</div><div class="admonition-text"><p>As a general rule, inside an extended method, when you dispatch over the same function which that method implements, you should pass it <code>next(experiment)</code> while all other functions taking an experiment argument should be passed <code>top(experiment)</code>.</p></div></div><h1><a class="nav-anchor" id="The-private-interface-of-run-time-objects.-1" href="#The-private-interface-of-run-time-objects.-1">The private interface of run-time objects.</a></h1><p>Most of the functionality above is for the extension of <a href="../start/#setup_time-1">setup-time</a> behavior. However, there are two ways to implement new run-time behavior: the generation of custom events and custom moments.</p><h2><a class="nav-anchor" id="Custom-Events-1" href="#Custom-Events-1">Custom Events</a></h2><p>Extensions to <a href="../extend_ref/#Weber.poll_events"><code>poll_events</code></a> can be used to notify watcher functions of new kinds of events. An event is an object that inherits from <code>Weber.ExpEvent</code> and which is tagged with the <a href="../event/#Weber.@event"><code>@event</code></a> macro. Custom events can implement new methods for the existing <a href="../event/">public functions on events</a> or their own new functions.</p><p>If you define new functions, instead of leveraging the existing ones, they should generally have some default behavior for all <code>ExpEvent</code> objects, so it is easy to call the method on any event a watcher moment receives.</p><h3><a class="nav-anchor" id="Event-Timing-1" href="#Event-Timing-1">Event Timing</a></h3><p>To specify event timing, you must define a <code>time</code> method for your custom event. You can simply store the time passed to <a href="../extend_ref/#Weber.poll_events"><code>poll_events</code></a> in your custom event, or, if you have more precise timing information for your hardware you can store it here. Internally, the value returend by <code>time</code> is used to determine when to run the next moment when a prior moment triggers on the event.</p><h3><a class="nav-anchor" id="Custom-Key-Events-1" href="#Custom-Key-Events-1">Custom Key Events</a></h3><p>One approach, if you are implementing events for a hardware input device, is to implement methods for <a href="../event/#Weber.iskeydown"><code>iskeydown</code></a>. You can define your own type of keycode (which should be of some new custom type <code>&lt;: Weber.Key</code>). Then, you can make use of the <a href="../event/#Weber.@key_str"><code>@key_str</code></a> macro by adding entries to the <code>Weber.str_to_code</code> dictionary (a private global constant). So for example, you could add the following to the module implementing your extension.</p><pre><code class="language-julia">Weber.str_to_code[&quot;my_button1&quot;] = MyHardwareKey(1)
Weber.str_to_code[&quot;my_button1&quot;] = MyHardwareKey(2)</code></pre><p>Such key types should implement <code>==</code>, <code>hash</code> and <code>isless</code> so that key events can be ordered. This allows them to be displayed in an organized fashion when printed using <a href="../event/#Weber.listkeys"><code>listkeys</code></a>.</p><p>Once these events are defined you can extend <a href="../extend_ref/#Weber.poll_events"><code>poll_events</code></a> so that it generates events that return true for <code>iskeydown(myevent,key&quot;my_button1&quot;)</code> (and a corresponding method for <code>iskeyup</code>). How this happens will depend on the specific hardware you are supporting. These new events could then be used in an experiment as follows.</p><pre><code class="language-julia">response(key&quot;my_button1&quot; =&gt; &quot;button1_pressed&quot;,
         key&quot;my_button2&quot; =&gt; &quot;button2_pressed&quot;)</code></pre><h2><a class="nav-anchor" id="Custom-Moments-1" href="#Custom-Moments-1">Custom Moments</a></h2><p>You can create your own moment types, which must be children of <code>Weber.SimpleMoment</code>. These new moments will have to be generated using some newly defined function, or added automatically by extending <a href="../trials/#Weber.addtrial"><code>addtrial</code></a>. Once created, and added to trials, these moments will be processed at run-time using the function <a href="../extend_ref/#Weber.handle"><code>handle</code></a>, which should define the moment&#39;s run-time behavior. Such a moment must also define <a href="../extend_ref/#Weber.moment_trace"><code>moment_trace</code></a>.</p><p>A moment can also define <a href="../extend_ref/#Weber.delta_t"><code>delta_t</code></a>–to define when it occurs–or <a href="../extend_ref/#Weber.prepare!"><code>prepare!</code></a>–to have some kind of initialization occur before its onset–but these both have default implementations.</p><p>Methods of <a href="../extend_ref/#Weber.handle"><code>handle</code></a> should not make use of the extension machinery described above. What this means is that methods of <a href="../extend_ref/#Weber.handle"><code>handle</code></a> should never dispatch on an extended experiment, and no calls to <a href="../extend_ref/#DataStructures.top-Tuple{Weber.Experiment}"><code>top</code></a>, <a href="../extend_ref/#Base.next-Tuple{Weber.ExtendedExperiment}"><code>next</code></a> or <a href="../extend_ref/#Weber.extension-Tuple{Weber.ExtendedExperiment}"><code>extension</code></a> should occur on the experiment object. Further, each moment should belong to one specific extension, in which all functionality for that custom moment should be implemented.</p><h1><a class="nav-anchor" id="Registering-Your-Extension-1" href="#Registering-Your-Extension-1">Registering Your Extension</a></h1><p>Optionally, you can make it possible for users to extend Weber without ever having to manually download or import your extension.</p><p>To do so you register your extension using the <a href="../extend_ref/#Weber.@extension"><code>@Weber.extension</code></a> macro. This macro is not exported and should not be called within your extensions module. Instead you should submit a pull request to <a href="https://github.com/haberdashPI/Weber.jl/pulls">Weber</a> with your new extension defintion added to <code>extensions.jl</code>. Once your extension is also a registered package with <a href="https://github.com/JuliaLang/METADATA.jl">METADATA.jl</a> it can be downloaded the first time a user initializes your extension using its corresponding macro.</p><footer><hr/><a class="previous" href="../advanced/"><span class="direction">Previous</span><span class="title">Advanced Experiments</span></a><a class="next" href="../experiment/"><span class="direction">Next</span><span class="title">Experiments</span></a></footer></article></body></html>
