<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Extensions · Weber.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Weber.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><span class="toctext">User guide</span><ul><li><a class="toctext" href="../start/">Getting Started</a></li><li><a class="toctext" href="../trial_guide/">Trial Creation</a></li><li><a class="toctext" href="../stimulus/">Stimulus Generation</a></li><li><a class="toctext" href="../adaptive/">Adaptive Tracks</a></li><li><a class="toctext" href="../advanced/">Advanced Experiments</a></li><li><a class="toctext" href="../extend/">Extending Weber</a></li></ul></li><li><span class="toctext">Reference</span><ul><li><a class="toctext" href="../experiment/">Experiments</a></li><li><a class="toctext" href="../trials/">Trials</a></li><li><a class="toctext" href="../sound/">Sound</a></li><li><a class="toctext" href="../video/">Video</a></li><li><a class="toctext" href="../event/">Events</a></li><li class="current"><a class="toctext" href>Extensions</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Creating-Extensions-1">Creating Extensions</a></li><li><a class="toctext" href="#Functions-operating-over-extensions-1">Functions operating over extensions</a></li><li><a class="toctext" href="#Extendable-Private-Functions-1">Extendable Private Functions</a></li><li><a class="toctext" href="#Private-Moment-Functions-1">Private Moment Functions</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Reference</li><li><a href>Extensions</a></li></ul><a class="edit-page" href="https://github.com/haberdashPI/Weber.jl/tree/84de2793f6f34dfab0da9355e83a63c64819816e/docs/src/extend_ref.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Extensions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Available-Extensions-1" href="#Available-Extensions-1">Available Extensions</a></h1><p>Extensions provide additional functionality for Weber. Currently there are two extensions availble:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.@Cedrus" href="#Weber.@Cedrus"><code>Weber.@Cedrus</code></a> — <span class="docstring-category">Macro</span>.</div><div><p><a href="https://github.com/haberdashPI/WeberCedrus.jl">Extension Website</a></p><pre><code class="language-none">@Cedrus()</code></pre><p>Creates an extension for Weber allowing experiments to respond to events from Cedrus response-pad hardware. You can use <a href="../event/#Weber.iskeydown"><code>iskeydown</code></a> and <a href="../event/#Weber.iskeyup"><code>iskeyup</code></a> to check for events. To find the keycodes of the buttons for your response pad, run the following code, and press each of the buttons on the response pad.</p><pre><code class="language-none">run_keycode_helper(extensions=[@Cedrus()])</code></pre><div class="admonition warning"><div class="admonition-title">Do not call inside a package</div><div class="admonition-text"><p>Do not call @Cedrus inside of a package or in tests. It should only be used in one-off scripts. If WeberCedrus is not currently installed it will be installed by this macro using <code>Pkg.add</code> which can lead to problems when called in packages or tests.</p><p>If you want to include an extension without this behavior you can call @Cedrus_safe which mimics @Cedrus except that it will never call <code>Pkg.add</code>.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/84de2793f6f34dfab0da9355e83a63c64819816e/src/extensions.jl#L1-L26">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.@DAQmx" href="#Weber.@DAQmx"><code>Weber.@DAQmx</code></a> — <span class="docstring-category">Macro</span>.</div><div><p><a href="https://github.com/haberdashPI/WeberDAQmx.jl">Extension Website</a></p><pre><code class="language-none">@DAQmx(port;eeg_sample_rate,[codes])</code></pre><p>Create a Weber extension that writes <code>record</code> events to a digital out line via the DAQmx API. This can be used to send trigger codes during eeg recording.</p><p><strong>Arguments</strong></p><ul><li><p>port: should be <code>nothing</code>, to disable the extension, or the port name for the digital output line.</p></li><li><p>eeg_sample_rate: should be set to the sampling rate for eeg recording. This calibrates the code length for triggers.</p></li><li><p>codes: a Dict that maps record event codes (a string) to a number. This should be an Integer less than 256. Any codes not specified here will be automatically set, based on the order in which codes are recieved.</p></li></ul><p><strong>Example</strong></p><p>The following experiment sends the code 0x01 to port0 on TestDevice.</p><pre><code class="language-none">port = &quot;/TestDevice/port0/line0:7&quot;
experiment = Experiment(extensions=[
  @DAQmx(port;eeg_sample_rate=512,codes=Dict(&quot;test&quot; =&gt; 0x01))])
setup(experiment) do
  addtrial(moment(record,&quot;test&quot;))
end
run(experiment)</code></pre><div class="admonition warning"><div class="admonition-title">Do not call inside a package</div><div class="admonition-text"><p>Do not call @DAQmx inside of a package or in tests. It should only be used in one-off scripts. If WeberDAQmx is not currently installed it will be installed by this macro using <code>Pkg.add</code> which can lead to problems when called in packages or tests.</p><p>If you want to include an extension without this behavior you can call @DAQmx_safe which mimics @DAQmx except that it will never call <code>Pkg.add</code>.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/84de2793f6f34dfab0da9355e83a63c64819816e/src/extensions.jl#L18-L61">source</a><br/></section><h1><a class="nav-anchor" id="Creating-Extensions-1" href="#Creating-Extensions-1">Creating Extensions</a></h1><p>The following functions are used when <a href="../extend/">extending experiments</a>.</p><p>To register your extension within Weber, so users can import your extension with ease, you use can use the <code>@extension</code> macro.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.@extension" href="#Weber.@extension"><code>Weber.@extension</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@extension [Symbol] begin
  [docstring...]
end</code></pre><p>Registers a given Weber extension. This creates a macro called <code>@[Symbol]</code> which imports <code>Weber[Symbol]</code> and calls <code>Weber[Symbol].InitExtension</code>, with the given arguments. InitExtension should return either <code>nothing</code> or an extension object.</p><p>The doc string is used to document the usage of the extension, and should normally include a link to the website of a julia package for the extension.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/84de2793f6f34dfab0da9355e83a63c64819816e/src/extension_macro.jl#L34-L47">source</a><br/></section><h2><a class="nav-anchor" id="Functions-operating-over-extensions-1" href="#Functions-operating-over-extensions-1">Functions operating over extensions</a></h2><p>These functions operate directly on an <code>ExtendedExperiment</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.next-Tuple{Weber.ExtendedExperiment}" href="#Base.next-Tuple{Weber.ExtendedExperiment}"><code>Base.next</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none"> next(experiment::ExtendedExperiment)</code></pre><p>Get the next extended version of this experiment.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/84de2793f6f34dfab0da9355e83a63c64819816e/src/types.jl#L760-L764">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataStructures.top-Tuple{Weber.Experiment}" href="#DataStructures.top-Tuple{Weber.Experiment}"><code>DataStructures.top</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">top(experiment::Experiment)</code></pre><p>Get the the top-most extended verison for this experiment, if any.</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/84de2793f6f34dfab0da9355e83a63c64819816e/src/types.jl#L731-L735">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.extension-Tuple{Weber.ExtendedExperiment}" href="#Weber.extension-Tuple{Weber.ExtendedExperiment}"><code>Weber.extension</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">extension(experiment::ExtendedExperiment)</code></pre><p>Get the extension object for this extended expeirment</p></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/84de2793f6f34dfab0da9355e83a63c64819816e/src/types.jl#L747-L751">source</a><br/></section><h2><a class="nav-anchor" id="Extendable-Private-Functions-1" href="#Extendable-Private-Functions-1">Extendable Private Functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.poll_events" href="#Weber.poll_events"><code>Weber.poll_events</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none"> Weber.poll_events(callback,experiment,time)</code></pre><p>Call the function <code>callback</code>, possibility multiple times, passing it an event object each time. The time at which the events are polled is passed, allowing this time to be stored with the event.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>This function should never be called directly by user code. A new method of this function can be implemented to extend Weber, allowing it to report new kinds events.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/84de2793f6f34dfab0da9355e83a63c64819816e/src/event.jl#L24-L37">source</a><br/></section><h2><a class="nav-anchor" id="Private-Moment-Functions-1" href="#Private-Moment-Functions-1">Private Moment Functions</a></h2><p>New <code>Weber.SimpleMoment</code> subtypes can define methods for the following functions to extend the runtime behavior of Weber.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.prepare!" href="#Weber.prepare!"><code>Weber.prepare!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">Weber.prepare!(m,[onset_s])</code></pre><p>If there is anything the moment needs to do before it occurs, it is done during <code>prepare!</code>. Prepare can be used to set up precise timing even when hardware latency is high, if that latency can be predicted, and accounted for. A moment&#39;s prepare! method is called just before the first non-zero pause between moments that occurs before this moment: in the simplest case, when this moment has a non-zero value for <a href="#Weber.delta_t"><code>delta_t</code></a>, preapre! will occur <code>delta_t</code> seconds before this moment. However, if several moments with no pause occur, prepare! will occur before all of those moments as well.</p><p>Prepare accepts an optional second argument used to indicate the time, in seconds from the start of the experiemnt when this moment will begin (as a Float64).  This argument may be Inf, indicating that it is not possible to predict when the moment will occur at this point, because the timing depends on some stateful information (e.g. a participant&#39;s response). It is accetable in this case to throw an error, explaining that this kind of moment must be able to know precisely when it occurs to be prepared.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>This method is part of the private interface for moments. It should not be called directly, but implemented as part of an extension. You need only extend the method taking a single arugment unless you intend to use this information during prepartion.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/84de2793f6f34dfab0da9355e83a63c64819816e/src/trial.jl#L489-L515">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.handle" href="#Weber.handle"><code>Weber.handle</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">handle(exp,queue,moment,to_handle)</code></pre><p>Internal method to handle the given moment object in a manner specific to its type.</p><p>The function <code>handle</code> is only called when the appropriate time has been reached for the next moment to be presented (according to <a href="#Weber.delta_t"><code>delta_t</code></a>) or when an event occurs.</p><p>The <code>to_handle</code> object is either a <code>Float64</code>, indicating the current experiment time, or it is an <code>ExpEvent</code> indicating the event that just occured. As an example, a timed moment, will run when it recieves any <code>Float64</code> value, but nothing occurs when passed an event.</p><p>The queue is a <code>MomentQueue</code> object, which has the same interface as the <code>Dequeue</code> object (from the <code>DataStructures</code> package) but it is also iterable. Upon calling handle, <code>top(queue) == moment</code>.</p><p>Handle should return a boolean indicating whether the event was &quot;handled&quot; or not. If unhandled, the moment should remain on top of the queue. If returning true, handle should <em>normally</em> remove the top moment from the queue. Exceptions exist (for instance, to allow for loops), but one does not normally need to implement custom moments that have such behavior.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>This method is part of the private interface for moments. It should not be called directly, but implemented as part of an extension. It is called during the course of running an experiment.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/84de2793f6f34dfab0da9355e83a63c64819816e/src/trial.jl#L563-L594">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.moment_trace" href="#Weber.moment_trace"><code>Weber.moment_trace</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">moment_trace(m)</code></pre><p>Returns the stacktrace indicating where this moment was defined.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>This method is part of the private interface for moments. It should not be called directly, but implemented as part of an extension.  You can get a stacktrace inside the function you define that constructs your custom moment using <code>stacktrace()[2:end]</code>.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/84de2793f6f34dfab0da9355e83a63c64819816e/src/types.jl#L399-L410">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Weber.delta_t" href="#Weber.delta_t"><code>Weber.delta_t</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">delta_t(m::AbstractMoment)</code></pre><p>Returns the time, since the start of the previous moment, at which this moment should begin. The default implementation returns zero.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>This method is part of the private interface for moments. It should not be called directly, but implemented as part of an extension.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/haberdashPI/Weber.jl/tree/84de2793f6f34dfab0da9355e83a63c64819816e/src/types.jl#L382-L392">source</a><br/></section><footer><hr/><a class="previous" href="../event/"><span class="direction">Previous</span><span class="title">Events</span></a></footer></article></body></html>
